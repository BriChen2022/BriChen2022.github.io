<!DOCTYPE html><html lang="cn" theme-mode="light"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>插值方法（多项式插值） | BriChen's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/brands.min.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Brands';
 src: local('Font Awesome 6 Brands'), url('/lib/fontawesome/fa-brands.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Free';
 src: local('Font Awesome 6 Free'), url('/lib/fontawesome/fa-regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/contact/"><span class="navItemTitle">Contact</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>插值方法（多项式插值）</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2022-10-10T23:02:37.000Z" id="date"> 2022-10-11</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-05-15T08:37:43.236Z" id="updated"> 2023-05-15</time></div></span></div></div><hr><div id="post-content"><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1>
<h2 id="例子容格函数"><a href="#例子：容格函数" class="headerlink" title="例子：容格函数"></a>例子：容格函数</h2>
<h2 id="情形"><a href="#情形" class="headerlink" title="情形"></a>情形</h2>
<ul>
<li>函数以表格的形式呈现</li>
<li>函数有解析式但太复杂不便于计算</li>
</ul>
<p><strong>插值函数的目的是: (1)用更精炼的函数描述离散数据
(2)构造既能反映函数本身性质又能便于计算的简单函数</strong> ##
插值方法概括
由于多项式函数的形式最简单且便于计算,本节主要讨论的都是多项式插值理论和构造方法.
- Lagrange插值方法.由基函数构造,容易拓展到高维 -
Newton插值方法.适合增减插值节点的情况 - Hermit插值方法. -
分段插值方法.为避免Runge现象. # 插值问题 ## 插值问题定义 - 被插值函数 -
插值节点 - 插值条件 - 插值多项式 - 插值余项,也即误差 ##
插值多项式的存在唯一性定理
<strong>定理</strong>:给定互异的n+1个节点及其对应函数值，则存在唯一次数不超过n的多项式满足已给定的n+1个插值条件。</p>
<p><strong>定理证明：Vandermond矩阵</strong>
实际求解线性方程组不会这样做（ 待定系数法） - 这个矩阵是病态的 -
待定系数法计算量大 -
存在唯一性指的是待定的系数是存在且唯一的，多项式的表示形式是多样的不唯一的</p>
<h2 id="余项公式定理"><a href="#余项公式定理" class="headerlink" title="余项公式定理"></a>余项公式定理</h2>
<p>这个定理用来说明插值多项式对被插值函数的逼近程序的好坏.</p>
<p><strong>定理</strong>:设<span
class="math inline">\(x_0,x_1,\cdots,x_n\)</span>是<span
class="math inline">\([a,b]\)</span>内<span
class="math inline">\(n+1\)</span>个互不相同的插值节点,且<span
class="math inline">\(x\in[a,b]\)</span>.又设<span
class="math inline">\(f\in C^{n+1}([a,b])\)</span>.则插值多项式<span
class="math inline">\(p_n\in P_n\)</span>在<span
class="math inline">\(x\)</span>点处的插值余项为,</p>
<p><span class="math display">\[
R_n(x)=f(x)-p_n(x)=\frac{f^{(n+1)}(\xi_x)}{(n+1)!}\pi_{n+1}(x)
\]</span></p>
<p>其中,<span class="math inline">\(\xi_x\in(a,b)\)</span>,<span
class="math inline">\(\pi_{n+1}(x)\)</span>为<span
class="math inline">\(n+1\)</span>次节点多项式,即,</p>
<p><span class="math display">\[
\pi_{n+1}(x)=\prod_{i=0}^{n}(x-x_i)
\]</span></p>
<p><strong>证明</strong>:构造辅助函数.</p>
<p><span class="math display">\[
\phi(T)=f(T)-p_n(T)-\frac{f(x)-p_n(x)}{\pi_{n+1}(x)}\pi_{n+1}(T),T\in
[a,b]
\]</span></p>
<p>容易验证,辅助函数有<span
class="math inline">\(n+2\)</span>个零点,分别<span
class="math inline">\(x,x_0,x_1,\cdots,x_n\)</span>.应用Rolle定理,
可以证明存在<span class="math inline">\(\xi_x\in(a,b)\)</span>,使得,</p>
<p><span class="math display">\[
\phi^{(n+1)}(\xi_x)=0
\]</span></p>
<p>于是对辅助函数求n+1次导有,</p>
<p><span class="math display">\[
\phi^{(n+1)}(\xi_x)=f^{(n+1)}(\xi_x)-0-\frac{f(x)-p_n(x)}{\pi_{n+1}(x)}(n+1)!=0
\]</span></p>
<p>整理后得证.</p>
<ul>
<li>这个定理说明了插值多项式对被插值函数逼近程度的好坏</li>
<li>证明是构造函数之后用Rolle定理</li>
<li>首系数为1的n+1次多项式求n+1次导结果为<span
class="math inline">\((n+1)!\)</span></li>
</ul>
<h1 id="lagrange插值方法"><a href="#Lagrange插值方法" class="headerlink" title="Lagrange插值方法"></a>Lagrange插值方法</h1>
<p>Lagrange插值方法主要避免了待定系数法的两个问题: -
求解线性方程组的计算量大 -
范德蒙德矩阵是病态的,所以待定系数法得到的插值多项式是不可靠的 ##
L插值定理 <strong>定理</strong>:设<span
class="math inline">\(x_0,x_1,\cdots,x_n\)</span>为<span
class="math inline">\(n+1\)</span>个互异节点,被插值函数<span
class="math inline">\(f(x)\)</span>在插值节点的函数值已知.那么存在唯一次数不超过<span
class="math inline">\(n\)</span>的L插值多项式<span
class="math inline">\(L_n(x)\in P_n\)</span>,满足插值条件,</p>
<p><span class="math display">\[
L_n(x_k)=f(x_k),k=0,1,\cdots,n
\]</span></p>
<p>而<span class="math inline">\(L_n(x)\)</span>多项式形如,</p>
<p><span class="math display">\[
L_n(x)=\sum_{k=0}^{n}l_{k,n}(x)f(x_k)
\]</span></p>
<p>其中,</p>
<p><span class="math display">\[
l_{k,n}(x)=\prod_{i=0,i\neq k}^{n}\frac{x-x_i}{x_k-x_i},k=0,1,\cdots,n
\]</span></p>
<p><strong>证明</strong>:由基函数要满足如下性质:</p>
<p><span class="math display">\[
l_{k,n}(x_j)=\left\{\begin{matrix}
1,j=k\\
0,j\neq k
\end{matrix}\right. \quad j,k=0,1,\cdots,n
\]</span></p>
<p>易知,<span class="math inline">\(l_{k,n}(x)\)</span>含有因子<span
class="math inline">\(\prod_{i=0,i\neq
k}^{n}(x-x_i)\)</span>,又由于这个因子与<span
class="math inline">\(l_{k,n}(x)\)</span>的次数相同为n,因此两者间只差一个常数.又由<span
class="math inline">\(l_{k,n}(x_k)=1\)</span>可以推得定理结论.</p>
<ul>
<li>插值基函数 也叫特征多项式</li>
<li>基函数这三个字其实体现的就是一种正交性</li>
<li>被插值函数为多项式的插值多项式就是它本身，从余项公式为0可以看出</li>
<li>变形形式 记<span
class="math inline">\(\pi_{n+1}(x)=\prod_{i=0}^{n}(x-x_i)\)</span>,则基函数可以表示成,</li>
</ul>
<p><span class="math display">\[
l_{k,n}(x)=\frac{\pi_{n+1}(x)}{x-x_k}\cdot
\frac{1}{\pi_{n+1}&#39;(x_k)},k=0,1,\cdots,n
\]</span></p>
<h2 id="l插值算法"><a href="#L插值算法" class="headerlink" title="L插值算法"></a>L插值算法</h2>
<p>2.3.2.1 可以发现插值基函数只与节点有关，可以提前计算出所需要的基函数
<strong>多元插值的方法（后面介绍</strong></p>
<h1 id="neville插值方法略过了"><a href="#Neville插值方法(略过了?)" class="headerlink" title="Neville插值方法(略过了?)"></a>Neville插值方法(略过了?)</h1>
<h1 id="newton插值方法"><a href="#Newton插值方法" class="headerlink" title="Newton插值方法"></a>Newton插值方法</h1>
<h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2>
<p>给定n+1个节点，Newton插值的目的同样是要找到一个次数不超过n次的多项式<span
class="math inline">\(N_n(x)\)</span>，<strong>既满足插值条件</strong>，且同时<span
class="math inline">\(N_n(x)\)</span>可以表示成<span
class="math inline">\(N_{n-1}(x)\)</span>和一个次数不超过n次的多项式的和的形式，也即，</p>
<p><span class="math display">\[
N_n(x)=N_{n-1}(x)+q(x)
\]</span></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2>
<ul>
<li>本质是L插值多项式的<strong>等价形式</strong></li>
<li>牛顿法<strong>最大的优点</strong>是当需要增加一个节点时可以在原来的基础上加上一项，而拉格朗日法则要完全重新计算（基函数，整个插值多项式都要重新算）
## 牛顿差商 由插值条件知，</li>
</ul>
<p><span class="math display">\[
q(x_i)=N_n(x_i)-N_{n-1}(x_i)=0,\quad i=0,1,\cdots,n-1
\]</span></p>
<p>因此,<span class="math inline">\(q(x)\)</span>应该含有因子<span
class="math inline">\(\prod_{i=0}^{n-1}(x-x_i)\)</span>,由于两者都是n次的多项式,所以他们之间只相差一个常数,而这可以用插值条件<span
class="math inline">\(N_n(x_n)=y_n\)</span>确定.</p>
<p><span class="math display">\[
N_n(x_n)=N_{n-1}(x_n)+q(x_n)
\]</span></p>
<p><span class="math display">\[
y_n-N_{n-1}(x)=q(x_n)=a_n\prod_{i=0}^{n-1}(x_n-x_i)=a_n\pi_n(x_n)
\]</span></p>
<p>故有,</p>
<p><span class="math display">\[
a_n=\frac{y_n-N_{n-1}(x_n)}{\pi_n(x_n)}
\]</span></p>
<p><strong>系数<span
class="math inline">\(a_n\)</span>被称为牛顿差商.</strong> 记为,</p>
<p><span class="math display">\[
a_n=f[x_0,x_1,\cdots,x_n],n\geq1
\]</span></p>
<h3 id="牛顿差商是什么"><a href="#牛顿差商是什么" class="headerlink" title="牛顿差商是什么"></a>牛顿差商是什么</h3>
<p>Newton差商实际上是多项式的一个系数。
有了牛顿差商,我们可以把牛顿插值多项式改写一下,</p>
<p><span class="math display">\[
N_n(x)=N_{n-1}(x)+a_n\pi_n(x)=\sum_{i=0}^{n}a_i\pi_i(x)
\]</span></p>
<p>其中,我们规定<span
class="math inline">\(f[x_0]=y_0,\pi_0(x)=1\)</span>.</p>
<p>由插值多项式的唯一性,可知,Newton插值多项式跟Lagrange插值多项式是等价的.</p>
<h3 id="差商的性质"><a href="#差商的性质" class="headerlink" title="差商的性质"></a>差商的性质</h3>
<p>公式</p>
<p><span class="math display">\[
a_n=\frac{y_n-N_{n-1}(x_n)}{\pi_n(x_n)}
\]</span></p>
<p>虽然给出了一种计算差商的办法,但是要用到<span
class="math inline">\(N_{n-1}(x_n)\)</span>,这并不便于计算.
通过对牛顿差商性质的了解,我们可以给出<strong>更加实用的</strong>Newton插值多项式的构造方法.
#### Newton差商性质 - 差商与节点的排序无关 首项系数与
Lagrange插值多项式的首项系数一致
L插值多项式的首系数也是N插值多项式的首系数,也就是n阶Newton差商.</p>
<p><span class="math display">\[
f[x_0,x_1,\cdots,x_n]=\sum_{i=0}^{n}\frac{y_i}{\pi_{n+1}&#39;(x_i)}
\]</span></p>
<ul>
<li><strong>差商具有线性性质</strong>，若<span
class="math inline">\(f=\alpha g+\beta h\)</span>,那么</li>
</ul>
<p><span class="math display">\[
f[x_0,x_1,\cdots,x_n]=\alpha g[x_0,x_1,\cdots,x_n]+\beta
h[x_0,x_1,\cdots,x_n]
\]</span></p>
<ul>
<li><strong>递推公式</strong></li>
</ul>
<p><span class="math display">\[
f[x_i,x_{i+1},\cdots,x_n]=\frac{f[x_{i+1},\cdots,x_n]-f[x_i,\cdots,x_{n-1}]}{x_n-x_i},n\geq
1
\]</span></p>
<ul>
<li><strong>差商与高阶导数的联系</strong> 设<span
class="math inline">\(f\in C^n[a,b],x_i,i=0,1,\cdots,n\)</span>是<span
class="math inline">\([a,b]\)</span>中互异节点,则存在<span
class="math inline">\(\xi\in[a,b]\)</span>使得,</li>
</ul>
<p><span class="math display">\[
f[x_0,x_1,\cdots,x_n]=\frac{f^{(n)}(\xi)}{n!}
\]</span></p>
<p>值得注意的是,如果所有节点<span
class="math inline">\(x_0,x_1,\cdots,x_n\)</span>都重合(认为是一种极限过程),这牛顿差商退化成,</p>
<p><span class="math display">\[
f[x,x,\cdots,x]=\frac{f^{(n)}(x)}{n!}
\]</span></p>
<p>进而,Newton插值多项式退化成Taylor多项式. -
<strong>Leibniz公式</strong>,若<span
class="math inline">\(f=gh\)</span>，那么</p>
<p><span class="math display">\[
f[x_0,x_1,\cdots,x_n]=\sum_{j=0}^{n}g[x_0,x_1,\cdots,x_j]\cdot
h[x_j,x_1,\cdots,x_n]
\]</span></p>
<h2 id="newton插值算法"><a href="#Newton插值算法" class="headerlink" title="Newton插值算法"></a>Newton插值算法</h2>
<p><strong>差商表</strong> 1. 构建差商表 2. 取对角线</p>
<p><strong>Horner</strong>方法 将Newton插值多项式写成嵌套形式</p>
<h2 id="n插值多项式的误差"><a href="#N插值多项式的误差" class="headerlink" title="N插值多项式的误差"></a>N插值多项式的误差</h2>
<p><span class="math display">\[
R_n(x)=f[x_0,x_1,\cdots,x_n,\textbf{x}]\pi_{n+1}(x)
\]</span></p>
<p><strong>证明:</strong> 关于<span
class="math inline">\(x_0,x_1,\cdots,x_n\)</span>以及<span
class="math inline">\(x\)</span>构造<span
class="math inline">\(N_{n+1}(x)\)</span>,</p>
<p><span class="math display">\[
N_{n+1}(t)=N_{n}(t)+f[x_0,x_1,\cdots,x_n,x]\pi_{n+1}(t)
\]</span></p>
<p>这里我们应该要注意到插值多项式<span
class="math inline">\(N_{n+1}(t)\)</span>在<span
class="math inline">\(t=x\)</span>处的插值条件就是</p>
<p><span class="math display">\[
N_{n+1}(x)=f(x)
\]</span></p>
<p>因此将式子中的t用x替换,即得,</p>
<p><span class="math display">\[
N_{n+1}(x)-N_{n}(x)=f[x_0,x_1,\cdots,x_n,x]\pi_{n+1}(x)
\]</span></p>
<p><span class="math display">\[
f(x)-N_{n}(x)=f[x_0,x_1,\cdots,x_n,x]\pi_{n+1}(x)
\]</span></p>
<p>于是,就证明了<span
class="math inline">\(R_n(x)=f[x_0,x_1,\cdots,x_n,\textbf{x}]\pi_{n+1}(x)\)</span>.
# 差分与等距节点
当插值节点等距的时候,可以对Newton插值多项式进一步化简.为此,我们需要引入差分的概念.</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3>
<p><strong>定义</strong>:设在等距节点<span
class="math inline">\(x_i=x_o+ih,i=0,1,2,\cdots,n\)</span>上,已知函数<span
class="math inline">\(f(x)\)</span>的值为<span
class="math inline">\(y_0,y_1,\cdots,y_n\)</span>,其中<span
class="math inline">\(y&gt;0\)</span>为相邻两个节点的步长.称,</p>
<p><span class="math display">\[
\Delta^1f_i=f_{i+1}-f_i,i=0,1,2,\cdots,n
\]</span></p>
<ul>
<li>零阶差分 定义为:<span
class="math inline">\(\Delta^0f_i=f_i,i=0,1,2,\cdots,n\)</span></li>
<li>m阶向前差分</li>
</ul>
<p><span class="math display">\[
\Delta^mf_i=\Delta^{m-1}f_{i+1}-\Delta^{m-1}f_i=\Delta^{m-1}(f_{i+1}-f_i)=\Delta^{m-1}\Delta^{1}f_i,i=0,1,2,\cdots,n
\]</span></p>
<h3 id="差分性质"><a href="#差分性质" class="headerlink" title="差分性质"></a>差分性质</h3>
<ul>
<li>差分与牛顿差商的关系</li>
</ul>
<p><span class="math display">\[
f[x_0,x_1,\cdots,x_m]=\frac{\Delta^mf_0}{m!h^{m}}
\]</span></p>
<p><span class="math display">\[
f[x_i,x_{i+1},\cdots,x_{i+m}]=\frac{\Delta^mf_i}{m!h^{m}}
\]</span></p>
<ul>
<li>高阶差分与函数值的关系</li>
</ul>
<p><span class="math display">\[
\Delta^mf_i=\sum_{j=0}^{m}(-1)^{j}C_{j}^{m}f_{i+m-j}
\]</span></p>
<h2 id="newton向前差分公式"><a href="#Newton向前差分公式" class="headerlink" title="Newton向前差分公式"></a>Newton向前差分公式</h2>
<p><span class="math display">\[
N_n(x)=\sum_{i=0}^{n}f[x_0,x_1,\cdots,x_i]\pi_i(x)=\sum_{i=0}^{n}\frac{\Delta^if_0}{i!h^{i}}\pi_i(x)
\]</span></p>
<p>再做线性替换<span class="math inline">\(x=x_0+th,\quad 0\leq t\leq
n\)</span>,则<span
class="math inline">\(x-x_i=(t-i)h,i=0,1,2,\cdots,n\)</span>,上面的公式可以简化为,</p>
<p><span class="math display">\[
N_n(x_0+th)=\sum_{i=0}^{n}\frac{\Delta^if_0}{i!h^{i}}\pi_i(x_0+th)=\sum_{i=0}^{n}\frac{\Delta^if_0}{i!h^{i}}\prod_{j=0}^{i-1}(h(t-j))=\sum_{i=0}^{n}\frac{\Delta^if_0}{i!}\prod_{j=0}^{i-1}(t-j)
\]</span></p>
<p>类似的,可以把插值余项公式简化成,</p>
<p><span class="math display">\[
R_n(x)=\frac{h^{n+1}f^{(n+1)}(\xi_x)}{(n+1)!}\prod_{j=0}^{n}(t-j)
\]</span></p>
<p>注:类似向前差分,我们可以定义向后差分,</p>
<p><span class="math display">\[
\nabla^1f_i=f_{i}-f_{i-1}
\]</span></p>
<p>有差不多的结论,区别在于,向前差分公式适合在右侧增加节点,向后差分公式则是向左.</p>
<h1 id="hermit插值"><a href="#Hermit插值" class="headerlink" title="Hermit插值"></a>Hermit插值</h1>
<h2 id="满足插值条件和导数条件的插值"><a href="#满足插值条件和导数条件的插值" class="headerlink" title="满足插值条件和导数条件的插值"></a>满足插值条件和导数条件的插值</h2>
<p>Hermit插值与前面插值方法最大的区别就是,在插值节点处除了满足插值条件外,还需要满足导数插值条件.
## 几何意义
这种方式构造的插值函数,除了过插值节点外,还保持了在节点处的光滑性 ##
构造H多项式 2.7.3.1 一种构造 2.7.3.2 Newton 插值余项
一般情况下，同次数的尔米特多项式比拉格朗日多项式更精确 #
Runge现象和分段插值
<strong>容格现象启示：不要轻易使用高次插值多项式.</strong> ## 分段插值
<strong>主要思想</strong>是将插值区间划分成一个个小区间,在每个小区间上用低次的插值多项式逼近函数.
最简单的一种方法就是<strong>分段线性插值</strong>.</p>
<h2 id="分段线性插值"><a href="#分段线性插值" class="headerlink" title="分段线性插值"></a>分段线性插值</h2>
<p>分段插值的<strong>几何意义</strong>就是:在每个小区间内用直线段连起来.
<strong>定义:(分段插值函数)</strong></p>
<h3 id="函数空间维数"><a href="#函数空间维数" class="headerlink" title="函数空间维数"></a>函数空间维数</h3>
<p>2.8.2.1.1 自由度条件 2.8.2.1.2 连续性条件 ###
分段线性插值多项式具有一致收性</p>
<h2 id="分段线性和分段三次hermit插值"><a href="#分段线性和分段三次hermit插值" class="headerlink" title="分段线性和分段三次hermit插值"></a>分段线性和分段三次hermit插值</h2>
<h1 id="样条插值"><a href="#样条插值" class="headerlink" title="样条插值"></a>样条插值</h1>
<p>弹性势能最小的插值方式，稳定性很好
分段线性插值多项式的光滑性差,只有连续性.
而分段3次Hermit插值具有一阶可导性,但是要知道节点处的导数值才行.</p>
<h2 id="次样条插值多项式"><a href="#3次样条插值多项式" class="headerlink" title="3次样条插值多项式"></a>3次样条插值多项式</h2>
<p><strong>定义:</strong> 设<span
class="math inline">\(f(x)\)</span>为定义在区间<span
class="math inline">\([a,b]\)</span>内的函数,已知<span
class="math inline">\(f(x)\)</span>在区间<span
class="math inline">\([a,b]\)</span>内的<span
class="math inline">\(n+1\)</span>个互异的点<span
class="math inline">\(a\leq x_0&lt;x_1&lt;\cdots&lt;x_n\leq
b\)</span>处的函数值为<span
class="math inline">\(y(x_i)=y_i,i=0,\cdots,n\)</span>.设<span
class="math inline">\(s_3(x)\)</span>是定义在区间<span
class="math inline">\([a,b]\)</span>上的函数,若<span
class="math inline">\(s(x)\)</span>满足以下条件, -
<strong>(局部性质)</strong><span
class="math inline">\(s(x)\)</span>在每个小区间<span
class="math inline">\([x_i,x_{i+1}],i=0,\cdots,n-1\)</span>内是次数不超过3次的多项式
- <strong>(插值条件)</strong><span
class="math inline">\(s(x)\)</span>满足插值条件<span
class="math inline">\(s(x_i)=y_i,i=0,\cdots,n\)</span> -
<strong>(整体性质)</strong><span
class="math inline">\(s(x)\)</span>是插值区间上的二阶连续可导函数</p>
<p>则称<span
class="math inline">\(s(x)\)</span>是插值区间内的3次样条插值函数,简称3次样条.</p>
<p><strong>定义如下函数空间</strong></p>
<p><span class="math display">\[
S^{2,3}=\{s\in C[a,b]|s_{I_i}\in
P_3(I_i),I_i=[x_i,x_{i+1}],i=0,\cdots,n-1]\}
\]</span></p>
<p>该空间的维度为<span
class="math inline">\(4n-(3n-3)=n+3\)</span>,即3次样条自由度为<span
class="math inline">\(n+3\)</span>,插值条件提供了<span
class="math inline">\(n+1\)</span>个自由度,于是发现,我们还需要额外的两个自由度.</p>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2>
<p>由于求解仍缺少两个自由度,而缺少的只能由插值区间<span
class="math inline">\([a,b]\)</span>的两个端点给出,我们称由端点给出的条件为<strong>边界条件</strong>.</p>
<p>边界条件通常有三类: - <strong>自然边界条件</strong></p>
<p><span class="math display">\[
s&#39;&#39;(x_0)=s&#39;&#39;(x_n)=0
\]</span></p>
<p>这样构造的样条称为自然样条. - <strong>固支边界条件</strong></p>
<p><span class="math display">\[
s&#39;&#39;(x_0)=y&#39;_0\quad s&#39;&#39;(x_n)=y&#39;_n
\]</span></p>
<p>固支边界条件包含了更多信息,通常比自然条件更精确,
这样构造的样条称为固支样条. - <strong>循环边界条件</strong></p>
<p><span class="math display">\[
s(x_0)=s(x_n)
\]</span></p>
<p><span class="math display">\[
s&#39;(x_0)=s&#39;(x_n)
\]</span></p>
<p><span class="math display">\[
s&#39;&#39;(x_0)=s&#39;&#39;(x_n)
\]</span></p>
<p>这样构造的样条称为周期样条.</p>
<h2 id="三次样条的构造"><a href="#三次样条的构造" class="headerlink" title="三次样条的构造"></a>三次样条的构造</h2>
<h3 id="三弯矩构造法解线性方程组"><a href="#三弯矩构造法(解线性方程组)" class="headerlink" title="三弯矩构造法(解线性方程组)"></a>三弯矩构造法(解线性方程组)</h3>
<p>三弯矩构造法利用3次样条在内部节点上的二阶连续可导性化简计算,将问题化简为求解线性方程组.</p>
<p><strong>构造过程:</strong> 记3次样条在节点处的二阶导数值为<span
class="math inline">\(M_i=s&#39;&#39;(x_i),i=0,\cdots,n\)</span>.由于<span
class="math inline">\(s&#39;&#39;(x)\)</span>在每个小区间上都是一次多项式,故有,</p>
<p><span class="math display">\[
s&#39;&#39;_i(x)=\frac{x_{i+1}-x}{h_i}M_i+\frac{x-x_{i}}{h_i}M_{i+1}
\]</span></p>
<p>其中<span
class="math inline">\(h_i=x_{i+1}-x_i\)</span>,将上面的式子积分两次,有</p>
<p>留空（）</p>
<p>总之利用完插值条件和一阶连续可导的条件后,得到,</p>
<p><span class="math display">\[
\mu_{i+1}M_i+2M_{i+1}+\lambda_{i+1}M_{i+2}=d_{i+1}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\begin{cases}
\mu_{i+1}=\frac{h_i}{h_i+h_{i+1}}\\
\\
\lambda_{i+1}=\frac{h_{i+1}}{h_i+h_{i+1}}\\
\\
d_{i+1}=6f[x_i,x_{i+1},x_{i+2}]
\end{cases}
\]</span></p>
<p>接下来考虑边界条件 <strong>(1)</strong> 自然边界 即已知<span
class="math inline">\(M_0=M_n=0\)</span>,所以得到的线性方程组为,</p>
<p><strong>(2)</strong> <strong>(3)</strong></p>
<h3 id="b样条构造法基函数"><a href="#B样条构造法(基函数)" class="headerlink" title="B样条构造法(基函数)"></a>B样条构造法(基函数)</h3>
<h1 id="多元插值方法"><a href="#多元插值方法" class="headerlink" title="多元插值方法"></a>多元插值方法</h1>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2022/10/11/Project%202/">← Next Project 2</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/10/10/%E7%BB%AA%E8%AE%BA/">绪论 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">BriChen</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E5%AE%B9%E6%A0%BC%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">例子：容格函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%85%E5%BD%A2"><span class="toc-number">1.2.</span> <span class="toc-text">情形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%99%E9%A1%B9%E5%85%AC%E5%BC%8F%E5%AE%9A%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">余项公式定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lagrange%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">Lagrange插值方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#l%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">L插值算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#neville%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%E7%95%A5%E8%BF%87%E4%BA%86"><span class="toc-number">3.</span> <span class="toc-text">Neville插值方法(略过了?)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#newton%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">Newton插值方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%87%BA"><span class="toc-number">4.1.</span> <span class="toc-text">引出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%9B%E9%A1%BF%E5%B7%AE%E5%95%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.2.1.</span> <span class="toc-text">牛顿差商是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%95%86%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">差商的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newton%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">Newton插值算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#n%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%AF%AF%E5%B7%AE"><span class="toc-number">4.4.</span> <span class="toc-text">N插值多项式的误差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.5.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-number">4.5.1.</span> <span class="toc-text">差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E6%80%A7%E8%B4%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">差分性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newton%E5%90%91%E5%89%8D%E5%B7%AE%E5%88%86%E5%85%AC%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">Newton向前差分公式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hermit%E6%8F%92%E5%80%BC"><span class="toc-number">5.</span> <span class="toc-text">Hermit插值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%A1%E8%B6%B3%E6%8F%92%E5%80%BC%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%AF%BC%E6%95%B0%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%8F%92%E5%80%BC"><span class="toc-number">5.1.</span> <span class="toc-text">满足插值条件和导数条件的插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC"><span class="toc-number">5.2.</span> <span class="toc-text">分段线性插值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%A9%BA%E9%97%B4%E7%BB%B4%E6%95%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">函数空间维数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%BA%BF%E6%80%A7%E5%92%8C%E5%88%86%E6%AE%B5%E4%B8%89%E6%AC%A1hermit%E6%8F%92%E5%80%BC"><span class="toc-number">5.3.</span> <span class="toc-text">分段线性和分段三次hermit插值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">样条插值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">3次样条插值多项式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">边界条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">6.3.</span> <span class="toc-text">三次样条的构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%BC%AF%E7%9F%A9%E6%9E%84%E9%80%A0%E6%B3%95%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">6.3.1.</span> <span class="toc-text">三弯矩构造法(解线性方程组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E6%A0%B7%E6%9D%A1%E6%9E%84%E9%80%A0%E6%B3%95%E5%9F%BA%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">B样条构造法(基函数)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">多元插值方法</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>
<!DOCTYPE html><html lang="cn" theme-mode="light"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>报告 | BriChen's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/brands.min.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Brands';
 src: local('Font Awesome 6 Brands'), url('/lib/fontawesome/fa-brands.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Free';
 src: local('Font Awesome 6 Free'), url('/lib/fontawesome/fa-regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/contact/"><span class="navItemTitle">Contact</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>报告</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-02-18T01:09:44.000Z" id="date"> 2023-02-18</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-05-15T08:50:39.691Z" id="updated"> 2023-05-15</time></div></span></div></div><hr><div id="post-content"><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1>
<h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2>
<figure>
<img src="/images/92121416f71acd201a329cdec03cb1d3.png"
alt="92121416f71acd201a329cdec03cb1d3.png" />
<figcaption
aria-hidden="true">92121416f71acd201a329cdec03cb1d3.png</figcaption>
</figure>
<h2 id="意义和目的"><a href="#意义和目的" class="headerlink" title="意义和目的"></a>意义和目的</h2>
<p>计算希尔伯特矩阵的无穷范数的条件数，从而知道希尔伯特矩阵是“病态的”。</p>
<h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2>
<p>条件数是线性方程组Ax=b的解对b中的误差或不确定度的敏感性的度量。数学定义为矩阵A的条件数等于A的范数与A的逆的范数的乘积，即cond(A)=‖A‖·‖A的逆‖，对应矩阵的3种范数，相应地可以定义3种条件数。</p>
<p>条件数事实上表示了矩阵计算对于误差的敏感性。对于线性方程组Ax=b，如果A的条件数大，b的微小改变就能引起解x较大的改变，数值稳定性差。如果A的条件数小，b有微小的改变，x的改变也很微小，数值稳定性好。它也可以表示b不变，而A有微小改变时，x的变化情况。
## 程序设计流程 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 试估计 5 至 20 阶Hilbert 矩阵的无穷范数条件数</span><br><span class="line">import numpy as np</span><br><span class="line">np.set_printoptions(suppress=True)</span><br><span class="line"># 希尔伯特矩阵</span><br><span class="line">def H(n):</span><br><span class="line">    H = np.zeros((n, n))</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            H[i,j] = 1/(i+j+1)</span><br><span class="line">    return H</span><br><span class="line"></span><br><span class="line">#无穷范数</span><br><span class="line">def norm(H):</span><br><span class="line">    nm = 0</span><br><span class="line">    l = len(H)</span><br><span class="line">    for i in range(l):</span><br><span class="line">        sum = 0</span><br><span class="line">        for j in range(l):</span><br><span class="line">            sum = sum + abs(H[i,j])</span><br><span class="line">        if nm &lt;= sum:</span><br><span class="line">            nm = sum</span><br><span class="line">    return nm</span><br><span class="line"></span><br><span class="line">N = [5,10,15,20]</span><br><span class="line">for n in N:</span><br><span class="line">    H1 = H(n)</span><br><span class="line">    HI = np.linalg.inv(H1)</span><br><span class="line">    cond = norm(H1)*norm(HI)</span><br><span class="line">    print(n,&#x27;阶Hilbert 矩阵的条件数为：&#x27;,cond)</span><br><span class="line">    #print(np.linalg.cond(H1,p=np.inf)) 这条用来验证</span><br></pre></td></tr></table></figure></p>
<h2 id="实验结果和讨论"><a href="#实验结果和讨论" class="headerlink" title="实验结果和讨论"></a>实验结果和讨论</h2>
<p>高阶希尔伯特矩阵的条件数非常大。</p>
<figure>
<img src="/images/d5f06d0a4bd8e4e95ffb8f566167156a.png"
alt="d5f06d0a4bd8e4e95ffb8f566167156a.png" />
<figcaption
aria-hidden="true">d5f06d0a4bd8e4e95ffb8f566167156a.png</figcaption>
</figure>
<h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1>
<h2 id="题目摘要-1"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2>
<figure>
<img src="/images/04016e99a3ea21ebad22b76737d5383a.png"
alt="04016e99a3ea21ebad22b76737d5383a.png" />
<figcaption
aria-hidden="true">04016e99a3ea21ebad22b76737d5383a.png</figcaption>
</figure>
<h2 id="意义和目的-1"><a href="#意义和目的" class="headerlink" title="意义和目的"></a>意义和目的</h2>
<p>追赶法适用于三对角矩阵，可以有效减少计算量。 ## 数学原理
追赶法的基本原理是矩阵的LU分解，即将矩阵A 分解为 <span
class="math display">\[
A=LU
\]</span> 其中，L为一个对角线上元素为1的下三角矩阵，U为一个上三角矩阵.
容易验证，一个三对角矩阵作LU分解以后，得到一个下二对角矩阵与一个上二对角矩阵的乘积。
## 程序设计流程 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 用追赶法解三对角方程组</span><br><span class="line">import numpy as np</span><br><span class="line">A = np.array([[2, -1, 0, 0, 0],</span><br><span class="line">              [-1, 2, -1, 0, 0],</span><br><span class="line">              [0, -1, 2, -1, 0],</span><br><span class="line">              [0, 0, -1, 2, -1],</span><br><span class="line">              [0, 0, 0, -1, 2]])</span><br><span class="line"></span><br><span class="line">b = np.array([1, 0, 0, 0, 0])</span><br><span class="line"># 左乘A逆</span><br><span class="line">print(&#x27;传统方法：&#x27;, np.linalg.inv(A).dot(b))</span><br><span class="line"></span><br><span class="line"># 追赶法</span><br><span class="line">X0 = np.diag(A)</span><br><span class="line">X1 = np.diag(A,1)</span><br><span class="line">X1 = np.insert(X1,0,0)</span><br><span class="line">X2 = np.diag(A,-1)</span><br><span class="line">X2 = np.insert(X2,0,0)</span><br><span class="line">#print(X0,X1,X2) #测试用</span><br><span class="line">n = len(A)</span><br><span class="line">alpha = np.zeros(n)</span><br><span class="line">beta = np.zeros(n-1)</span><br><span class="line">beta[0] = X1[1]/X0[0]</span><br><span class="line">X = np.zeros(n)</span><br><span class="line">Y = np.zeros(n)</span><br><span class="line"></span><br><span class="line">for i in range(1,n-1): #LU分解相关计算</span><br><span class="line">    beta[i] = X1[i]/(X0[i]-X2[i]*beta[i-1])</span><br><span class="line">for i in range(0,n): #追</span><br><span class="line">    if i == 0:</span><br><span class="line">        Y[i] = b[i]/X0[i]</span><br><span class="line">        continue</span><br><span class="line">    Y[i] = (b[i]-X2[i]*Y[i-1])/(X0[i]-X2[i]*beta[i-1])</span><br><span class="line">for i in range(n-1,-1,-1): #赶</span><br><span class="line">    if i == n-1:</span><br><span class="line">        X[i] = Y[i]</span><br><span class="line">        continue</span><br><span class="line">    X[i] = Y[i] - beta[i]*X[i+1]</span><br><span class="line"></span><br><span class="line">print(&#x27;追赶法：&#x27;, X)</span><br></pre></td></tr></table></figure></p>
<h2 id="实验结果和讨论-1"><a href="#实验结果和讨论" class="headerlink" title="实验结果和讨论"></a>实验结果和讨论</h2>
<p>如果在代码中加入计录运行时间的代码，应该可以发现两种运算方式在速度上的区别，但是由于计算阶数较小，差别不会很明显。</p>
<figure>
<img src="/images/218069d12964700cadf7e4db4f0f3ba0.png"
alt="218069d12964700cadf7e4db4f0f3ba0.png" />
<figcaption
aria-hidden="true">218069d12964700cadf7e4db4f0f3ba0.png</figcaption>
</figure>
<h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1>
<h2 id="题目摘要-2"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2>
<p><img src="/images/ef765724e3c45421cb52fb9f7b5d7edc.png"
alt="ef765724e3c45421cb52fb9f7b5d7edc.png" /> <img
src="/images/b1a6a6147e24181ceda7d3911c4ea838.png"
alt="b1a6a6147e24181ceda7d3911c4ea838.png" /></p>
<h2 id="意义和目的-2"><a href="#意义和目的" class="headerlink" title="意义和目的"></a>意义和目的</h2>
<p>利用 Gauss 列主元消去法、显式相对 Gauss 列主元消去法求解线性方程组。
## 数学原理
如果系数矩阵的元素按绝对值在数量级方面相差很大，那么，在进行列主元消元过程前，先把系数矩阵的元素进行行平衡：系数矩阵的每行元素和相应的右端向量元素同除以该行元素绝对值最大的元素。这就是所谓的平衡技术。然后再进行列主元消元过程。</p>
<p>如果真正进行运算去确定相对主元，则称为显式相对
Gauss列主元消去法；如果不进行运算，也能确定相对主元，则称为隐式相对
Gauss 列主元消去法。</p>
<p>显式相对 Gauss 列主元消去法：对给定的n阶线性方程组 <span
class="math inline">\(Ax=b\)</span>首先进行列主元消元过程，在消元过程中利用显式平衡技术，然后进行回代过程，最后得到解或确定该线性方程组是奇异的。</p>
<h2 id="程序设计流程"><a href="#程序设计流程" class="headerlink" title="程序设计流程"></a>程序设计流程</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"># Gauss 列主元消元法</span><br><span class="line">import numpy as np</span><br><span class="line">import copy</span><br><span class="line">np.set_printoptions(precision=8)</span><br><span class="line">np.set_printoptions(suppress=False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def swap(a, b, k, j): # 用来交换矩阵的行向量</span><br><span class="line">    tmp = copy.deepcopy(a[:,k])</span><br><span class="line">    a[:,k] = a[:,j]</span><br><span class="line">    a[:,j] = tmp</span><br><span class="line">    tmp = copy.deepcopy(b[k])</span><br><span class="line">    b[k] = b[j]</span><br><span class="line">    b[j] = tmp</span><br><span class="line">    return a,b</span><br><span class="line"></span><br><span class="line">def select(A,k):</span><br><span class="line">    X = list(A[k])</span><br><span class="line">    j = X.index(max(A[k]))</span><br><span class="line">    return k, j</span><br><span class="line"></span><br><span class="line">#Gauss 列主元</span><br><span class="line">def gauss(a, b):</span><br><span class="line">    n = len(b)</span><br><span class="line">    for k in range(n):              #k表示迭代次数</span><br><span class="line">        if a[k,k] == 0:             #防止出现0做分母</span><br><span class="line">            k, j = select(a,k)                    </span><br><span class="line">            swap(a, b, k, j)           </span><br><span class="line">        # k, j = select(a,k)          #选列主元          </span><br><span class="line">        # swap(a, b, k, j)           #交换列主元</span><br><span class="line">        for i in range(k+1, n):   </span><br><span class="line">            l = a[i,k] / a[k,k]              </span><br><span class="line">            a[i,:] = a[i,:] - l * a[k,:] </span><br><span class="line">            b[i] = b[i] - l *b[k] </span><br><span class="line">        #     print(a,b)</span><br><span class="line">        # print(&#x27;------------&#x27;) </span><br><span class="line"></span><br><span class="line">    # 回代求解</span><br><span class="line">    x = np.zeros(n)</span><br><span class="line">    x[n-1] = b[n-1] / a[n-1, n-1] #先算最后一位的x解</span><br><span class="line">    for i in range(n-2, -1, -1):      #依次回代倒着算每一个解</span><br><span class="line">        for j in range(i+1, n):</span><br><span class="line">            b[i] -= a[i,j] * x[j]</span><br><span class="line">        x[i] = b[i] / a[i,i]</span><br><span class="line">    # for i in range(n):              # 输出每个分量</span><br><span class="line">    #     print(&quot;x&quot; + str(i + 1) + &quot; = &quot;, x[i]) </span><br><span class="line">    print(&quot;Gauss法:x&quot; &quot; = &quot;, x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># A = np.array([[0.4096, 0.1234, 0.3678, 0.2943], </span><br><span class="line">#             [0.2246, 0.3872, 0.4015, 0.1129], </span><br><span class="line">#             [0.3645, 0.1920, 0.3781, 0.0643],</span><br><span class="line">#             [0.1784, 0.4002, 0.2786, 0.3927]])</span><br><span class="line"># b = np.array([1.2951, 1.1262, 0.9989, 1.2499])</span><br><span class="line"></span><br><span class="line">A = np.array([[10, 7, 8, 7], </span><br><span class="line">            [7, 5, 6, 5], </span><br><span class="line">            [8, 6, 10, 9],</span><br><span class="line">            [7, 5, 9, 10]],dtype=float)</span><br><span class="line">b = np.array([32, 23, 33, 31],dtype=float)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># print(np.linalg.cond(A, p=np.inf))</span><br><span class="line">print(&#x27;传统方法：&#x27;, np.linalg.inv(A).dot(b))</span><br><span class="line">gauss(A, b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实验结果和讨论-2"><a href="#实验结果和讨论" class="headerlink" title="实验结果和讨论"></a>实验结果和讨论</h2>
<figure>
<img src="/images/14d2b5b8d15769e84e333af5a439dd85.png"
alt="14d2b5b8d15769e84e333af5a439dd85.png" />
<figcaption
aria-hidden="true">14d2b5b8d15769e84e333af5a439dd85.png</figcaption>
</figure>
<p>由于顺序消去法会因为的值过小而引入计算误差，为了减少计算过程中舍入误差对方程组求解的影响，因此是否可以选择绝对值尽可能大的主元作为除数。</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/23/Hilber%20%E7%A9%BA%E9%97%B4/">← Next Hilbert 空间</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2022/11/16/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/">解线性方程组的迭代法 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">BriChen</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">实验一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%91%98%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">题目摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E4%B9%89%E5%92%8C%E7%9B%AE%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">意义和目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">数学原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%92%8C%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.4.</span> <span class="toc-text">实验结果和讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C"><span class="toc-number">2.</span> <span class="toc-text">实验二</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%91%98%E8%A6%81-1"><span class="toc-number">2.1.</span> <span class="toc-text">题目摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E4%B9%89%E5%92%8C%E7%9B%AE%E7%9A%84-1"><span class="toc-number">2.2.</span> <span class="toc-text">意义和目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%92%8C%E8%AE%A8%E8%AE%BA-1"><span class="toc-number">2.3.</span> <span class="toc-text">实验结果和讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89"><span class="toc-number">3.</span> <span class="toc-text">实验三</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%91%98%E8%A6%81-2"><span class="toc-number">3.1.</span> <span class="toc-text">题目摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E4%B9%89%E5%92%8C%E7%9B%AE%E7%9A%84-2"><span class="toc-number">3.2.</span> <span class="toc-text">意义和目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">程序设计流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%92%8C%E8%AE%A8%E8%AE%BA-2"><span class="toc-number">3.4.</span> <span class="toc-text">实验结果和讨论</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>
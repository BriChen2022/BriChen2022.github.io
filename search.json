[{"title":"23.5.15 线性规划问题的几个定理","url":"/2023/05/15/23.5.15%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AE%9A%E7%90%86/","content":"基本概念\r\n凸集\r\n（通俗版本）集合中任意两点的连线仍在集合中。\r\n（严格定义）设n维度欧式空间中点集\\(\\mathbb{K}\\)，\\(X_1,X_2\\)为集合中任意两点，若对任意实数\\(\\alpha\\in [0,1]\\)，满足： \\[\r\n\\alpha X_1+(1-\\alpha)X_2\\in\\mathbb{K}\r\n\\] 则称该集合\\(\\mathbb{K}\\)为凸集。\r\n凸组合 设n维度欧式空间中点集\\(\\mathbb{K}\\)，\\(X_1,\\cdots,X_k\\)为集合中任意\\(k\\)个点，若存在\\(k\\)个实数\\(0\\leq\\alpha_i\\leq 1,i=1,\\cdots,k\\)并且\\(\\sum_{i=1}^{k}\\alpha_i =1\\)，满足： \\[\r\nX=\\sum_{i=1}^{k}\\alpha_i X_i\r\n\\] 则称\\(X\\)为\\(X_1,\\cdots,X_k\\)的凸组合。\\(0 &lt;\\alpha_i&lt;\r\n1,i=1\\)，称为严格凸组合。\r\n顶点 设\\(\\mathbb{K}\\)凸集，\\(X\\in\\mathbb{K}\\),如果\\(X\\)不能用\\(\\mathbb{K}\\)中不同两点的严格凸组合表示，则称\\(X\\)为\\(\\mathbb{K}\\)的一个顶点。\r\n也即，对\\(0 &lt;\\alpha&lt; 1\\)有，\r\n\\[\r\nX\\neq \\alpha X_1+(1-\\alpha)X_2,\\forall X_1,X_2\\in\\mathbb{K},X_1\\neq X_2\r\n\\] # 几个定理\r\n定理1（线性规划问题的可行域为凸集）\r\n若线性规划问题存在可行域， \\[\r\nD=\\{\\textbf{X}\\vert \\sum_{i=1}^{n}\\textbf{P}_ix_i=\\textbf{b},x_i\\geq 0\\}\r\n\\] 是凸集。（小写的x代表\\(X\\)的分量）\r\nproof 设\\(X_1,X_2\\)为\\(D\\)中任意两个相异的点，\\(A\\)是以\\(P_i\\)为行向量的矩阵。 则有， \\[\r\nAX_1=b,AX_2=b\r\n\\] 于是，两点连线上任意一点\\(X\\)满足， \\[\r\n\\begin{align*}\r\nAX=&amp; A(\\alpha X_1+(1-\\alpha)X_2)\\\\\r\n=&amp;\\alpha AX_1+AX_2-\\alpha AX_2\\in\\mathbb{K}\\\\\r\n=&amp; \\alpha b+b-\\alpha b\\\\\r\n=&amp; b\r\n\\end{align*}\r\n\\] 故\\(X\\in D\\)，\\(D\\)凸集。\r\n定理2 若\\(\\mathbb{K}\\)为有界凸集，则集合内任意一点可以表示为\\(\\mathbb{K}\\)的顶点的凸组合。\r\nproof 对于二维的情况比较形象。\r\n已知三角形为有界凸集。任何有界凸集可以用凸多边形逼近，而任意凸多边形可以划分成可数个三角形。承认上诉逻辑，我们只需要证明：三角形的任意一点可以用顶点的凸组合表出。\r\n设\\(X_1,X_2,X_3\\)为三角形的三个顶点。\\(X\\)为三角形内任意一点。若\\(X\\)在三条边上（即落在任意两个顶点的连线上），由凸集定义显然有顶点的凸组合表示。\r\n若不在三条边上，做过\\(X\\)与\\(X_1\\)的射线交另外两点的连线于\\(X&#39;\\)，于是有， \\[\r\nX&#39;=\\alpha X_2+(1-\\alpha)X_3\r\n\\] \\[\r\nX=\\lambda X&#39;+(1-\\lambda)X_1\r\n\\] \\[\r\n\\lambda,\\alpha\\in(0,1)\r\n\\] 代入即得， \\[\r\nX=(1-\\lambda)X_1+\\lambda\\alpha X_2+\\lambda(1-\\alpha)X_3\r\n\\] 将三个系数相加不难发现和为\\(1\\)。 至此，我们得到了\\(X\\)用顶点的凸组合的表示。\r\n但是对于二维以上的情形，就没有这么直观了，我们需要将三角形换成所谓的“单纯形”。\r\n\r\n单纯形是二维的三角形，三维的四面体，在任意维度的推广。n-维单纯形是一个有\r\nn+1 个顶点，n+1 个面 (facet) 的多面体。这个词译自英语\r\nsimplex，「单纯」其实意味着基本，因为他是组成更复杂结构（复形\r\ncomplex）的基本构件。\r\n\r\n","categories":["Math","运筹"],"tags":["深夜食堂","运筹"]},{"title":"23.5.16 Banach-Steinhaus 定理","url":"/2023/05/16/23.5.16%20Banach-Steinhaus%20%E5%AE%9A%E7%90%86/","content":"定理 设 \\(E\\)\r\n为Banach空间， \\(F\\) 为赋范空间，\\((u_i)_{i\\in I}\\) 为一族从\\(E\\)到\\(F\\)的有界线性算子，即\\((u_i)_{i\\in I}\\subset\r\n\\mathcal{B}(E,F)\\)。若对\\(E\\)中任意点\\(x\\)，有\\(\\sup_{i\\in I}\\vert\\vert u_i(x)\\vert\\vert\r\n&lt;\\infty\\) ，则有\r\n\\[\r\n\\sup_{i\\in I}\\vert\\vert u\\vert\\vert &lt;\\infty\r\n\\]\r\n即算子族 \\((u_i)_{i\\in I}\\) 在 \\(\\mathcal{B}(E,F)\\)在有界，该算子族是有界集。\r\nproof\r\n证明前先说点别的，这个定理（命题）的逆否命题又叫做“共鸣定理”。Banach-Steinhaus\r\n定理通常也称作“一致有界原理”，而这个定理的发现者称他为 principal of\r\nconcentration of singularity\r\n（奇性聚集定理），也就是似乎它的发现者也是从这个命题的反向来理解的，总之这个命题的逆否命题是很重要的。比如，我们可以用来它说明Fourier级数的发散。下面回归正题：\r\n设 \\[\r\nM(x)=\\sup_{i\\in I}||u_i(x) ||\r\n\\] \\[\r\nF_n=\\{x\\in E:M(x)\\leq n\\}\r\n\\] 由\\(u_i\\)连续可知， \\[\r\n\\{x\\in E:||u_i(x) ||\\leq n\\}\r\n\\] 是\\(E\\)中闭集，那么， \\[\r\nF_n=\\bigcap_{i\\in I}\\{x\\in E:||u_i(x) ||\\leq n\\}\r\n\\] 也是闭集。 由定理假设，\\(\\forall\r\nx\\in E\\)，有\\(M(x)&lt;\\infty\\)\r\n，因此，对任意\\(x\\)必定属于某个\\(F_n\\) 于是有， \\[\r\nE=\\bigcup_{n\\geq 1}F_n\r\n\\] 由Baire定理，\\(E\\)是Banach空间，故\\(E\\)是Baire空间。由Baire空间的性质可知，\r\n\\(\\bigcup_{n\\geq 1}\\mathring{F_n}\\)\r\n在\\(E\\)中稠密，故存在某个\\(n\\)，使得\\(\\mathring{F_n}\\neq\\varnothing\\)\r\n。因此存在开球\\(B(x_0,r)\\subset\\mathring{F_n}\\) 即对\\(\\forall x\\in B(x_0,r)\\) 有， \\[\r\nM(x)=\\sup_{i\\in I}||u_i(x) ||\\leq n\r\n\\] 等价地，若\\(\\forall x\\in\r\nB(0,r)\\) 有， \\[\r\nM(x+x_0)=\\sup_{i\\in I}||u_i(x+x_0) ||\\leq n\r\n\\] 于是，由线性算子的线性， \\[\r\n||u_i(x+x_0-x_0)||\\leq||u_i(x+x_0||+||u_i(x_0)||\\leq n+M(x_0)\r\n\\] 还是因为线性，对\\(\\forall x\\in\r\nB(0,1)\\) \\[\r\n||u_i(x)||\\leq \\frac{n+M(x_0)}{r}=Constant\r\n\\] 故，\\(\\sup_{i\\in I}\\vert\\vert\r\nu\\vert\\vert &lt;\\infty\\)。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.5.18 Bessel不等式与Parserval恒等式","url":"/2023/05/18/23.5.18%20Bessel%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%B8%8EParserval%E6%81%92%E7%AD%89%E5%BC%8F/","content":"Bessel不等式 设\\(H\\)是Hilbert空间，\\((e_n)_{n\\geq 1}\\)是\\(H\\)中的规范正交序列，则对任意\\(x\\in H\\)，有， \\[\r\n\\sum_{n=1}^{\\infty}|\\langle x, e_n \\rangle|^2\\leq ||x||^2\r\n\\] Proof 对任意的\\(n\\)，有 \\[\r\n\\begin{aligned}\r\n||x-\\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k||^2&amp;=\\langle\r\nx-\\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k,x-\\sum_{k=1}^{n}\\langle x,\r\ne_k \\rangle e_k  \\rangle\\\\\r\n&amp;=\\langle x, x \\rangle+\\langle \\sum_{k=1}^{n}\\langle x, e_k \\rangle\r\ne_k, \\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k \\rangle-2Re\\{\\langle x,\r\n\\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k \\rangle\\}\\\\\r\n&amp;=||x||^2+\\sum_{k=1}^{n}\\langle x, e_k \\rangle\\langle  e_k,\r\n\\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k\r\n\\rangle-2Re\\{\\sum_{k=1}^{n}\\overline{\\langle x, e_k \\rangle}\\langle x,\r\ne_k \\rangle\\}\\\\\r\n&amp;=||x||^2+\\sum_{k=1}^{n}\\langle x, e_k \\rangle\\langle  e_k, \\langle\r\nx, e_k \\rangle e_k \\rangle-2Re\\{\\sum_{k=1}^{n}\\langle x, e_k\r\n\\rangle^2\\}\\\\\r\n&amp;=||x||^2+\\sum_{k=1}^{n}\\langle x, e_k \\rangle\\overline{\\langle x,\r\ne_k \\rangle}\\langle  e_k,  e_k \\rangle-2\\sum_{k=1}^{n}\\langle x, e_k\r\n\\rangle^2\\\\\r\n&amp;=||x||^2+\\sum_{k=1}^{n}\\langle x, e_k\r\n\\rangle^2\\cdot1-2\\sum_{k=1}^{n}\\langle x, e_k \\rangle^2\\\\\r\n&amp;=||x||^2-\\sum_{k=1}^{n}\\langle x, e_k \\rangle^2\\geq0\r\n\\end{aligned}\r\n\\] 于是不等式得证。\r\nParserval恒等式 设\\(H\\)是Hilbert空间，\\((e_n)_{n\\geq 1}\\)是\\(H\\)中的规范正交基，则对任意\\(x\\in H\\)，有， \\[\r\n\\sum_{n=1}^{\\infty}|\\langle x, e_n \\rangle|^2=||x||^2\r\n\\] 更一般地，\\(x，y\\in H\\)，有，\r\n\\[\r\n\\langle x, y \\rangle=\\sum_{n=1}^{\\infty}\\langle x, e_n \\rangle\\langle\r\ne_n, y \\rangle\r\n\\]\r\n证明明天补上。\r\n","categories":["Math","泛函"],"tags":["深夜食堂","不等式"]},{"title":"23.5.17 琴生不等式（Jenssen）","url":"/2023/05/17/23.5.17%20%E7%90%B4%E7%94%9F%E4%B8%8D%E7%AD%89%E5%BC%8F%EF%BC%88Jenssen%EF%BC%89/","content":"记\\(X\\)为一个随机变量。若\\(f\\)是一个下凸函数，则有， \\[E(f(X))\\geq f(E(X))\\] \\(f\\)是一个上凸函数，则有， \\[E(f(X))\\leq f(E(X))\\] 进一步，\\(f\\)是严格凸的（等号只在\\(\\lambda=0\\) or \\(1\\)成立），那么不等式取等当且仅当\\(X\\)是一个确定量（常数）。\r\nproof\r\n证明思路就是数学归纳法和利用凸函数的性质。下面只证明（下）凸函数，并且\\(X\\)为离散随机变量的情况。\r\n当\\(n=2\\)时，即 \\[\r\np_1f(X)+p_2f(X)\\geq f(p_1X+p_2X)\r\n\\] 而这可以由下凸函数的定义直接得到。\r\n假设不等式对于\\(n=k-1\\geq\r\n2\\)都成立， 当\\(n=k\\)时，有\r\n\\[\r\n\\begin{aligned}\r\nE(f(X))=\\sum_{i=1}^{k}p_if(X)&amp;=p_kf(X)+\\sum_{i=1}^{k-1}p_if(X)\\\\\r\n&amp;=p_kf(X)+(1-p_k)\\sum_{i=1}^{k-1}\\frac{p_i}{1-p_k}f(X)\\\\\r\n&amp;\\geq p_kf(X)+(1-p_k)f(\\sum_{i=1}^{k-1}\\frac{p_i}{1-p_k}X) \\quad\r\n(由假设得)\\\\\r\n&amp;\\geq f(p_k+(1-p_k)\\sum_{i=1}^{k-1}\\frac{p_i}{1-p_k}X) \\quad\r\n(由凸函数的定义得)\\\\\r\n&amp;=f(\\sum_{i=1}^{k}p_kX)=f(EX)\r\n\\end{aligned}\r\n\\] 由归纳原理，不等式对任意离散随机变量\\(X\\)成立。\r\n","categories":["Math"],"tags":["深夜食堂","不等式"]},{"title":"23.5.20 Schwarz不等式和内积的连续性","url":"/2023/05/20/23.5.20%20Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%92%8C%E5%86%85%E7%A7%AF%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7/","content":"Schwarz不等式 \\(\\forall\r\nx,y\\in H\\) ,\\(H\\)是Hilbert空间，有 \\[\r\n|(x,y)|^2\\leq(x,x)(y,y)\r\n\\]\r\nProof 对任意的\\(\\lambda\\in\\mathbb{C},x,y\\in H\\) \\[\r\n(x+\\lambda y,x+\\lambda\r\ny)=(x,x)+|\\lambda|^2(y,y)+\\lambda(y,x)+\\bar{\\lambda}(x,y)\\geq0\r\n\\] 若\\(y=0\\)，则不等式显然成立。\r\n若\\(y\\neq 0\\)，则令 \\[\r\n\\lambda=\\frac{-(x,y)}{(y,y)}\r\n\\] 代入上式得， \\[\r\n(x,y)+|\\frac{-(x,y)}{(y,y)}|^2(y,y)+\\frac{-(x,y)}{(y,y)}(y,x)+\\overline{\\frac{-(x,y)}{(y,y)}}(x,y)\\geq\r\n0\r\n\\] \\[\r\n(x,y)+\\frac{|(x,y)|^2}{(y,y)}+\\frac{-|(x,y)|^2}{(y,y)}+\\frac{-|(x,y)|^2}{(y,y)}\\geq\r\n0\r\n\\] \\[\r\n(x,y)\\geq\\frac{(x,y)^2}{(y,y)}\r\n\\] 故有， \\[\r\n|(x,y)|^2\\leq(x,x)(y,y)=||x||\\cdot||y||\r\n\\]\r\n内积的连续性 \\(H\\)是Hilbert空间,内积\\((x,y）\\)是关于\\(x,y\\)的连续函数，即 \\[\r\n(x,y)=(\\lim_{n\\to\\infty}x_n,\\lim_{n\\to\\infty}y_n)=lim_{n\\to\\infty}(x_n,y_n)\r\n\\]\r\nProof 要证明内积连续，即要说明 \\[\r\n|(x_n,y_n)-(x,y)|\\to 0\r\n\\] 考察， \\[\r\n\\begin{aligned}\r\n|(x_n,y_n)-(x_n+x-x_n,y)|&amp;=|(x_n,y_n)-(x_n,y)-(x-x_n,y)|\\\\\r\n&amp;\\leq|(x_n,y_n)-(x_n,y)|+|(x-x_n,y)|\\\\\r\n&amp;=|(x_n,y_n-y)|+|(x-x_n,y)|\r\n\\end{aligned}\r\n\\] 有Schwartz不等式得， \\[\r\n|(x_n,y_n-y)|+|(x-x_n,y)|\\leq||x_n||\\cdot||y_n-y||+||x_n-x||\\cdot||y||\r\n\\] 又因为\\(x_n\\to x,y_n\\to\r\ny\\quad(n\\to\\infty)\\) ,所以有\\(||x_n||\\)有界，以及 \\[\r\n||y_n-y||\\to0,||x_n-x||\\to0\r\n\\] 所以就有， \\[\r\n|(x_n,y_n)-(x,y)|\\to 0\r\n\\] 即内积是连续函数。\r\n","categories":["Math","泛函"],"tags":["深夜食堂","不等式"]},{"title":"23.5.19 Parserval 恒等式","url":"/2023/05/19/23.5.19%20Parserval%20%E6%81%92%E7%AD%89%E5%BC%8F/","content":"Parserval恒等式 设\\(H\\)是Hilbert空间，\\((e_n)_{n\\geq 1}\\)是\\(H\\)中的规范正交基，则对任意\\(x\\in H\\)，有， \\[\r\n\\sum_{n=1}^{\\infty}|\\langle x, e_n \\rangle|^2=||x||^2\r\n\\] 更一般地，\\(x，y\\in H\\)，有，\r\n\\[\r\n\\langle x, y \\rangle=\\sum_{n=1}^{\\infty}\\langle x, e_n \\rangle\\langle\r\ne_n, y \\rangle\r\n\\]\r\nProof 由Bessel不等式的证明过程可以发现，23.5.18\r\nBessel不等式与Parserval恒等式 \\[\r\n\\begin{aligned}\r\n||x-\\sum_{k=1}^{n}\\langle x, e_k \\rangle\r\ne_k||^2&amp;=||x||^2-\\sum_{k=1}^{n}\\langle x, e_k \\rangle^2\r\n\\end{aligned}\r\n\\] 即， \\[\r\n\\begin{aligned}\r\n||x||^2-||x-\\sum_{k=1}^{n}\\langle x, e_k \\rangle\r\ne_k||^2&amp;=\\sum_{k=1}^{n}\\langle x, e_k \\rangle^2\r\n\\end{aligned}\r\n\\] 我们先从直观感觉上看一下下面这个式子， \\[\r\n\\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k\r\n\\] 由于定理条件\\((e_n)_{n\\geq\r\n1}\\)是\\(H\\)中的规范正交基，\\(\\langle x, e_k \\rangle\\)相当于\\(x\\)在\\(e_k\\)上的投影，设\\(E_n=span\\{e_1,\\cdots,e_n\\}\\),那么 \\[\r\nP_{E_{n}}(x)=\\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k\\quad x\\in H\r\n\\] 即这个式子表达的含义为\\(x\\)在\\(E_n\\)上的投影,也就是\\(P_{E_n}(x)\\)，同时还注意到， \\[\r\n||P_{E_n}(x)||^2=\\langle P_{E_n}(x),P_{E_n}(x)\r\n\\rangle=\\langle\\sum_{k=1}^{n}\\langle x, e_k \\rangle\r\ne_k,\\sum_{k=1}^{n}\\langle x, e_k \\rangle e_k \\rangle\r\n\\] 即有， \\[\r\n||P_{E_n}(x)||^2=\\sum_{k=1}^{n}|\\langle x, e_k \\rangle|^2\r\n\\] 于是原来得到的恒等式就变成了， \\[\r\n\\begin{aligned}\r\n||x||^2-||x-P_{E_n}(x)||^2&amp;=||P_{E_n}(x)||^2\r\n\\end{aligned}\r\n\\]\r\n这样一来这个等式就更“清晰”了，因为它有着很“直观的”几何意义，有点类似于勾股定理：\r\n\r\n投影的长度2=向量长度2+(向量长度-投影长度)^2\r\n\r\n这件事情在二维和三维空间上都是很直观的。这个恒等式也说明了在更高维度空间这件事情也是存在的。\r\n但是实际上，上面的论证是很不严谨的，因为我们一开始并没有严格的给出投影的定义，仅从直观的角度出发去想象这样一个事实，由于严格论证需要很大篇幅，不符合我写这个专栏的目的相悖，今后可能会补充说明有关投影的事实，但今天的证明就先承认上面的等式。\r\n下面回归正题，要证明这个恒等式，实际上就是要证明当n趋于无穷大时，\r\n\\[\r\n||x-P_{E_n}(x)||^2\\to 0\r\n\\] 或者说，\\(x\\)在\\(E_n\\)上的投影是依范数收敛到\\(x\\)的，这其实在二维，三维情形上是很直观的事实。\r\n由于\\((e_n)_{n\\geq 1}\\)是\\(H\\)中的规范正交基，即这个序列张成的线性空间在\\(H\\)中是稠密的，于是有 \\[\r\n\\forall \\epsilon&gt;0\\forall x\\in H,\\exists y\\in\r\nspan\\{e_1,\\cdots,e_n\\}=E,\\quad s.t. ||x-y||\\leq\\epsilon\r\n\\] 因而， \\[\r\n||x-P_{E_n}(x)||\\leq||x-y||+||y-P_{E_n}(y)||+||P_{E_n}(y)-P_{E_n}(x)||\r\n\\] 由于投影算子是常数为1的Lipschitz映射，即(这个性质以后会证明)\r\n\\[\r\n||P_{E_n}(y)-P_{E_n}(x)||\\leq 1\\cdot||x-y||\r\n\\] 所以有， \\[\r\n||x-P_{E_n}(x)||\\leq2||x-y||+||y-P_{E_n}(y)||\\leq\r\n2\\epsilon+||y-P_{E_n}(y)||\r\n\\] 而对\\(y\\in\r\nspan\\{e_1,\\cdots,e_n\\}=E\\),存在\\(N\\geq\r\n1\\)和一系列数\\(\\alpha_i,i=1,\\cdots,N\\)使得， \\[\r\ny=\\sum_{i=1}^{N}\\alpha_ie_i\r\n\\] 则有， \\[\r\nP_{E_N}(y)=\\sum_{i=1}^{N}\\langle y, e_k \\rangle\r\ne_i=\\sum_{i=1}^{N}\\langle \\sum_{i=1}^{N}\\alpha_ie_i, e_i \\rangle\r\ne_i=\\sum_{i=1}^{N}\\alpha_ie_i=y\r\n\\] 因此，当\\(n\\geq N\\)时，就有，\r\n\\[\r\n||x-P_{E_n}(x)||\\leq 2\\epsilon+||y-P_{E_n}(y)||=2\\epsilon\r\n\\] 也就有了 \\[\r\n\\limsup_{n\\to\\infty}||x-P_{E_n}(x)||=0\r\n\\] 故， \\[\r\n\\begin{aligned}\r\n\\lim_{n\\to\\infty}(||x||^2-||x-P_{E_n}(x)||^2)&amp;=\\lim_{n\\to\\infty}||P_{E_n}(x)||^2\\\\\r\n||x||^2+0&amp;=||P_{E}(x)||^2\\\\\r\n\\end{aligned}\r\n\\] 即， \\[\r\n||x||^2=||\\sum_{n=1}^{\\infty}\\langle x,e_n\\rangle e_n||^2\r\n\\] 这就是Parserval恒等式。\r\n注意，上面取极限的过程用到了范数的连续性，并且\\(E=\\cup_{n=1}^{\\infty}E_n\\) 。\r\n尽管补充了这些，但其实证明还是不严谨的，因为，我们并没有说明，极限 \\[\r\n\\lim_{n\\to\\infty}P_{E_n}(x)\r\n\\] 是一定存在的，且它的极限就等于\\(x\\)在\\(E\\)上的投影，这些事实看似显然或者不显然，但都是需要论证的，碍于篇幅，以后有机会再补充。\r\n至于下边的那个等式的证明其实很简单，但是因为为了简化上面恒等式省略了很多篇幅，导致说明起来不那么容易，这其实也是追求直观感受的“代价”吧。还是有机会再补充。\r\n不过这里也可以提示一下，如果承认了下面事实 \\[\r\nx=\\lim_{n\\to\\infty}P_{E_n}(x)=\\sum_{i=1}^{\\infty}\\langle x,e_i\\rangle\r\ne_i\r\n\\] 等式是不是显然成立的？\r\n另外，Parserval最常见的使用场景是再Fourier级数上，定义平方可积空间上的内积，我们就得到了经常可以看到的Parserval恒等式。\r\n\\[\r\n\\frac{a_0^2}{4}+\\frac{1}{2}\\sum_{n=1}^{\\infty}(a_n^2+b_n^2)=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}|f(x)|^2dx\r\n\\]\r\n","categories":["Math","泛函"],"tags":["深夜食堂","不等式"]},{"title":"23.5.22 赋范空间完备的充要条件","url":"/2023/05/23/23.5.22%20%E8%B5%8B%E8%8C%83%E7%A9%BA%E9%97%B4%E5%AE%8C%E5%A4%87%E7%9A%84%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6/","content":"定理内容\r\n赋范空间\\((E,||\\cdot||)\\)是完备的，等价于此空间中的绝对收敛级数必收敛。\r\nProof \\((\\Leftarrow)\\) 任取该空间中Cauchy列\\((x_n)\\)，可以选择子列\\((x_{n_k})\\)满足， \\[\r\n||x_{n_{k+1}}-x_{n_k}||\\leq2^{-k}\r\n\\] 那么可以知道（柯西判别法），数项级数， \\[\r\n\\sum_{k\\geq1}||x_{n_{k+1}}-x_{n_k}||\r\n\\] 是收敛的，即，级数 \\[\r\n\\sum_{k\\geq1}(x_{n_{k+1}}-x_{n_k})\r\n\\]\r\n绝对收敛。由充分性假设（空间中的绝对收敛级数必收敛），可得，级数 \\[\r\n\\lim_{k\\to\\infty}x_{n_k}=\\sum_{k\\geq1}(x_{n_{k+1}}-x_{n_k})\r\n\\] 是收敛的，即子列\\((x_{n_k})\\)收敛。故而原柯西列也是收敛的，即证明了空间完备。\r\n\\((\\Rightarrow)\\) 设级数 \\[\r\n\\sum_{k\\geq1}x_k,\\quad S_n=\\sum_{k=1}^nx_k\r\n\\] 是绝对收敛的，那么， \\[\r\n||S_{n+p}-S_n||=||\\sum_{k=n+1}^{n+p}x_k||\\leq\\sum_{k=n+1}^{n+p}||x_k||\\to0,\\forall\r\nn,p\\in\\mathbb{N}^+\r\n\\] 即\\((S_n)\\)为\\(E\\)中Cauchy列，由于必要性假设（空间是完备的），故空间中的Cauchy列收敛，\\((S_n)\\)收敛，也就是级数 \\[\r\n\\sum_{k\\geq1}x_k\r\n\\] 是收敛的。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.5.21 Lp空间上的几个重要不等式","url":"/2023/05/21/23.5.21%20Lp%E7%A9%BA%E9%97%B4%E4%B8%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E4%B8%8D%E7%AD%89%E5%BC%8F/","content":"写在开始\r\n很多人在高中接触到这几个不等式的时候可能会想凭什么这几个有点晦涩的不等式要被称作重要不等式。笔者认为，主要是高中阶段的竞赛书并没有给出\\(L^p\\)空间这样一个清晰的背景，\"重要\"一词又显得过于宽泛才造成的这个疑惑。\r\n实际上，三个不等式中最重要的应该是Minkowski不等式，这个不等式说明了\\(L^p\\)空间在\\(1\\leq p\\leq\r\n\\infty\\)时可以成为一个赋范空间（有范数，p范数），在\\(0&lt;p&lt;1\\)时可以成为一个度量空间（没有范数但是可以引入度量，p范数的p次幂），因此，称这个不等式是\\(L^p\\)空间的基石也不为过。另外两个不等式是证明Minkowski不等式的脚手架，但也各有用处，比如Holder不等式是研究\\(L^p\\)空间对偶关系的重要工具。（以上为个人想法，不喜勿喷）\r\nYoung 不等式\r\n\\[\r\nxy\\leq\\alpha x^\\frac{1}{\\alpha}+\\beta y^\\frac{1}{\\beta}\r\n\\] 其中， \\[\r\nx,y\\geq0,\\quad\\alpha+\\beta=1，1\\geq\\alpha,\\beta\\geq 0\r\n\\]\r\nProof 利用指数函数的凸性即可证明， \\[\r\n\\alpha e^{\\frac{1}{\\alpha}\\ln x}+\\beta e^{\\frac{1}{\\beta}\\ln y}\r\n\\] 令， \\[\r\ns=\\frac{1}{\\alpha}\\ln x,t=\\frac{1}{\\beta}\\ln y\r\n\\] 则， \\[\r\nx=e^{\\alpha s},y=e^{\\beta t},\\quad xy=e^{\\alpha s+\\beta t}\r\n\\] \\[\r\n\\alpha e^{\\frac{1}{\\alpha}\\ln x}+\\beta e^{\\frac{1}{\\beta}\\ln y}=\\alpha\r\ne^s+\\beta e^t\r\n\\] 由指数函数的凸性即得， \\[\r\nxy=e^{\\alpha s+\\beta t}\\leq\\alpha e^s+\\beta e^t=x^\\frac{1}{\\alpha}+\\beta\r\ny^\\frac{1}{\\beta}\r\n\\]\r\n另外，如果令， \\[\r\n\\alpha=\\frac{1}{p},\\beta=\\frac{1}{q},\\frac{1}{p}+\\frac{1}{q}=1\r\n\\] 不等式就变成了， \\[\r\nxy\\leq\\frac{x^p}{p}+\\frac{y^q}{q}\r\n\\] 我们把p, q称作共轭数，表示他们两的倒数的和为1。\r\nHolder 不等式\r\n\\[\r\n||f\\cdot g||_r\\leq||f||_p\\cdot||g||_q\r\n\\] 其中， \\[\r\n\\frac{1}{p}+\\frac{1}{q}=\\frac{1}{r},\\quad 0&lt; p,q\\leq\\infty\r\n\\] \\[\r\nf\\in L^p(\\Omega),g\\in L^q(\\Omega)\r\n\\]\r\nProof 若 \\[\r\np,q=\\infty\r\n\\] 或者 \\[\r\np=\\infty,q\\neq\\infty;q=\\infty,p\\neq\\infty\r\n\\] 只需要利用无穷范数（本性上确界）的定义说明即可。\r\n重点说明 \\[\r\np,q\\neq\\infty\r\n\\] 的情况。\r\n由Young不等式得，注意\\(\\frac{r}{p}+\\frac{r}{q}=1\\), \\[\r\n\\begin{aligned}\r\n\\int_{\\Omega}|fg|^rd\\mu&amp;=\\int_{\\Omega}|f|^r|g|^rd\\mu\\leq\\int_{\\Omega}\\frac{r}{p}|f|^{r\\frac{p}{r}}+\\frac{r}{q}|g|^{r\\frac{q}{r}}d\\mu\\\\\r\n&amp;=\\frac{r}{p}||f||_p^p+\\frac{r}{q}||g||_q^q\r\n\\end{aligned}\r\n\\] 若 \\[\r\n||f||_p\\leq 1,\\quad||g||_q\\leq 1\r\n\\] 则有， \\[\r\n\\int_{\\Omega}|fg|^rd\\mu\\leq\\frac{r}{p}||f||_p^p+\\frac{r}{q}||g||_q^q\\leq\\frac{r}{p}+\\frac{r}{q}=1\r\n\\] 对于一般情形，即 \\[\r\n||f||_p&gt;0,\\quad||g||_q&gt;0\r\n\\] 我们令， \\[\r\nF=\\frac{f}{||f||_p},\\quad G=\\frac{g}{||g||_q}\r\n\\] 显然\\(||F||_p\\leq1,||G||_q\\leq1\\),所以， \\[\r\n\\int_{\\Omega}|FG|^rd\\mu=\\int_{\\Omega}|\\frac{f}{||f||_p}\\frac{g}{||g||_q}|^rd\\mu\\leq1\r\n\\] 即， \\[\r\n\\int_{\\Omega}|fg|^rd\\mu\\leq||f||_p^r||g||_q^r\r\n\\] \\[\r\n||fg||^r_r\\leq||f||_p^r||g||_q^r\r\n\\] \\[\r\n||fg||_r\\leq||f||_p||g||_q\r\n\\] 命题得证。\r\nMinkowski 不等式\r\n\\[\r\n||f+g||_p\\leq||f||_p+||g||_p\\quad 1\\leq p\\leq\\infty,f,g\\in L^p(\\Omega)\r\n\\]\r\nProof 设p,q为一对共轭数，由Holder不等式得， \\[\r\n\\begin{aligned}\r\n\\int_{\\Omega}|f+g|^pd\\mu&amp;\\leq\\int_{\\Omega}(|f|+|g|)|f+g|^{p-1}d\\mu\\\\\r\n&amp;=\\int_{\\Omega}|f|\\cdot|f+g|^{p-1}d\\mu+\\int_{\\Omega}|g|\\cdot|f+g|^{p-1}d\\mu\\\\\r\n&amp;\\leq||f||_p||(f+g)^{p-1}||_q+||g||_p||(f+g)^{p-1}||_q\\quad(Holder)\r\n\\end{aligned}\r\n\\] 注意， \\[\r\n||(f+g)^{p-1}||_q=(\\int_{\\Omega}(|f+g|^{p-1})^q\r\nd\\mu)^{\\frac{1}{q}},\\quad q=\\frac{p}{p-1}\r\n\\] \\[\r\n||(f+g)^{p-1}||_q=(\\int_{\\Omega}(|f+g|^p\r\nd\\mu)^{\\frac{p-1}{p}}=||f+g||_p^{p-1}\r\n\\] 于是， \\[\r\n\\begin{aligned}\r\n||f+g||_p^p=\\int_{\\Omega}|f+g|^pd\\mu&amp;\\leq||f||_p||(f+g)^{p-1}||_q+||g||_p||(f+g)^{p-1}||_q\\quad(Holder)\\\\\r\n&amp;=||f||_p||f+g||_p^{p-1}+||g||_p||f+g||_p^{p-1}\\\\\r\n&amp;=(||f||_p+||g||_p)||f+g||_p^{p-1}\r\n\\end{aligned}\r\n\\] 故有， \\[\r\n||f+g||_p\\leq||f||_p+||g||_p\r\n\\]\r\n","categories":["Math","泛函"],"tags":["深夜食堂","不等式"]},{"title":"23.5.23 有限维空间所有范数等价","url":"/2023/05/23/23.5.23%20%E6%9C%89%E9%99%90%E7%BB%B4%E7%A9%BA%E9%97%B4%E6%89%80%E6%9C%89%E8%8C%83%E6%95%B0%E7%AD%89%E4%BB%B7/","content":"什么是范数等价\r\n设\\(p,q\\)为向量空间\\(E\\)上两个范数，如果存在常数\\(m,M&gt;0\\)使得，\r\n\\[\r\nmp(x)\\leq q(x)\\leq Mp(x),\\forall x\\in E\r\n\\]\r\n则称范数\\(p\\)和\\(q\\)等价。\r\n有限维向量空间上所有范数都等价\r\n定理内容\r\n设\\(E\\)为数域\\(\\mathbb{K}\\)上的有限维向量空间，那么其上所有范数都等价。\r\nProof\r\n其证明是通过建立任意有限维向量空间与\\(n\\)维的欧式空间同构关系得到的。\r\n设空间的维数为\\(\\dim E=n\\),\r\n并设\\(e_1,\\cdots,e_n\\)为\\(E\\)的一组基，那么\\(\\forall x\\in E\\)，有\r\n\\[\r\nx=\\sum_{k=1}^nx_ke_k,\\quad(x_1,\\cdots,x_n)\\in \\mathbb{K}^n\r\n\\]\r\n于是得到\\(\\mathbb{K}^n\\)到\\(E\\)上的双射，\\(\\Phi:(x_1,\\cdots,x_n)\\to x\\) 。\r\n设\\(p(\\cdot)\\)为\\(E\\)上的任一范数，由范数的三角不等式得，\r\n\\[\r\np(x)\\leq \\max_{1\\leq k\\leq\r\nn}|x_k|\\sum_{k=1}^np(e_k)\\leq||(x_1,\\cdots,x_n)||_{\\infty}M,\\quad\r\nM=\\sum_{k=1}^np(e_k)\r\n\\]\r\n那么对任意的\\(\\Phi:(x_1,\\cdots,x_n)\\to\r\nx\\)，\\(\\Phi:(y_1,\\cdots,y_n)\\to\r\ny\\)，有\r\n\\[\r\np(x-y)\\leq M||(x_1-y_1,\\cdots,x_n-y_n)||_{\\infty}\r\n\\]\r\n因此得到的\\(\\varphi(\\cdot)=p(\\Phi(\\cdot))\\)是\\((\\mathbb{K},||\\cdot||_{\\infty})\\)\r\n上的连续实值函数，\r\n\\[\r\n\\varphi:(\\mathbb{K},||\\cdot||_{\\infty})\\to [0,+\\infty],\\quad\r\n(x_1,x_2,\\dots,x_n)\\to p(x)=p(\\Phi(x_1,x_2,\\dots,x_n))\r\n\\] 取\\(S\\)为\\(\\mathbb{K}\\)上的单位闭球，\\(S\\)有界且自列紧，\\(\\varphi\\)是连续实值函数，故\\(\\varphi\\)可在\\(S\\)上取得最小值，记为\\(m\\)，即 \\[\r\n\\varphi(x_1,x_2,\\dots,x_n)\\geq m,\\quad\\forall (x_1,x_2,\\dots,x_n)\\in S\r\n\\] 对于\\(\\forall x\\in E\\)且\\(x\\neq 0\\),对应有 \\[\r\n(x_1,x_2,\\dots,x_n)\\in \\mathbb{K},\\quad\r\n\\frac{(x_1,x_2,\\dots,x_n)}{||x_1,x_2,\\dots,x_n||_{\\infty}}\\in S\r\n\\] 于是有， \\[\r\n\\varphi(\\frac{(x_1,x_2,\\dots,x_n)}{||x_1,x_2,\\dots,x_n||_{\\infty}})=p(\\Phi(\\frac{(x_1,x_2,\\dots,x_n)}{||x_1,x_2,\\dots,x_n||_{\\infty}}))=p(\\frac{x}{||x_1,x_2,\\dots,x_n||_{\\infty}})\\geq\r\nm\r\n\\] 即得， \\[\r\np(x)\\geq m||x_1,x_2,\\dots,x_n||_{\\infty}\r\n\\] 综上所述， \\[\r\nm||x_1,x_2,\\dots,x_n||_{\\infty}\\leq p(x)\\leq\r\nM||x_1,x_2,\\dots,x_n||_{\\infty},\\quad \\forall x\\in E\r\n\\] 由此可得，\\(E\\)上所有范数都等价。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.5.24 赋范空间是有限维度的充要条件","url":"/2023/05/24/23.5.24%20%E8%B5%8B%E8%8C%83%E7%A9%BA%E9%97%B4%E6%98%AF%E6%9C%89%E9%99%90%E7%BB%B4%E5%BA%A6%E7%9A%84%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6/","content":"Riesz 引理\r\n在证明之前，需要知道一个引理。\r\n设赋范空间\\((E,||\\cdot||)\\)，\\(F\\)是\\(E\\)的一个闭的线性子空间，且\\(F\\neq E\\)，那么任取\\(1&gt;\\epsilon&gt;0\\)，存在\\(e\\in E\\)，满足\\(||e||=1\\)且\\(d(e.F)\\geq 1-\\epsilon\\) 。\r\nProof\r\n因为\\(F\\neq E\\)，所以存在\\(x\\in E\\backslash F\\)，记\\(x\\)到\\(F\\)的距离为\\(d\\)， \\[\r\nd=d(x,F)=\\inf\\{||x-y||:\\forall y\\in E\\}\r\n\\] 因为\\(F\\)是闭的，所以\\(d&gt;0\\)，否则， \\[\r\n\\exists x_n\\in F,s.t.||x-x_n||\\to 0\r\n\\] 又\\(F\\)是闭的，则有\\(x\\in F\\)，这与\\(x\\in E\\backslash F\\)矛盾。\r\n任取\\(1&gt;\\epsilon&gt;0\\),可取一点\\(y\\in F\\)，使得（这是由下确界定义得到）\r\n\\[\r\nd\\leq||x-y||\\leq\\frac{d}{1-\\epsilon}\r\n\\] 设 \\[\r\ne=\\frac{x-y}{||x-y||}\r\n\\] 则\\(e\\)为\\(E\\)中单位向量且\\(e\\notin F\\) ,任取一点\\(z\\in F\\)，有， \\[\r\n\\begin{aligned}\r\n||e-z||&amp;=||\\frac{x-y}{||x-y||}-z||\\\\\r\n&amp;=\\frac{1}{||x-y||}||x-y-||x-y||z||\\\\\r\n&amp;\\geq\\frac{1}{\\frac{d}{1-\\epsilon}}d=1-\\epsilon\r\n\\end{aligned}\r\n\\] 这样我们就找到了满足条件的单位向量\\(e\\)。\r\n有限维的充要条件（Riesz 定理）\r\n设赋范空间\\((E,||\\cdot||)\\)，则\\(E\\)是有限维度的充分必要条件是赋范空间\\((E,||\\cdot||)\\)上的闭单位球是紧的。\r\nProof 必要性可以用23.5.23\r\n有限维空间所有范数等价中的定理保证。\r\n下面证明充分性。 假设\\(E\\)是无穷维的，首先记\\(E\\)中的单位向量\\(x_1\\)，并设 \\[\r\nF_1=\\mathbb{K}x_1=\\{\\lambda x_1:\\lambda\\in\\mathbb{K}\\}\r\n\\] 则\\(F_1\\)是\\(x_1\\)生成的向量子空间，且\\(\\dim\r\nF_1=1\\)，由于有限维线性赋范空间总是完备的，所以\\(F_1\\)是\\(E\\)的完备子空间，完备的子空间是闭的，所以\\(F\\)是\\(E\\)的闭向量子空间。又因为\\(E\\)是无穷维的，所以\\(E\\neq\r\nF\\)，那么由上面的引理可得，存在单位向量\\(x_2\\in E\\)，满足 \\[\r\n||x_2||=1,\\quad d(x_2,F_1)\\geq 1-\\frac{1}{2}\r\n\\] 于是， \\[\r\n||x_1-x_2||\\geq\\frac{1}{2}\r\n\\] 记由\\(F_2=span\\{x_1,x_2\\}\\)，且\\(\\dim F_2\\leq 2\\)，所以\\(E\\neq F_2\\)， 同理可得\\(x_3\\in E\\)，满足 \\[\r\n||x_3||=1,\\quad d(x_3,F_2)\\geq \\frac{1}{2}\r\n\\] 如此反复，我们得到了单位球面上的序列\\((x_n)\\)，其元素两两之间的距离 \\[\r\nd(x_i,x_j)\\geq \\frac{1}{2},\\forall i,j\\in\\mathbb{N}^+\r\n\\] 故\\((x_n)\\)没有收敛子列，这与单位球面是紧的（充分性假设）矛盾。于是假设不成立，\\(E\\)只能是有限维的。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.5.25 压缩映射的不动点","url":"/2023/05/26/23.5.25%20%E5%8E%8B%E7%BC%A9%E6%98%A0%E5%B0%84%E7%9A%84%E4%B8%8D%E5%8A%A8%E7%82%B9/","content":"在很多数学分支中，比如金融数学中（应该），压缩映射的不动点定理都是很基本的一个定理。\r\n但是其证明并不是很难，今天的深夜食堂就分享不动点定理的证明。\r\n定理内容 设\\((E,d)\\)是完备的度量空间，\\(f:E\\to E\\)是压缩映射，则\\(f\\)有唯一的不动点，即 \\[\r\nf(x)=x,\\quad\\exists ! x\\in E\r\n\\]\r\n注：\\(\\quad\\exists !\\)\r\n表示\"存在唯一的\"\r\nProof 压缩映射的定义就是指满足：\\(\\exists\\lambda &lt;1,\\forall x,y\\in\r\nE\\),总有\r\n\\[\r\nd(f(x),f(y))\\leq \\lambda d(x,y)\r\n\\] 的映射\\(f\\)，称为压缩映射。\r\n下面开始证明， 取一点列\\((x_n)\\)，其中\\(x_1\\)为\\(E\\)中任意一点，其余点满足 \\[\r\nf(x_{n-1})=x_n\r\n\\] 由于\\(f\\)是压缩映射，可知存在\\(\\lambda&lt;1\\)使得， \\[\r\nd(x_n,x_{n-1})=d(f(x_{n-1}),f(x_{n-2}))\\leq\\lambda\r\nd(x_{n-1},x_{n-2})\\leq\\cdots\\leq\\lambda^{n-2}d(x_2,x_1)\r\n\\] 那么对任意的\\(p\\in\\mathbb{N}\\)有， \\[\r\nd(x_{n+p},x_n)\\leq\r\nd(x_{n+p},d_{n+p-1})+\\cdots+d(x_{n+1},x_n)\\leq(\\lambda^{n+p-2}+\\cdots+\\lambda^{n-1})d(x_2,x_1)\r\n\\] 因为\\(\\lambda&lt;1\\)，所有当\\(n\\to\\infty\\) 时， \\[\r\nd(x_{n+p},x_n)\\to 0\r\n\\] 故\\((x_n)\\)是Cauchy序列。由于\\(E\\)是完备的，故其上柯西列收敛，设其收敛于\\(x\\)，于是， \\[\r\nf(x)=f(\\lim_{n\\to\\infty}x_n)=\\lim_{n\\to\\infty}f(x_n)=\\lim_{n\\to\\infty}x_{n+1}=x\r\n\\] 不动点的存在性得证。\r\n下面证明唯一性。 设\\(x,y\\)都是不动点，那么 \\[\r\nd(x,y)=d(f(x),f(y))\\leq \\lambda d(x,y),\\quad\\lambda&lt;1\r\n\\] 因此必有\\(x=y\\)，唯一性得证。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.5.29 有界线性算子的基本性质","url":"/2023/05/29/23.5.29%20%E6%9C%89%E7%95%8C%E7%BA%BF%E6%80%A7%E7%AE%97%E5%AD%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8/","content":"定义\r\n线性映射\r\n设\\(E,F\\)为数域\\(\\mathbb{K}\\)上的两个向量空间，若映射\\(u\\) \\[\r\n\\begin{aligned}\r\nu:&amp;E\\to F\\\\\r\n\\end{aligned}\r\n\\] 满足， \\[\r\n\\begin{aligned}\r\nu(ax+y)=au(x)+u(y),\\ a\\in\\mathbb{K}\r\n\\end{aligned}\r\n\\] 称\\(u\\)为线性算子。显然，积分和微分这两种运算都是线性算子。\r\n记\\(\\mathcal{L}(E,F)\\)为从\\(E\\)到\\(F\\)的所有线性映射组成的集合。\r\n有界线性映射\r\n设\\(E,F\\)为数域\\(\\mathbb{K}\\)上的两个赋范空间，若映射\\(u\\)为线性映射且满足， \\[\r\n\\|u(x)\\| \\leqslant C\\|x\\|,\\ \\forall x\\in E\r\n\\] 则称\\(u\\)有界。\r\n记\\(\\mathcal{B}(E,F)\\)为从\\(E\\)到\\(F\\)的所有有界线性映射组成的集合。\r\n基本性质\r\n设 \\(E\\) 和 \\(F\\) 是数域 \\(\\mathbb{K}\\) 上的两个赋范空间, \\(u \\in \\mathcal{L}(E, F)\\) ,\r\n那么下面命题等价: (1) \\(u\\) 在 \\(E\\) 上连续. (2) \\(u\\) 在某一点连续. (3) \\(u\\) 在原点连续. (4) 存在 \\(C \\geqslant 0\\) , 使得 \\(\\forall x \\in E\\) , 有 \\(\\|u(x)\\| \\leqslant C\\|x\\|\\) .\r\nProof \\((1)\\Rightarrow(2)\\) 显然。\r\n\\((2)\\Rightarrow(3)\\) 设\\(u\\)在\\(x_0\\)处连续，\\(\\forall\\epsilon&gt;0\\)存在半径为\\(r\\)的开球\\(B(x_0,r)\\)，使得 \\[\r\n||u(x)-u(x_0)||\\leq\\epsilon,\\ \\forall x\\in B(x_0,r)\r\n\\] 取任意\\(y\\in\r\nB(0,r)\\)，有\\(y+x_0\\in\r\nB(x_0,r)\\)，于是有， \\[\r\n||u(y)||=||u(x_0+y)-u(x_0)||\\leq\\epsilon\r\n\\] 故在原点连续。\r\n\\((3)\\Rightarrow(4)\\) 设\\(u\\)在原点处连续，取\\(\\epsilon=1\\)存在半径为\\(r_0\\)的开球\\(B(0,r_0)\\)，使得 \\[\r\n||u(x)||\\leq 1,\\ \\forall x\\in B(0,r_0)\r\n\\] 那么任取\\(y\\in E\\)，有\\(r_0\\frac{y}{||y||}\\in B(0,r_0)\\)，于是\r\n\\[\r\n||u(r_0\\frac{y}{||y||})||\\leq 1\\Rightarrow\r\n||u(y)||\\leq\\frac{||y||}{r_0},\\forall y\\in E\r\n\\] 令\\(C=\\frac{1}{r_0}\\)即可。\r\n\\((4)\\Rightarrow(1)\\) 任取\\(x-y\\in E\\),于是有， \\[\r\n||u(x)-u(y)||\\leq C||x-y||\r\n\\] 即\\(u\\)是Lipschitz连续的，那么必连续。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.5.26 Cauchy列的简单性质","url":"/2023/05/26/23.5.26%20Cauchy%E5%88%97%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/","content":"Cauchy列的几个性质\r\n\r\n若\\((x_n)\\)为收敛序列，则必为柯西列。\r\n若\\((x_n)\\)为柯西列且有收敛子列，则该序列收敛。\r\n柯西列必有界。\r\n\r\nProof 以下讨论默认在度量空间\\((E,d)\\)下。\r\n（1）设\\(\\lim_{n\\to\\infty}x_n=x\\)，即（极限定义），\r\n\\[\r\n\\forall\\epsilon&gt;0,\\exists N,s.t. n\\geq N,d(x_n,x)\\leq\\epsilon\r\n\\] 那么对于任意的\\(m,n\\leq N\\)，\r\n\\[\r\nd(x_m,x_n)\\leq d(x_m,x)+d(x,x_n)\\leq2\\epsilon\r\n\\] 故\\((x_n)\\)为柯西列。\r\n（2）设\\((x_{n_k})\\)是柯西列\\((x_n)\\)的收敛子列，设\\(\\lim_{k\\to\\infty}x_{n_k}=x_0\\)，即（极限定义），\r\n\\[\r\n\\forall\\epsilon&gt;0,\\exists K,s.t. k\\geq K,d(x_{n_k},x_0)\\leq\\epsilon\r\n\\] 又\\((x_n)\\)为为柯西列，由柯西列的定义， \\[\r\n\\forall p\\in\\mathbb{N}^+\\ \\forall\\epsilon&gt;0,\\exists N,\\ s.t. n\\geq\r\nN,d(x_{n+p},x_n)\\leq\\epsilon\\quad\r\n\\] 因此取\\(n\\geq N, p\\geq\r\nn_K-n\\), \\[\r\nd(x_n,x_0)\\leq d(x_n,x_{n+p})+d(x_{n+p},x_0)\\leq 2\\epsilon\r\n\\]\r\n故\\((x_n)\\)收敛。\r\n（3）设\\((x_n)\\)为为柯西列。取\\(\\epsilon=1\\) \\[\r\n\\exists N,\\ s.t. n,m\\geq N,d(x_n,x_m)\\leq1\r\n\\] 即，当\\(n&gt;N\\)时， \\[\r\nd(x_n,x_N)\\leq 1\r\n\\] 取 \\[\r\nM=\\max\\{\\max_{1\\leq k\\leq N}(d(x_k,x_N)),1\\}\r\n\\] 则对任意的\\(n\\)，有\\(d(x_n,x_N)\\leq M\\)，故有界。\r\n","categories":["Math","基本性质"],"tags":["深夜食堂"]},{"title":"23.5.31 可分度量空间","url":"/2023/05/31/23.5.31%20%E5%8F%AF%E5%88%86%E5%BA%A6%E9%87%8F%E7%A9%BA%E9%97%B4/","content":"定义\r\n稠密\r\n设\\(A,B\\)为度量空间\\(E\\)中的集合，如果有\\(\\bar{B}\\supset A\\) ，则称\\(B\\)在\\(A\\)中稠密。\r\n注意：有的教材上对稠密的定义为\\(\\bar{B}=A\\)，但我们使用上面的定义。另外，定义中没有要求B一定是A的子集。\r\n用\\(\\epsilon-\\delta\\)语言描述，\r\n\\[\r\n\\forall x\\in A,\\bar{B}\\supset A\\Rightarrow\r\nx\\in\\bar{B}\\Leftrightarrow\\forall\\epsilon&gt;0,\\exists\r\nBall(x,\\epsilon)\\cap B\\neq\\varnothing\r\n\\] \\[\r\n\\exists y\\in B,d(x,y)&lt;\\epsilon\r\n\\] 也就是说，\\(A\\)中任意点都可以用\\(B\\)中的点列逼近。\r\n例子：有理数集在实数集中稠密，无理数集也在实数集中稠密。\r\n有理数集在无理数集中稠密，反之一样，但注意这两个集合的交集是空集。\r\n可分\r\n设度量空间\\(E\\)，如果\\(E\\)存在一个稠密的子集并且这个子集的元素个数是可数的，则称该度量空间是可分的。\r\n定理：度量空间\\(E\\)可分，当且仅当\\(E\\)中存在一个可数列，序列中的元素与\\(E\\)中任意元素的距离可以任意小。\r\n常见度量空间的可分性判定\r\n（1）高维实数空间\\(\\mathbb{R}^n\\)是可分的。 因为有理数集\\(\\mathbb{Q}^n\\)是可数的，且在\\(\\mathbb{R}^n\\)中稠密，故\\(\\mathbb{R}^n\\)可分。\r\n（2）区间上连续函数的全体\\(C[a,b]\\)可分。\r\n连续函数可以用多项式逼近（Weierestrass定理），多项式可以用有理多项式逼近，有理多项式的全体是可数的。\r\n（3）空间\\(l^{\\infty}=\\{x=(x_1,\\cdots,x_n,\\cdots|\\max{|x_i|}\\leq\r\nc_x)\\}\\)不可分 反证法。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.5.30 度量空间的紧性","url":"/2023/05/30/23.5.30%20%E5%BA%A6%E9%87%8F%E7%A9%BA%E9%97%B4%E7%9A%84%E7%B4%A7%E6%80%A7/","content":"紧性的定义\r\n紧性，是很多数学学科中的基础概念，出现频率特别高。分析学中一些基本定理的成立，本质上是因为其拓扑的紧性。\r\n简单地说，“紧的”指的就是任意开覆盖都有有限子覆盖，数学专业的学生应该在学习实数系的基本定理的时候就接触过这个概念，什么是覆盖，什么是开覆盖，什么是有限覆盖定理。有限覆盖定理揭示了闭区间的一个本质属性也就是“紧致性”（简称为紧性）。\r\n紧性是一种拓扑概念，一个集合是不是紧的依赖其所在空间的拓扑结构，下面是紧性的定义:\r\n设 \\(E\\) 是拓扑空间. (1) 若 \\(E\\) 上的开集族 \\(\\left(O_{i}\\right)_{i \\in I}\\) 满足 \\(E=\\bigcup_{i \\in I} O_{i}\\), 则称 \\(\\left(O_{i}\\right)_{i \\in I}\\) 是 \\(E\\) 的开覆盖. (2) 若 \\(E\\) 的任意一个开覆盖 \\(\\left(O_{i}\\right)_{i \\in I}\\)\r\n中都可取出有限个子集覆盖, 则称 \\(E\\) 是\r\n紧的 (也就是说, 存在 \\(I\\) 的有限子集\r\n\\(J\\), 使得 \\(\\bigcup_{i \\in J} O_{i}=E\\) ).\r\n紧性的刻画\r\n在度量空间中，紧性有着更加丰富的刻画，特别是可以同序列来刻画紧性。\r\n今晚介绍的度量空间中的紧性刻画定理，是在泛函分析中经常使用到的，提到紧性要能够很自然的想起这几种紧性的刻画。（当然要限定在度量空间中使用）\r\n紧性刻画定理 设 \\((E,\r\nd)\\) 是度量空间, 则下面的命题等价: (1) \\((E, d)\\) 是紧空间. (2) 任一 \\(E\\) 中的无限子集必有凝聚点 (称这样的 \\(E\\) 是列紧的). (3) 任一 \\(E\\) 中的序列有收敛的子列 (称这样的 \\(E\\) 是序列紧的). (4) \\((E, d)\\) 是完备的且预紧的 (预紧性是指:\r\n对任意 \\(\\varepsilon&gt;0, E\\)\r\n可被有限个以 \\(\\varepsilon\\)\r\n为半径的开球覆盖).\r\nProof \\((1)\\Rightarrow(2)\\) 反证法。假设\\(E\\)中有无限集\\(F\\)没有凝聚点，即 \\[\r\n\\forall x\\in E,\\exists\\ open\\ ball\\  B(x,\\epsilon_x),\\\r\ns.t.B(x,\\epsilon_x)\\cap (F\\backslash\\{x\\})=\\emptyset\r\n\\] 显然， \\[\r\nE=\\bigcup_{x \\in E} B(x,\\epsilon_x)\r\n\\] 即\\(\\bigcup_{x \\in E}\r\nB(x,\\epsilon_x)\\)是\\(E\\)的开覆盖，又 \\((E, d)\\)\r\n是紧空间，则由紧性的定义，可取出有限个子集覆盖，记成 \\[\r\n\\bigcup_{1\\leq k\\leq n} B(x_k,\\epsilon_k)=E\r\n\\] 注意， \\[\r\n\\begin{aligned}\r\n&amp;B(x,\\epsilon_x)\\cap F=\\{x\\}&amp;x\\in F\\\\\r\n&amp;B(x,\\epsilon_x)\\cap F=\\emptyset&amp;x\\notin F\r\n\\end{aligned}\r\n\\] 因此， \\[\r\n\\bigcup_{1\\leq k\\leq n} B(x_k,\\epsilon_k)\r\n\\] 最多只能包含\\(F\\)中的\\(n\\)个点，而 \\[\r\nF\\subset E=\\bigcup_{1\\leq k\\leq n} B(x_k,\\epsilon_k)\r\n\\] 即\\(F\\)是\\(\\bigcup_{1\\leq k\\leq n}\r\nB(x_k,\\epsilon_k)\\)的子集（应该包含\\(F\\)的全部点，也就是说应该包含无限个点），这与\\(F\\)是无限集矛盾。\r\n\\((2)\\Rightarrow(3)\\)\r\n设无限序列\\((x_n)\\in\r\nE\\)。若序列中只有有限个不同的值，则容易取出收敛子列。若序列是无限个不同的值，则由”\r\n任一 \\(E\\)\r\n中的无限子集必有凝聚点“，知序列有凝聚点，由凝聚点的定义容易取出一收敛子列。\r\n设序列有凝聚点\\(x\\)，任取开球\\(B(x,\\frac{1}{k})\\), 都有 \\[\r\n(B(x,\\frac{1}{k}) \\cap (x_n)) \\backslash\\{x\\} \\neq \\varnothing\r\n\\] 在上面的集合中取一点\\(x_{n_k}\\)，且\\(x_{n_k}\\neq\r\nx_{n_{k-1}}\\)，如此就得到了一收敛子列。\r\n\\((3)\\Rightarrow(4)\\) 任取\\(E\\)中柯西列\\((x_n)\\)，由” 任一 \\(E\\) 中的序列有收敛的子列“，可知柯西列\\((x_n)\\)有收敛子列，那么这个柯西列就是收敛的（柯西列的简单性质）。故空间\\(E\\)是完备的。下面证明预紧性。\r\n假设\\(E\\)不是预紧的，即存在 \\(\\varepsilon&#39;&gt;0, E\\) 不可被有限个以\r\n\\(\\varepsilon&#39;\\)\r\n为半径的开球覆盖。此时任取\\(x_1\\)，必有\\(E\\subsetneq B(x_1,\\epsilon&#39;)\\)\r\n，任取\\(x_2\\in E\\backslash\r\nB(x_1,\\epsilon&#39;)\\)，有\\(E\\subsetneq\r\n(B(x_1,\\epsilon&#39;)\\cup B(x_2,\\epsilon&#39;))\\)\r\n。如此反复可得一无穷序列\\((x_n)\\)，且这个序列的任意两个元素间的距离（或者说度量）\r\n\\[\r\nd(x_n,x_m)\\geq \\epsilon&#39; \\quad \\forall n\\neq m\r\n\\] 那么这个序列不存在收敛子列，矛盾，E是预紧的。\r\n\\((4)\\Rightarrow(3)\\) \\((E, d)\\) 是完备的且预紧的。因为\\(E\\)是完备的，要说明任一 \\(E\\)\r\n中的序列有收敛的子列，我们只要说明任一 \\(E\\) 中的序列有柯西子列。 首先取\r\n\\(\\varepsilon_{1}=\\frac{1}{2}\\), 由于\r\n\\(E\\) 是预紧空间,\r\n故存在有限子集 \\(F \\subset\r\nE\\), 使得 \\(E=\\) \\(\\bigcup_{x \\in F} B\\left(x,\r\n\\varepsilon_{1}\\right)\\), 则无穷序列 \\(\\left(x_{n}\\right)\\)\r\n必有一个无穷子序列包含于某个开球 \\(B\\left(x,\r\n\\varepsilon_{1}\\right)\\). 我 们记该子序列为 \\(\\left(x_{1_{i}}\\right)_{i \\geqslant 1}\\);\r\n再令 \\(\\varepsilon_{2}=\\frac{1}{2^{2}}\\), 则又有\r\n\\(\\left(x_{1_{i}}\\right)_{i \\geqslant\r\n1}\\) 的无穷子列 \\(\\left(x_{2_{i}}\\right)_{i \\geqslant 1}\\) 包\r\n含于某个以 \\(\\varepsilon_{2}\\)\r\n为半径的开球中; 依此类推, 对任一个整数 \\(n \\in\r\n\\mathbb{N}^{*}\\), 取 \\(\\varepsilon_{n}=\\frac{1}{2^{n}}\\),\r\n可以给出一个无穷序列 \\(\\left(x_{n_{i}}\\right)_{i \\geqslant 1}\\),\r\n它是 \\(\\left(x_{(n-1)_{i}}\\right)_{i \\geqslant\r\n1}\\) 的子序列, 并且满足: 对任意 \\(i, j\r\n\\geqslant 1\\), 有 \\[\r\nd\\left(x_{n_{i}}, x_{n_{j}}\\right)&lt;\\frac{1}{2^{n-1}}\r\n\\] 接下来运用 “对角线选择法”, 可以得到 \\(\\left(x_{n}\\right)\\) 的子列 \\(\\left(x_{i_{i}}\\right)_{i \\geqslant 1}\\),\r\n该序列满足: 当 \\(i, j \\geqslant n\\) 时,\r\n\\(d\\left(x_{i_{i}},\r\nx_{j_{j}}\\right)&lt;\\frac{1}{2^{n-1}}\\). 故 \\(\\left(x_{i_{i}}\\right)_{i \\geqslant 1}\\) 是\r\n\\(\\left(x_{n}\\right)\\) 的一个 Cauchy\r\n子序列。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.6.2 处处连续且处处不可微的函数是很多的","url":"/2023/06/02/23.6.2%20%E5%A4%84%E5%A4%84%E8%BF%9E%E7%BB%AD%E4%B8%94%E5%A4%84%E5%A4%84%E4%B8%8D%E5%8F%AF%E5%BE%AE%E7%9A%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%BE%88%E5%A4%9A%E7%9A%84/","content":"前置概念\r\nBarie空间\r\n定义：称拓扑空间\\(E\\)是一个 Baire\r\n空间,若\\(E\\)中任意 、\r\n可数多个 、 稠密 、\r\n开集的交仍然在\\(E\\)中稠密。\r\nBarie定理\r\n定理(Baire)：设 \\((E, d)\\)\r\n是完备度量空间, \\(\\left(O_{n}\\right)_{n\r\n\\geqslant 1}\\) 是一列在 \\(E\\) 中\r\n稠密的开子集, 则 \\(O=\\bigcap_{n \\geqslant 1}\r\nO_{n}\\) 在 \\(E\\) 中稠密.\r\n换句话说就是，完备度量空间是第二纲的。\r\n定理：局部紧的 Hausdorff 空间是 Baire 空间. 定理：设 \\(E\\) 是 Baire 空间, 则 (1) \\(E\\) 的任意开子集也是一个 Baire 空间. (2) 设\r\n\\(\\left(F_{n}\\right)_{n \\geqslant 1}\\)\r\n是 \\(E\\) 的一列闭子集, 并且 \\(E=\\bigcup_{n \\geqslant 1} F_{n}\\) , 那么\r\n\\(\\bigcup_{n \\geqslant 1}\r\n\\stackrel{\\circ}{F}_{n}\\) 在 \\(E\\) 中 稠密。\r\n第一纲集（贫集、疏集）\r\n设 \\(E\\) 是拓扑空间. (1) 称 \\(E\\)\r\n中可数多个开子集的交集为 \\(\\mathcal{G}_{\\delta}\\) 集, 称 \\(E\\)\r\n中可数多个闭子集的并集 为 \\(\\mathcal{F}_{\\sigma}\\) 集. (2) 称 \\(A \\subset E\\) 为贫集 (或第一纲集), 若 \\(A\\) 为某个无内点的 \\(\\mathcal{F}_{\\sigma}\\) 集的子集; 称 \\(A \\subset E\\) 为剩余集（第二纲集）, 若\r\n\\(A\\) 包含一个稠密的 \\(\\mathcal{G}_{\\delta}\\) 集.\r\n注： (1) \\(A\\) 是 \\(\\mathcal{G}_{\\delta}\\) 集等价于 \\(A^{c}\\) 是 \\(\\mathcal{F}_{\\sigma}\\) 集. (2) \\(A\\) 是贫集等价于 \\(A^{c}\\) 是剩余集, 这是因为集合 \\(A\\) 是稠密的当且仅当 \\(A^{c}\\) 无内点, 从而 \\(A\\) 是稠密的 \\(\\mathcal{G}_{\\delta}\\) 集当且仅当 \\(A^{c}\\) 是无内点的 \\(\\mathcal{F}_{\\sigma}\\) 集. (3) 设 \\(E\\) 是 Baire 空间, 则 \\(E\\) 中可数多个贫集的并集仍然是贫集;\r\n可数多个剩余集的交仍然是剩余集. (4) 贫集和剩余集的概念描述了子集的大小.\r\n如果和测度论中的概念相比较, 我们可以把贫集对应着零测度集,\r\n剩余集对应于与全集几乎处处相等的集合, 它们的性质极为类似.\r\n今日份的定理\r\n在\\(C[0,1]\\)中处处不可微的函数集合\\(E\\)是非空的，并且E的余集是第一纲集（贫集）。\r\nProof 取 \\(\\mathcal{H}=C[0,1]\\), 设 \\(A_{n}\\) 表示 \\(\\mathcal{H}\\) 中特定元素 \\(f\\) 的集合，如下： \\[\r\nA_n=\\{f\\in \\mathcal{H}:\\left|\\frac{f(s+h)-f(s)}{h}\\right| \\leqslant\r\nn,\\exists s\\in [0,1],\\forall |h|\\leq\\frac{1}{n},s+h\\in [0,1] \\}\r\n\\] 从\\(A_n\\)的构造我们可以知道，若 \\(f\\) 在某个点 \\(s\\) 处可微, 则必有正整数 \\(n\\), 使得 \\(f \\in\r\nA_{n}\\), 于是 \\[\r\n\\mathcal{H} \\backslash E \\subset \\bigcup_{n=1}^{\\infty} A_{n}\r\n\\] 下面我们证明每个 \\(A_{n}\\)\r\n是贫集，为此先证 \\(A_{n}\\)\r\n是闭的。为此，我们去证明其补集是开的。\r\n事实上, 若 \\(f \\in \\mathscr{X} \\backslash\r\nA_{n}\\), 则 \\(\\forall s \\in[0,1],\r\n\\exists |h_{s}|\\leqslant \\frac{1}{n}\\), 使得 \\[\r\n\\left|f\\left(s+h_{s}\\right)-f(s)\\right|&gt;n\\left|h_{s}\\right|\r\n\\] 又由 \\(f\\) 的连续性, \\(\\exists \\varepsilon_{s}&gt;0\\), 以及 \\(s\\) 的某个适当的邻域 \\(J_{s}\\), 使得对 \\(\\forall \\sigma \\in J_{s}\\), 有 \\[\r\n\\left|f\\left(\\sigma+h_{s}\\right)-f(\\sigma)\\right|&gt;n\\left|h_{s}\\right|+2\r\n\\varepsilon_{s}\r\n\\] 根据有限覆盖定理, 可设 \\(J_{s_{1}},\r\nJ_{s_{2}}, \\cdots, J_{s_{m}}\\) 覆盖 \\([0,1]\\), 并设 \\[\r\n\\varepsilon=\\min \\left\\{\\varepsilon_{s_{1}}, \\varepsilon_{s_{2}},\r\n\\cdots, \\varepsilon_{s_{m}}\\right\\}\r\n\\] 若 \\(g \\in \\mathcal{H}\\) 适合\r\n\\(\\|g-f\\|&lt;\\varepsilon\\), 则由 \\[\r\n\\left|f\\left(\\sigma+h_{s}\\right)-f(\\sigma)\\right|&gt;n\\left|h_{s}\\right|+2\r\n\\varepsilon_{s}\r\n\\] 对 \\(\\forall \\sigma \\in\r\nJ_{s_{k}}(k=\\) \\(1,2, \\cdots,\r\nm\\) ) 有 \\[\r\n\\left|g\\left(\\sigma+h_{s_{k}}\\right)-g(\\sigma)\\right|\r\n\\geqslant\\left|f\\left(\\sigma+h_{s_{k}}\\right)-f(\\sigma)\\right|-2\r\n\\varepsilon&gt;n\\left|h_{s_{k}}\\right|\r\n\\] 于是证明了 \\(\\mathcal{H} \\backslash\r\nA_{n}\\) 是开集，从而 \\(A_{n}\\)\r\n是闭集。\r\n再证 \\(A_{n}\\)\r\n没有内点。 \\(\\forall f \\in\r\nA_{n}, \\forall \\varepsilon&gt;0\\), 由 Weierstrass 逼近定理,\r\n存在多项式 \\(p\\), 使得 \\[\r\n\\|f-p\\|&lt;\\frac{\\varepsilon}{2}\r\n\\] 由于\\(p\\) 的导数在 \\([0,1]\\) 上是有界的, 因此根据中值定理, \\(\\exists M&gt;0\\), 使得 对 \\(\\forall s \\in[0,1]\\) 及 \\(|h|&lt;1 / n\\), 成立 \\[\r\n|p(s+h)-p(s)| \\leqslant M|h|\r\n\\] 设 \\(g(s) \\in C[0,1]\\)\r\n是一个分段线性函数, 满足 \\(\\|g\\|&lt;\\varepsilon / 2\\).\r\n并且各条线段斜率的绝对值都大于 \\(M+n\\),\r\n那么 \\[\r\np+g \\in B(f, \\varepsilon), \\text { 而 } p+g \\bar{\\epsilon} A_{n}\r\n\\] 这样, 我们证明了每个 \\(A_{n}\\) 是贫集, 从而 \\(\\bigcup_{n=1}^{\\infty} A_{n}\\)\r\n是第一纲集。而 \\(\\mathcal{H}\\)\r\n是完备的, 由 Baire 定理 \\(\\mathcal{H}\\)\r\n是第二纲集, 由此根据 \\[\r\n\\mathcal{H} \\backslash E \\subset \\bigcup_{n=1}^{\\infty} A_{n}\r\n\\] 可知\\(E\\) 也是第二纲集。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.6.6 有界线性算子空间成为完备赋范空间","url":"/2023/06/06/23.6.6%20%E6%9C%89%E7%95%8C%E7%BA%BF%E6%80%A7%E7%AE%97%E5%AD%90%E7%A9%BA%E9%97%B4%E6%88%90%E4%B8%BA%E5%AE%8C%E5%A4%87%E8%B5%8B%E8%8C%83%E7%A9%BA%E9%97%B4/","content":"我们知道有界线性算子空间\\(\\mathcal{B}(E,F)\\)是线性算子空间\\(\\mathcal{L}(E,F)\\)的向量子空间，并且可以赋予范数，\r\n\\[\r\n||u||=\\sup_{x\\in E}\\frac{||u(x)||_F}{||x||_E}\r\n\\] 成为赋范空间。下面定理说明的是，在什么样的条件下\\(\\mathcal{B}(E,F)\\)可以成为Banach空间，也就是完备线性赋范空间。\r\n定理\r\n设\\(E\\)是赋范空间，\\(F\\)是Banach空间，则\\(\\mathcal{B}(E,F)\\)也是Banach空间。\r\nProof 我们只证明\\(\\mathcal{B}(E,F)\\)是完备的，即\\(\\mathcal{B}(E,F)\\)上任意柯西列都收敛。\r\n设\\((u_n)\\)是\\(\\mathcal{B}(E,F)\\)中的柯西列，任意给定的\\(x\\in E\\)，有， \\[\r\n||u_m(x)-u_n(x)||_F=||(u_m-u_n)(x)||_F\\leq||u_m-u_n||\\cdot||x||_E\r\n\\] \\((u_n)\\)是\\(\\mathcal{B}(E,F)\\)中的柯西列，故\\(m,n\\)充分大时， \\[\r\n||u_m-u_n||\\to 0\r\n\\] 于是可知\\((u_n(x))\\)是\\(F\\)中的柯西列，由于\\(F\\)是Banach空间，\\((u_n(x))\\)是收敛的，记其极限为\\(u(x)\\)。 由此此我们可以定义一个映射， \\[\r\nu:E\\to F\r\n\\] 下面需要说明的是，这个新定义的映射也是有界线性算子，即\\(u\\in\\mathcal{B}(E,F)\\)。\r\n（1）线性，这是容易的。 \\[\r\nu(\\lambda x+y)=\\lim_{n\\to\\infty}u_n(\\lambda\r\nx+y))=\\lim_{n\\to\\infty}\\lambda u_n(x)+u_n(y)=\\lambda u(x)+u(y)\r\n\\] （2）有界，对于 \\[\r\n||u(x)||_F\\leq||u||\\cdot||x||_E=||\\lim_{n\\to\\infty}u_n||\\cdot||x||_E\r\n\\] 由范数连续性 \\[\r\n||\\lim_{n\\to\\infty}u_n||\\cdot||x||_E=\\lim_{n\\to\\infty}||u_n||\\cdot||x||_E\r\n\\] 因为\\((u_n)\\)是\\(\\mathcal{B}(E,F)\\)中的柯西列，必有界，故存在\\(M\\)，使得 \\[\r\n||\\lim_{n\\to\\infty}u_n||\\cdot||x||_E=\\lim_{n\\to\\infty}||u_n||\\cdot||x||_E\\leq\r\nM||x||_E\\\r\n\\] 于是 \\[\r\n||u(x)||_F\\leq M||x||_E\r\n\\] 故\\(u\\)是有界的。\r\n至此我们知道，\\(u\\in\\mathcal{B}(E,F)\\)。\r\n最后说明，\\((u_n)\\)是收敛到\\(u\\)的。（是依照有界线性算子空间中的范数收敛）\r\n前面我们得出了对\\(\\forall x\\in\r\nE\\)，有， \\[\r\n||u_m(x)-u_n(x)||_F\\leq||u_m-u_n||\\cdot||x||_E\r\n\\] 对\\(\\forall\\epsilon&gt;0,\\exists\r\nN\\)当\\(m,n&gt;N\\)时， \\[\r\n||u_m-u_n||\\leq\\epsilon\r\n\\] 所以 \\[\r\n||u_m(x)-u_n(x)||_F\\leq||u_m-u_n||\\cdot||x||_E\\leq\\epsilon||x||_E\r\n\\] 令\\(m\\to\\infty\\)且有范数连续性得， \\[\r\n||u(x)-u_n(x)||_F\\leq\\epsilon||x||_E\r\n\\] 于是由范数定义， \\[\r\n||u-u_n||=\\sup_{x\\in E}\\frac{||u(x)-u_n(x)||_F}{||x||_E}\\leq\\epsilon\r\n\\] 故\\(\\mathcal{B}(E,F)\\)中有\\(u_n\\to u\\)。综上，\\(\\mathcal{B}(E,F)\\)是一个Banach空间。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.6.1 压缩映射定理的进一步讨论","url":"/2023/06/02/23.6.1%20%E5%8E%8B%E7%BC%A9%E6%98%A0%E5%B0%84%E5%AE%9A%E7%90%86%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA/","content":"定理回顾\r\n23.5.25 压缩映射的不动点\r\n\r\n定理内容 设\\((E,d)\\)是完备的度量空间，\\(f:E\\to E\\)是压缩映射，则\\(f\\)有唯一的不动点，即 \\[\r\nf(x)=x,\\quad\\exists ! x\\in E\r\n\\] 注：\\(\\quad\\exists !\\)\r\n表示\"存在唯一的\"\r\n\r\n讨论\r\n（1）压缩映射的条件能不能去掉或改变。\r\n\r\n压缩映射的定义就是指满足：\\(\\exists\\lambda\r\n&lt;1,\\forall x,y\\in E\\),总有\r\n\\[\r\nd(f(x),f(y))\\leq \\lambda d(x,y)\r\n\\] 的映射\\(f\\)，称为压缩映射。\r\n\r\n如果映射\\(f\\)只满足， \\[\r\nd(f(x),f(y))&lt; d(x,y)\r\n\\] 或者说\\(\\lambda =\r\n1\\)且把\\(\\leq\\)换做＜时，压缩映射定理能不能成立？这样的改动看似变化不大，毕竟\r\n\"小于1\"和\"小于等于一个小于1的常数\"，这两件事给我们的感觉是有点相似的。但是这里还是有些区别。\r\n问题的答案是不能做这样的变动。因为有如下面的反例： \\[\r\nf(x)=x^2+1,\\ \\forall x\\in(0,1)\r\n\\] \\[\r\nf(x)=\\sqrt{x^2+1},\\ \\forall x\\in(0,\\infty)\r\n\\]\r\n它们都满足我们改变后的条件，但是显然在各自的定义域内找不到一点使得\\(f(x)=x\\)。\r\n（2）能不能再加上什么限制，减弱的条件也能有类似的结果呢？\r\n这是可以的。如果\\((E,d)\\)是紧的度量空间，那么压缩映射的条件就可以减弱为，\r\n\\[\r\nd(f(x),f(y))&lt; d(x,y)\\quad \\forall x\\neq y,\\ x,y\\in E\r\n\\]\r\nProof 设\\(g(x)=d(x,f(x))\\)，因为\\(f\\)和\\(d\\)都是连续映射，故\\(g\\)也连续。由于\\(E\\)紧的，所以\\(g(E)\\)紧。\r\n于是在紧空间上的连续函数可以取得最小值，记作\\(\\lambda\\) 。\r\n我们假设取得最小值时\\(\\lambda&gt;0\\)，也就是此时仍是\\(d(x_{min},f(x_{min})&gt;0\\)，也就是说，\r\n\\[\r\nx_{\\min}\\neq f(x_{min})\r\n\\] 实际上我们就是在假设不动点不存在。\r\n那么， \\[\r\nd(f(x_{min},f^2(x_{min})))&lt;d(x_{min},f(x_{min}))=\\lambda\r\n\\] 这与\\(\\lambda\\)是\\(g\\)的最小值矛盾，因为我们发现在假设下，\r\n\\[\r\ng(f(x_{min}))&lt;g(x_{min})\r\n\\] 于是假设不成立。故$。（注意距离函数d是非负的）\r\n不动点的唯一性的证明就容易了。 假设存在两个不动点\\(x,y\\)，那么 \\[\r\nd(f(x),f(y))=d(x,y)\r\n\\] 与 \\[\r\nd(f(x),f(y))&lt; d(x,y)\\quad \\forall x\\neq y,\\ x,y\\in E\r\n\\] 矛盾。\r\n（3）设\\((E,d)\\)是完备的度量空间，如果\\(f,g\\)是可交换的压缩映射，这两个映射有相同唯一的不动点。\r\n\\(f,g\\)是可交换，是指\\(fg=gf\\)。证明是容易的。因为设\\(f(x_0)=x_0\\) \\[\r\ng(x_0)=g(f(x_0))=f(g(x_0))\r\n\\] 所以\\(g(x_0)\\)是\\(f\\)的不动点。由于不动点是唯一的，所以 \\[\r\ng(x_0)=x_0\r\n\\] 现在我们如果把可交换的条件去掉会怎么样？\r\n此时，两个映射的不动点没有必然联系，可以相同可以不同。 比如取， \\[\r\nf\\equiv 1,g\\equiv0\r\n\\] \\[\r\nf(x)=(x-1)^2+1,g(x)=x^2,x\\in(0,\\infty)\r\n\\]\r\n上面的两个不可换有不同的不动点，下面的不可换但有相同不动点。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"23.6.5 所有多项式构成的空间不能赋予完备范数","url":"/2023/06/05/23.6.5%20%E6%89%80%E6%9C%89%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9E%84%E6%88%90%E7%9A%84%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%83%BD%E8%B5%8B%E4%BA%88%E5%AE%8C%E5%A4%87%E8%8C%83%E6%95%B0/","content":"命题\r\n所有多项式构成的空间不能赋予完备范数。\r\n证明\r\n为此，我们需要先证明一个引理。\r\n\r\n设\\(E\\)是赋范空间，\\(F\\)是\\(E\\)的向量子空间。若\\(F\\neq E\\)，则\\(F\\)在\\(E\\)的内部是空集。\r\n\r\nProof 因为\\(F\\neq\r\nE\\)，所以\\(\\exists x&#39;\\in\r\nE\\backslash F\\) ，假设\\(\\mathring{F}\\neq\\varnothing\\)，那么\\(\\exists x_0\\in F,s.t. B(x_0,r)\\subset F\\) ,\r\n由于\\(F\\)是向量子空间，有 \\[\r\nB(x_0,r)\\subset F\\Leftrightarrow x_0\\in F,B(0,r)\\subset F\r\n\\] 注意到 \\[\r\n\\frac{r}{2}\\frac{x&#39;}{||x&#39;||}\\in B(0,r)\\subset F\r\n\\] 又因为\\(F\\)是向量子空间，所以应有\\(x&#39;\\in F\\)，但这与\\(x&#39;\\in E\\backslash F\\)矛盾。\r\n下面来证明今日份的命题： 所有多项式构成的空间不能赋予完备范数。\r\nProof 记\\(P\\)为所有多项式构成的空间，\\(P_n\\)为最高次数不超过\\(n\\)的多项式的全体构成的空间。 显然\\(P_n\\)是\\(P\\)的向量子空间，且 \\[\r\nP=\\bigcup_{n\\geq 1}P_n\r\n\\] 因\\(P_n\\)是有限维的，所以\\(P_n\\)是完备的，完备子空间是闭的。\r\n现假设\\(P\\)是可以赋予完备范数的Banach空间。\r\n由于Banach 空间一定是Baire 空间，因此， \\[\r\n\\bigcup_{n\\geq 1}\\mathring{P_n}\r\n\\] 在\\(P\\)中稠密。但是由前边的引理知， \\[\r\n\\forall n\\geq 1,\\mathring{P_n}=\\varnothing\\Rightarrow \\bigcup_{n\\geq\r\n1}\\mathring{P_n}=\\varnothing\r\n\\] 空集不可能在\\(P\\)中稠密，故假设不成立，即所有多项式构成的空间不能赋予完备范数。\r\n证明过程中用到的结论\r\n\r\n有限维赋范空间都是完备的\r\n完备子空间是闭集\r\n完备度量空间（Banach空间）是Baire空间\r\nBaire空间的性质： 设 \\(E\\) 是 Baire\r\n空间, \\(\\left(F_{n}\\right)_{n \\geqslant\r\n1}\\) 是 \\(E\\) 的一列闭子集, 并且\r\n\\(E=\\bigcup_{n \\geqslant 1} F_{n}\\) ,\r\n那么 \\(\\bigcup_{n \\geqslant 1}\r\n\\stackrel{\\circ}{F}_{n}\\) 在 \\(E\\) 中 稠密。\r\n\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]},{"title":"绪论（运筹学）","url":"/2023/05/15/OP_%E7%BB%AA%E8%AE%BA/","content":"绪论\r\n起源\r\n现在普遍认为,运筹学的真正活动是从第二次世界大战初期的军事任务开始的。当时迫切需要把各项稀少的资源以更有效的方式分配给各种不同的军事作业及在每一作业内的各项活动。\r\n战争结束后,运筹学在战争中获得的成功引起了在军事行业以外的其他行业应用运筹学的兴趣。\r\n运筹学的特征\r\n\r\n研究方法类似科学领域已有方法（观察阐述问题、数据收集、数学建模、假设检验、模型调节）\r\n视野广泛、着眼组织整体（的利益）\r\n常寻求最优解\r\n运筹小组，团队工作\r\n\r\n影响\r\n大，效率提升\r\n运筹学建模方法综述\r\n\r\n定义感兴趣的问题并且收集相关数据。\r\n构建表示问题的数学模型。\r\n开发一个计算机程序,通过它从模型中求得问题的解\r\n检验模型(model validation),如果有必要,对模型进行调整。\r\n根据管理层的要求,准备模型的后续应用。\r\n实施。\r\n\r\n虽然本书的大部分篇幅主要集中在构建和求解数学模型上,但是本章我们已经尽量强调这只是典型运筹学研究整个过程的一个组成部分。这里所描述的其他阶段对于研究的成败也是非常重要的。学习后续章节时尽量记住模型和求解过程在整个过程中的作用。\r\n","categories":["Math","运筹"],"tags":["运筹学"]},{"title":"Hilbert 空间","url":"/2023/04/23/Hilber%20%E7%A9%BA%E9%97%B4/","content":"在调和分析、偏微分方程和量子力学中自然出现的许多空间是\r\nHilbert空间。容易看到，Hilbert空间是欧氏空间从有限维到无限维最直接的抽象和推广。Hilbert空间的出现和\r\nFourier 级数理论的发展密切相连，Fourier\r\n变换为我们在本章将要研究的共轭理论和正交展开理论提供了无限维情形下最直接的例子.\r\n# 内积空间 ## 定义 ### 内积 - 线性（注意复数域的情况） -\r\n对称（复数域注意是共轭对称） - 非负 ### Hilbert空间 设\\(H\\)为内积空间，定义范数(验证这个定义符合范数定义)\r\n\\[\r\n||x||=&lt;x,x&gt;^{\\frac{1}{2}}\r\n\\]\r\n称此范数为内积诱导的范数，\\(H\\)成为赋范空间，如果这个范数完备，则称\\(H\\)为Hilbert空间。 ## 例子 ### 常见内积空间\r\n### 常见Hilbert空间 ## 定理 ### Cauchy-Schwarz 不等式 设\\(H\\)为数域\\(\\mathbb{K}\\)上的内积空间，则对任意的\\(x,y\\in H\\)有，\r\n\\[\r\n|&lt;x,y&gt;|^2\\leq&lt;x,x&gt;&lt;y,y&gt;\r\n\\]\r\n等号成立当且仅当x,y成比例。 变形：\\(\\left&lt;x,y\\right&gt;\\leq||x||||y||\\)\r\nproof：（利用二次函数判别式）\r\n\\[\r\n\\forall\\lambda\\in\\mathbb{K},\\left&lt;x+\\lambda y,x+\\lambda\r\ny\\right&gt;\\geq 0\r\n\\]\r\n复数域时，取\\(\\lambda=t\\cdot?\\) ###\r\n极化恒等式 设\\(H\\)为数域\\(\\mathbb{K}\\)上的内积空间，那么 - \\(\\mathbb{K}=\\mathbb{R}\\)，则\r\n\\(&lt;x,y&gt;=\\frac{1}{2}(||x+y||^2-||x||^2-||y||^2)\\)\r\n- \\(\\mathbb{K}=\\mathbb{C}\\)，则\r\n\\(&lt;x,y&gt;=\\frac{1}{4}\\sum_{k=0}^3i^k||x+i^ky||^2\\)\r\nproof:由定义展开验证。\r\n注：由极化恒等式可以验证，两个内积空间中的线性等距映射\\(u:H\\to K\\)是保内积的。即， \\[\r\n&lt;u(x),u(y)&gt;=&lt;x,y&gt;\r\n\\]\r\n平行四边形公式\r\n设\\(H\\)为内积空间，\\(\\forall x,y\\in H\\)有，\r\n\\[\r\n||x+y||^2+||x-y||^2=2(||x||^2+||y||^2)\r\n\\]\r\n或者,\r\n\\[\r\n\\frac{1}{2}(||x+y||^2+||x-y||^2)=||x||^2+||y||^2\r\n\\]\r\n范数可以由内积导出\r\n设\\(H\\)为赋范空间，如果范数满足平行四边形公式，那么范数可以用内积导出，也即\\(H\\)可以成为内积空间。\r\nproof：证明分四步。设内积如下（只证明实数域情形，内积实际就是先设极化恒等式），\r\n\\[\r\n\\left&lt;x,y\\right&gt;=\\frac{1}{2}(||x+y||^2-||x||^2-||y||^2)\r\n\\]\r\n\r\n\\(\\mathbb{K}=\\mathbb{C}\\)\r\n(1)非负、对称性显然。 (2)下证线性。\r\n\\(\\left&lt;x,2y\\right&gt;=2\\left&lt;x,y\\right&gt;\\)\r\n\\(\\left&lt;x+x&#39;,y\\right&gt;=\\left&lt;x,y\\right&gt;+\\left&lt;x&#39;,y\\right&gt;\\)\r\n\\(\\lambda\\in\\mathbb{Q},\\left&lt;\\lambda\r\nx,y\\right&gt;=\\lambda\\left&lt;x,y\\right&gt;\\)\r\n\\(\\lambda\\in\\mathbb{R},\\left&lt;\\lambda\r\nx,y\\right&gt;=\\lambda\\left&lt;x,y\\right&gt;\\) # 投影算子 ## 定义\r\n### 正交和正交补 设\\(H\\)为内积空间，若\\(\\left&lt;x,y\\right&gt;=0,x,y\\in\r\nH\\)则称\\(x\\)与\\(y\\)正交(\\(x\\bot\r\ny\\))。若\\(A\\subset H\\),称\r\n\r\n\\[\r\nA^{\\bot}=\\{x\\in H:x\\bot y,\\forall y\\in A\\}\r\n\\]\r\n为A再H中的正交补。 注： 1. \\(x\\bot y\\Rightarrow\r\n||x+y||^2=||x||^2+||y||^2\\) 2. 定义夹角：\\(\\cos\\theta=\\frac{Re\\left&lt;x,y\\right&gt;}{||x||||y||},x,y\\neq\r\n0\\) 3. 由内积连续性可知，对任意 \\(A \\subset H\\), \\(A^{\\perp}\\) 是 H 的闭向量子空间, 并有\r\n\\[\r\nA^{\\perp}=(\\bar{A})^{\\perp}=(\\operatorname{span}\r\nA)^{\\perp}=(\\overline{\\operatorname{span} A})^{\\perp}\r\n\\]\r\n定理\r\n投影定理\r\n设\\(H\\)为Hilbert空间，\\(C\\)是\\(H\\)的非空闭凸子集，那么， - 对任意\\(x\\in H\\)存在唯一的\\(y\\in C\\)使得 \\[\r\n||x-y||=d(x,C)=\\inf_{y\\in C}d(x,y)\r\n\\] 则称 \\(y\\) 是\\(x\\)在\\(C\\)上的投影，记作\\(P_C(x)\\). - 设\\(y\\in H\\),则\\(y=P_C(x)\\Leftrightarrow\r\nRe\\left&lt;x-y,z-y\\right&gt;\\leq 0,\\forall z\\in C\\) - 映射\\(x\\to\r\nP_C(x)\\)是常数为1的Lipschitz映射，即\r\n\\[\r\n||P_C(x)-P_C(x&#39;)||\\leq||x-x&#39;||\r\n\\]\r\n\r\n\\(P_C\\circ P_C=P_C\\)且\\(P_C(H)=C\\),即投影算子是幂等算子。\r\n\r\nproof：（1.下确界定义 Cauchy列 完备性\r\n平行四边形公式）（2.取凸组合）（3.用2的结论和Cauchy不等式）（4. 定义）\r\n注：证明只用到C的完备性.因此,若H是任意内积空间且C是完备的凸集，则定理的结论也成立.\r\n当上面定理的凸集C是向量子空间时,其投影有下面的简单刻画\r\n设\\(H\\)为Hilbert空间，\\(E\\)为\\(H\\)的闭的向量子空间。那么任意\\(x\\in H\\)，它的投影\\(P_E(x)\\)是\\(E\\)中满足\\(x-y\\perp E\\)的唯一元素\\(y\\)，并且\\(P_E\\)是\\(H\\)到\\(E\\)的线性算子，\\(||P_E||\\leq 1\\)。\r\nproof：投影定理的第二条、第三条 ### 正交分解 设 \\(H\\) 是 Hilbert 空间, \\(E\\) 是 \\(H\\) 的向量子空间, 则有\r\n\\[\r\nH=\\bar{E} \\oplus E^{\\perp}\r\n\\]\r\n也就是说, 任取 \\(x \\in H\\) ,\r\n存在唯一的分解 \\(x=y+z\\) , 这里 \\((y, z) \\in \\bar{E} \\times E^{\\perp}\\) ,\r\n并有\r\n\\[\r\n\\|x\\|^{2}=\\|y\\|^{2}+\\|z\\|^{2}\r\n\\]\r\nproof:书中唯一性证明好像有误。\r\n推论：设 \\(H\\) 是\r\nHilbert 空间, \\(E\\) 是 \\(H\\) 的向量子空间, 则有\r\n\\[\r\n(E^{\\perp})^{\\perp}=\\bar{E}\r\n\\]\r\nproof：（提示：\\(x\\in\r\nE^{\\perp},P_E(x)=0\\),E为向量空间） # 对偶和共轭 !!!\r\n一般来说,我们很难描述一个赋范空间的对偶空间.Riesz表示定理说明Hilbert空间的对偶空间是它本身.\r\n## 定义 ### 酉算子 映射 \\(u \\in\r\n\\mathcal{B}(H)\\) 被称为酉算子, 若 \\(u^{*} u=u u^{*}=\\mathrm{I}_{H}\\).\r\n注：\\(\\mathcal{B}(H)\\)在所有酉算子构成一个群。 ##\r\n定理 ### Riesz 表示定理 设\\(H\\)为数域\\(\\mathbb{K}\\)上的Hilbert空间，那么\\(\\varphi:H\\to\\mathbb{K}\\)是一个连续线性泛函的充要条件是存在向量\\(y\\in H\\)，使得\r\n\\[\r\n\\varphi(x)=\\left&lt;x,y\\right&gt;,\\forall x\\in H\r\n\\]\r\n而且如此得到的向量\\(y\\)是唯一的且满足\\(||y||=||\\varphi||\\) proof:\r\n注:定理结论表明了 ### 伴随算子 设\\(H,K\\)为两个的Hilbert空间，\\(u\\in\\mathcal{B}(H,K)\\)，那么存在唯一的\\(u^*\\in\\mathcal{B}(K,H)\\)使得，\r\n\\[\r\n\\left&lt;u^*(x),y\\right&gt;=\\left&lt;x,u(y)\\right&gt;,\\forall x\\in\r\nK,\\forall y\\in H\r\n\\]\r\n并且\\(||u||=||u^*||\\).称\\(u^*\\)为\\(u\\)的伴随。 proof：\r\n注：有如下几个结论 - \\((u^*)^*=u,u\\in \\mathcal{B}(H,K)\\) - 123 -\r\n123阿巴阿巴\r\n正交基\r\n这节将证明任一Hilbert空间均有正交基，这是Hilbert空间特有的性质;正交基是处理Hilbert空间的有效工具.\r\n## 定义 设\\(H\\)为Hilbert空间。 -\r\n向量族的正交 两两正交。 - 规范正交\r\n两两正交且各个向量的范数等于1。 - 完全的\r\n向量族的线性扩张（\\(span\\{(e_i)_{i\\in\r\nI}\\}\\),\\(I\\)指标集）在\\(H\\)中稠密。 - 规范正交基\r\n\\((e_i)_{i\\in I}\\)在\\(H\\)中规范正交且完全的，称为\\(H\\)的规范正交基。\r\n定理\r\n1\r\n设 \\(H\\) 是 Hilbert 空间, \\(\\left(e_{1}, \\cdots, e_{n}\\right)\\) 是\r\n\\(H\\) 中的规范正交序列, 令 \\(E=\\operatorname{span}\\left(e_{1}, \\cdots,\r\ne_{n}\\right)\\). 那么对任意 \\(x \\in\r\nH\\), 有\r\n\\[\r\nP_{E}(x)=\\sum_{i=1}^{n}\\left\\langle x, e_{i}\\right\\rangle e_{i}\r\n\\]\r\n且\r\n\\[\r\n\\|x\\|^{2}=\\left\\|x-P_{E}(x)\\right\\|^{2}+\\sum_{i=1}^{n}\\left|\\left\\langle\r\nx, e_{i}\\right\\rangle\\right|^{2}\r\n\\]\r\n2\r\n设 \\(H\\) 是 Hilbert 空间, \\(\\left(e_{n}\\right)_{n \\geqslant 1}\\) 是\r\n\\(H\\) 中的规范正交序列. 则\r\n下面命题等价: (1) \\(\\left(e_{n}\\right)_{n\r\n\\geqslant 1}\\) 是完全的 (即 \\(\\left(e_{n}\\right)_{n \\geqslant 1}\\) 是\r\n\\(H\\) 中的规范正交基). (2) 任取 \\(x \\in H\\), 存在唯一的序列 \\(\\left(x_{n}\\right) \\subset \\mathbb{K}\\),\r\n使得级数 \\(\\sum_{n \\geqslant 1} x_{n}\r\ne_{n}\\) 收敛到 \\(x\\). ###\r\nBessel不等式 ### Parseval恒等式 ### Gram-Schmidt 正交化\r\n任一可分的Hilbert空间具有一列(可为有限)规范正交基.\r\n设\\(H\\)是可分的非零Hilbert空间，则\\(H\\)有规范正交基.(这里提醒:一个拓扑空间是可分的,若它有最多可数的稠密子集.)\r\n.jpg\r\n","categories":["Math","泛函"],"tags":["泛函分析"]},{"title":"Project 3","url":"/2022/10/18/Project%203/","content":"练习一：Bezier曲线\r\n代码： # Bezier curveimport numpy as npimport mathfrom matplotlib import pyplot as pltdef Bernstein(t,n,i):    Bern = math.factorial(n)/(math.factorial(i)*math.factorial(n-i)) * pow(t,i) * pow(1-t,n-i)    return Berndef Bezier(X,t):    B = 0    for i in range(0,len(X)):        B = B + Bernstein(t,len(X)-1,i)*X[i]    return Bdef B_curve(X,Y,T):    XX = []    YY = []    for i in range(0,len(X)):        plt.plot(X[i],Y[i],&#x27;r^&#x27;)    for i in range(0,len(T)-1):        XX.append(Bezier(X,T[i]))        YY.append(Bezier(Y,T[i]))    plt.plot(XX,YY)    plt.show()X = [0,1,2,3]Y = [0,4,1,5]T = np.arange(0,1.0,0.01)T = np.ndarray.tolist(T)plt.plot(X,Y)B_curve(X,Y,T) 输出结果：\r\n\r\n练习二：细分算法（t=0.3，学号尾数位3）\r\n代码： # 细分分割算法 de Casteljau 算法import numpy as npimport mathfrom matplotlib import pyplot as pltdef Bernstein(t,n,i):    Bern = math.factorial(n)/(math.factorial(i)*math.factorial(n-i)) * pow(t,i) * pow(1-t,n-i)    return Berndef Bezier(X,t):    B = 0    for i in range(0,len(X)):        B = B + Bernstein(t,len(X)-1,i)*X[i]    return Bdef B_curve(X,Y,T):    XX = []    YY = []    for i in range(0,len(X)):        plt.plot(X[i],Y[i],&#x27;ro&#x27;)    for i in range(0,len(T)-1):        XX.append(Bezier(X,T[i]))        YY.append(Bezier(Y,T[i]))    plt.plot(XX,YY)def line(X,Y,t):    X1 = L(X,t)    Y1 = L(Y,t)    plt.plot(X1,Y1)    plt.plot(X1[0],Y1[0],&quot;r+&quot;)    plt.plot(X1[-1],Y1[-1],&quot;r+&quot;)    return X1,Y1def L(X,t):    XX = []    for i in range(0,len(X)-1):        XX.append((1-t)*X[i]+t*X[i+1])    return XXX = [0,1,2,3]#Y = [0,4,1,5]Y = [0,4,4,0]t = 0.3T = np.arange(0,1.0,0.01)T = np.ndarray.tolist(T)plt.plot(X,Y)B_curve(X,Y,T)#连线for i in range(len(X)-1):    X1,Y1 = line(X,Y,t)    X,Y = X1,Y1    if i == 3:        print(X,Y)plt.show() 输出结果：\r\n #\r\n练习三：升阶算法（自行设计图案） 代码： # 升阶算法import numpy as npimport mathfrom matplotlib import pyplot as pltdef Bernstein(t,n,i):    Bern = math.factorial(n)/(math.factorial(i)*math.factorial(n-i)) * pow(t,i) * pow(1-t,n-i)    return Berndef Bezier(X,t):    B = 0    for i in range(0,len(X)):        B = B + Bernstein(t,len(X)-1,i)*X[i]    return Bdef B_curve(X,Y,T):    XX = []    YY = []    for i in range(0,len(X)):        plt.plot(X[i],Y[i],&#x27;r^&#x27;)    for i in range(0,len(T)-1):        XX.append(Bezier(X,T[i]))        YY.append(Bezier(Y,T[i]))    plt.plot(XX,YY)def Ascending(X): #升阶    XX = []    l = len(X)    for i in range(0,l+1):        if i == 0:            XX.append(X[0])        elif i == l:                XX.append(X[l-1])        else:            XX.append(X[i]*((l-i)/l)+X[i-1]*(i/l))    return XXX = [0,2,1,0,2]Y = [0,4,6,4,0]n = 10       #升阶次数T = np.arange(0,1.0,0.01)T = np.ndarray.tolist(T)for i in range(0,n):    #升阶控制    X = Ascending(X)    Y = Ascending(Y)plt.plot(X,Y)B_curve(X,Y,T)plt.show()\r\n输出结果：（升阶了十次） \r\n","categories":["Math","数值逼近"],"tags":["数值逼近","实验"]},{"title":"Project 2","url":"/2022/10/11/Project%202/","content":"练习一 (Runge现象)\r\n(1)为用 Lagrange 插值法计算出来的函数值. 代码:\r\n# lagrange 插值函数def lagrange(X,Y,xx):    bas = []    L = 0    for i in range(0,len(X)):        bas.append(basis(X[i],xx,len(X),i))        L=L+bas[i]*Y[i]    return Ldef basis(x_k,xx,len,k):    l = 1    for i in range(0,len):        if k != i:            l = l * ((xx-X[i])/(x_k-X[i]))    return lX = [2,2.75,4] #已知节点Y = [1/2,4/11,1/4] #对应函数值xx = 3 # 插值点L=lagrange(X,Y,xx)L_a = 1 / xxprint(L,L_a,abs(L-L_a)) 输出结果: 0.3295454545454546 0.3333333333333333 0.003787878787878729\r\n(2)等距节点的L插值函数. 代码: # Runge 现象from matplotlib import pyplot as pltimport numpydef lagrange(X,Y,xx):    bas = []    L = 0    for i in range(0,len(X)):        bas.append(basis(X[i],xx,len(X),i))        L=L+bas[i]*Y[i]    return Ldef basis(x_k,xx,len,k):    l = 1    for i in range(0,len):        if k != i:            l = l * ((xx-X[i])/(x_k-X[i]))    return ldef func(x):    y = 1/(1+pow(x,2))    return y n = 20h = 10/n X = []Y = []for i in range(0,n+1):    X.append(-5+i*h)            # 插值节点    Y.append(func(X[i]))        # 节点函数值# 作图x = numpy.arange(-5,5.1,0.1,float)y = []for i in range(0,len(x)):    y.append(lagrange(X,Y,x[i]))plt.plot(x, func(x))plt.plot(x,y)plt.show()\r\n输出结果:（经过很小地修改后把四幅图画在一起，为了缩短篇幅代码中没有体现）\r\n\r\n(3)Chebyshev插值节点的L插值多项式. 代码:\r\n# 用chebyshev节点的插值from cmath import cosfrom math import pifrom matplotlib import pyplot as pltimport numpydef lagrange(X,Y,xx):    bas = []    L = 0    for i in range(0,len(X)):        bas.append(basis(X[i],xx,len(X),i))        L=L+bas[i]*Y[i]    return Ldef basis(x_k,xx,len,k):    l = 1    for i in range(0,len):        if k != i:            l = l * ((xx-X[i])/(x_k-X[i]))    return ldef func(x):    y = 1/(1+pow(x,2))    return y def chebyshev_node(i,n):    z_i = cos((pi*(2*i+1))/(2*n+2))    return z_in = 16X = []Y = []for i in range(0,n+1):    X.append(5*chebyshev_node(i,n))            # 插值节点    Y.append(func(X[i]))        # 节点函数值# 作图x = numpy.arange(-5,5.1,0.1,float)y = []for i in range(0,len(x)):    y.append(lagrange(X,Y,x[i]))plt.plot(x, func(x))plt.plot(x,y)plt.show()\r\n输出结果:  (4)Newton插值多项式.\r\n代码: # Newton 插值法import numpy as npfrom matplotlib import pyplot as pltfrom copy import deepcopy#Runge函数def func(x):    y = 1/(1+pow(x,2))    return y # 差商表def divided_difference(X,Y,l):    N_k1 = deepcopy(Y)    N_k2 = deepcopy(Y)    N_k3 = deepcopy(Y)    for j in range(1,l):        for i in range(j,l):            N_k2[i] = (N_k1[i]-N_k1[i-1])/(X[i]-X[i-j]) # 跟着改动？？？？？        N_k3[j] = N_k2[j]        N_k1 = deepcopy(N_k2)    return N_k3# Newton插值多项式的Horner算法def N_interpolation_polynomial(x,X,N_k1,n):    sum = N_k1[n]*(x-X[n-1])    for i in range(n-1,0,-1):        sum =(x-X[i-1])*(sum + N_k[i])    sum = sum + N_k1[0]    return sumn = 20h = 10/nX = []Y = []for i in range(0,n+1):    X.append(-5+i*h)            # 插值节点    Y.append(func(X[i]))        # 节点函数值XX = np.arange(-5,5.01,0.01,float)YY = []L = len(X)N_k = divided_difference(X,Y,L) # 牛顿差商for i in XX:    y = N_interpolation_polynomial(i,X,N_k,n) # 插值多项式    #y = Newton(i,X,Y,L-1,N_k)    YY.append(y)# 插值图plt.plot(XX,YY)# 比较图plt.plot(XX, func(XX),&quot;r&quot;)plt.show()\r\n输出结果:  # 练习二 (分段插值)\r\n(1)分段线性插值 代码: # 分段线性插值from matplotlib import pyplot as pltimport numpy# Runge函数def func(x):    y = 1/(1+pow(x,2))    return y # 分段插值函数def piecewise_linear_interpolation_func(xx,X,Y,n):    sum = 0    for i in range(0,n+1):        sum = sum + basis_func(xx,X,i)*Y[i]    return sum# 基函数def basis_func(xx,X,i):    if i==0 and i == n:        return 0    elif xx&gt;=X[i-1] and xx&lt;=X[i]:        l = (xx-X[i-1])/(X[i]-X[i-1])        return l    elif xx&gt;=X[i] and xx&lt;=X[i+1]:        l = (xx-X[i+1])/(X[i]-X[i+1])        return l    else:        return 0n = 10                           #区间个数h = 10/n                        #区间长度X = []Y = []for i in range(0,n+1):    X.append(-5+i*h)            # 插值节点    Y.append(func(X[i]))        # 节点函数值# 分段插值图xx = numpy.arange(-5,5.1,0.1,float)yy =[]for x in xx:    y = piecewise_linear_interpolation_func(x,X,Y,n)    yy.append(y)plt.plot(xx,yy)# 比较图plt.plot(xx, func(xx))plt.show()\r\n输出结果:  (2)分段3次Hermit插值\r\n代码: # 分段3次Hermit插值from matplotlib import pyplot as pltimport numpy as npimport sympy as sp# Runge函数def func(x):    y = 1/(1+pow(x,2))    return y # 分段3次Hermit函数def tri_Hermit_interpolation_func(xx,X,Y,dY,n):    sum = 0    for i in range(0,n+1):        sum = sum + (h_func(xx,X,i)*Y[i]+h_bar_func(xx,X,i)*dY[i])    return sum# Hermit基函数def h_func(xx,X,i):    if i==0 and i == n:        return 0    elif xx&gt;=X[i-1] and xx&lt;=X[i]:        l = pow((xx-X[i-1])/(X[i]-X[i-1]),2)*(2*(xx-X[i])/(X[i-1]-X[i])+1)        return l    elif xx&gt;=X[i] and xx&lt;=X[i+1]:        l = pow((xx-X[i+1])/(X[i]-X[i+1]),2)*(2*(xx-X[i])/(X[i+1]-X[i])+1)        return l    else:        return 0def h_bar_func(xx,X,i):    if i==0 and i == n:        return 0    elif xx&gt;=X[i-1] and xx&lt;=X[i]:        l = pow((xx-X[i-1])/(X[i]-X[i-1]),2)*(xx-X[i])        return l    elif xx&gt;=X[i] and xx&lt;=X[i+1]:        l = pow((xx-X[i+1])/(X[i]-X[i+1]),2)*(xx-X[i])        return l    else:        return 0n = 8                           #区间个数h = 10/n                        #区间长度X = []Y = []dY = []# 求导a= sp.symbols(&#x27;a&#x27;)b = 1/(1+a**2)db = sp.diff(b,a)for i in range(0,n+1):    X.append(-5+i*h)            # 插值节点    Y.append(func(X[i]))        # 节点函数值    dY.append(db.evalf(subs=&#123;a:-5+i*h&#125;)) # 节点导数值# 分段插值图xx = np.arange(-5,5.1,0.1,float)yy =[]for x in xx:    y = tri_Hermit_interpolation_func(x,X,Y,dY,n)    yy.append(y)plt.plot(xx,yy)# 比较图plt.plot(xx, func(xx),&quot;r&quot;)plt.show() 输出结果:  (3)三次固支样条插值\r\n代码: # 三次（固支）样条插值(三弯矩构造)from matplotlib import pyplot as pltimport numpy as npimport sympy as spfrom copy import deepcopydef func(x):    y = 1/(1+pow(x,2))    return y # 差商表def divided_difference(X,Y,l,k):    N_k1 = deepcopy(Y)    N_k2 = deepcopy(Y)    N_k3 = []    for j in range(1,k+1):        for i in range(j,l):            N_k2[i] = (N_k1[i]-N_k1[i-1])/(X[i]-X[i-j])        N_k1 = deepcopy(N_k2)    for j in range(k,l):        N_k3.append(N_k1[j])    return N_k3# 三弯矩计算Mdef M(X,Y,H,L,n):    M = []    D2 = []    D3 = []    D = []    # 求导    a= sp.symbols(&#x27;a&#x27;)    b = 1/(1+a**2)    db = sp.diff(b,a)    # 系数矩阵    mu = []    lmda = []    A = np.zeros((L,L))    mu.append(0)                #补0    lmda.append(0)              #补0    for i in range(0,n):        if i == n-1:            #周期样条改这里            mu.append(0)            lmda.append(0)            break        mu.append(H[i]/(H[i]+H[i+1]))        lmda.append(H[i+1]/(H[i]+H[i+1]))    for i in range(L):        if i == 0 :            A[i][i+1] = 1            A[i][i] = 2        elif i == L-1 :            A[i][i-1] = 1            A[i][i] = 2        else :            A[i][i] = 2            A[i][i-1] = mu[i]            A[i][i+1] = lmda[i]    A = np.matrix(A)    # 边界条件    D2 = divided_difference(X,Y,L,1) # 固支边界条件需要的2阶差商    D3 = divided_difference(X,Y,L,2) # 方程组右边向量    for i in range(0,n+1) :        if i == 0:            D.append(6/H[0]*(D2[0]-db.evalf(subs=&#123;a:-5&#125;)))        elif i&lt;n and i&gt;0 :            D.append(6*D3[i-1])        else :            D.append(6/H[n-1]*(db.evalf(subs=&#123;a:5&#125;)-D2[-1]))    D = np.array(D)    M = A.I.dot(D)    return M# 样条插值函数def spline_func(xx,X,Y,H,M,n):    k = 0    for i in range(0,n):        if xx &lt;X[i+1] and xx &gt;=X[i]:            k = i            break    i = k    #yy = pow((X[i+1]-xx),3)*M[0][i]/(6*H[i])+pow((xx-X[i]),3)*M[0][i+1]/(6*H[i])+(Y[i]-M[i]*H[i]*H[i]/6)*(X[i+1]-xx)/H[i]+(Y[i+1]-M[i+1]*H[i]*H[i]/6)*(xx-X[i])/H[i]    yy = pow((X[i+1]-xx),3)*M[0,i]/(6*H[i])+pow((xx-X[i]),3)*M[0,i+1]/(6*H[i])+(Y[i]-M[0,i]*H[i]*H[i]/6)*(X[i+1]-xx)/H[i]+(Y[i+1]-M[0,i+1]*H[i]*H[i]/6)*(xx-X[i])/H[i]    return yyn = 10h = 10/n X = []Y = []H = []for i in range(0,n+1):    X.append(-5+i*h)            # 插值节点    Y.append(func(X[i]))        # 节点函数值for i in range(0,n):    H.append(X[i+1]-X[i])       # 区间长度L = len(X)# 样条插值函数x = np.arange(-5,5.1,0.1,float)YY = []M = M(X,Y,H,L,n)for xx in x:    yy = spline_func(xx,X,Y,H,M,n)    YY.append(yy)plt.plot(x, YY)# 比较图plt.plot(x, func(x))plt.show() 输出结果: \r\n练习三 (物体运动轨迹)\r\n(1)分段线性插值 代码: # 物体的轨迹# 分段线性插值T = [0,1,2,3,4]X = [0,1,4,3,0]Y = [0,2,4,1,0]n = len(T)-1from matplotlib import pyplot as pltimport numpy# 分段插值函数def piecewise_linear_interpolation_func(xx,X,Y,n):    sum = 0    for i in range(0,n+1):        sum = sum + basis_func(xx,X,i)*Y[i]    return sum# 基函数def basis_func(xx,X,i):    if i==0 and i == n:        return 0    elif xx&gt;=X[i-1] and xx&lt;=X[i]:        l = (xx-X[i-1])/(X[i]-X[i-1])        return l    elif xx&gt;=X[i] and xx&lt;=X[i+1]:        l = (xx-X[i+1])/(X[i]-X[i+1])        return l    else:        return 0# 分段插值图tt = numpy.arange(0,4.1,0.1,float)xx = []yy = []for t in tt:    x = piecewise_linear_interpolation_func(t,T,X,n)    xx.append(x)    y = piecewise_linear_interpolation_func(t,T,Y,n)    yy.append(y)print(xx,yy)plt.plot(xx,yy)plt.show()\r\n输出结果: \r\n(2)三次周期样条插值 代码： # 物体的轨迹# 三次 (周期) 样条插值方法T = [0,1,2,3,4]X = [0,1,4,3,0]H = [1,1,1,1]Y = [0,2,4,1,0]n = len(T)-1from matplotlib import pyplot as pltimport numpy as npimport sympy as spfrom copy import deepcopy# 差商表def divided_difference(X,Y,l,k):    N_k1 = deepcopy(Y)    N_k2 = deepcopy(Y)    N_k3 = []    for j in range(1,k+1):        for i in range(j,l):            N_k2[i] = (N_k1[i]-N_k1[i-1])/(X[i]-X[i-j])        N_k1 = deepcopy(N_k2)    for j in range(k,l):        N_k3.append(N_k1[j])    return N_k3# 三弯矩计算Mdef M(X,Y,H,L,n):    M = []    D2 = []    D3 = []    D = []    # 系数矩阵    D2 = divided_difference(X,Y,L,1) # 固支边界条件需要的1阶差商    D3 = divided_difference(X,Y,L,2) # 方程组右边向量    mu = []    lmda = []    A = np.zeros((L-1,L-1))    mu.append(0)                #补0    lmda.append(0)              #补0    for i in range(0,n):        if i == n-1:            #周期样条改这里            mu.append(1/2)            lmda.append(1/2)            break        mu.append(H[i]/(H[i]+H[i+1]))        lmda.append(H[i+1]/(H[i]+H[i+1]))    for i in range(0,n):        if i == 0 :            A[i][i+1] = lmda[1]            A[i][i] = 2            A[i][-1] = mu[1]        elif i == n-1 :            A[i][-2] = mu[i+1]            A[i][-1] = 2            A[i][0] = lmda[i+1]        else :            A[i][i] = 2            A[i][i-1] = mu[i+1]            A[i][i+1] = lmda[i+1]    A = np.matrix(A)    # 边界条件    for i in range(0,len(D3)) :        D.append(6*D3[i])    D.append(3*(D2[0]-D2[-1]))    print(D)    D = np.array(D)    M = A.I.dot(D)    return M# 样条插值函数def spline_func(xx,X,Y,H,M,n):    k = 0    for i in range(0,n):        if xx &lt;=X[i+1] and xx &gt;=X[i]:            k = i            break    i = k    if i == 0:        yy = pow((X[i+1]-xx),3)*M[0,-1]/(6*H[i])+pow((xx-X[i]),3)*M[0,0]/(6*H[i])+(Y[i]-M[0,-1]*H[i]*H[i]/6)*(X[i+1]-xx)/H[i]+(Y[i+1]-M[0,0]*H[i]*H[i]/6)*(xx-X[i])/H[i]    else:        yy = pow((X[i+1]-xx),3)*M[0,i-1]/(6*H[i])+pow((xx-X[i]),3)*M[0,i]/(6*H[i])+(Y[i]-M[0,i-1]*H[i]*H[i]/6)*(X[i+1]-xx)/H[i]+(Y[i+1]-M[0,i]*H[i]*H[i]/6)*(xx-X[i])/H[i]    return yy# 作插值图tt = np.arange(0,4.01,0.01,float)xx = []yy = []M1 = M(T,X,H,n+1,n)M2 = M(T,Y,H,n+1,n)print(M1)# M1 = [[3,-6,-3,6]]# M2 = [[1.5,-9,4.5,3]]for t in tt:    x = spline_func(t,T,X,H,M1,n)    xx.append(x)    y = spline_func(t,T,Y,H,M2,n)    yy.append(y)plt.plot(xx,yy)plt.show()\r\n输出结果： \r\n","categories":["Math","数值逼近"],"tags":["数值逼近","实验"]},{"title":"Project 5","url":"/2022/11/15/Project%205/","content":"练习一：Simpson 求积公式\r\n实验发现，Simpson 方法求积小数点后只有一位有效数字，而采用复合Simpson\r\n方法小数点后有五位有效数字。\r\n代码： # Simpson 求积公式from cmath import piimport scipy as scimport numpy as npdef f(x):    M = 200    sig = 0.1    xbar = 1.7    return M/(sig*(2*pi)**(1/2))*np.exp(-(x-xbar)**2/(2*sig**2))def simpson(a,b):    I = (b-a)/6*(f(a)+f(b)+4*f((a+b)/2))    return Ia = 1.8b = 1.9I1 = sc.integrate.quad(f,a,b)print(I1)I2 = simpson(a,b)print(I2)I3 = 0n = 10h = (b-a)/nfor i in range(n):    a1 = a + i*h    b1 = a + (i+1)*h    I3 = I3 + simpson(a1,b1)print(I3) 输出结果：\r\n(27.181024396655484, 3.0176999118065023e-13) # 精确值27.134402456529873\t# Simpson 求积公式27.18102028106211 # 复合Simpson 求积 \r\n练习二：Romberg 求积方法)\r\n实验发现，取公差为0.000001，代码计算得到的近似值与“精确值”的小数点后七位都是相同的。\r\n代码： # Romberg 求积方法from cmath import piimport scipy as scimport numpy as npdef trapezoidal(a,b):  # 梯形求积    I = (b-a)/2*(f(a)+f(b))    return Idef romberg(f,a,b,eps):    e = 1    m = 2  # 初始阶    while e &gt; eps:        h = b-a        T = np.zeros((m,m))        for k in range(m):            n = np.power(2,k)            h1 = h/n            I = 0            for s in range(n): #复合求积公式                a1 = a + s*h1                b1 = a + (s+1)*h1                I = I + trapezoidal(a1,b1)            T[k,0] = I            for j in range(1,k+1):                T[k,j]=1/(np.power(4,j)-1)*(np.power(4,j)*T[k,j-1]-T[k-1,j-1])                #print(T) #测试        e = abs(T[-1,-1]-T[-1,-2]) # 公差        m += 1        #print(T) #测试    return T[-1,-1]f = lambda x: np.log(x)a,b = 1,2eps = 0.000001I1 = sc.integrate.quad(f,a,b)print(I1[0])I2 = romberg(f,a,b,eps)print(I2) 输出结果：\r\n0.38629436111989063 #精确值0.38629430908624807 #Romberg 算法\r\n练习三：复合积分方法和\r\nGauss 积分方法的比较\r\n复合方法求积\r\n代码： # 复合积分方法和 Gauss 积分方法的比较# 复合积积分方法from cmath import piimport scipy as scimport numpy as npdef f(x):    return np.sqrt(1+np.exp(x))def f1(x):    return 2*np.sqrt(1+np.exp(2*x+2))def simpson(a,b):    I = (b-a)/6*(f(a)+f(b)+4*f((a+b)/2))    return Idef trapezoidal(a,b):  # 梯形求积    I = (b-a)/2*(f(a)+f(b))    return Ia = 0b = 4I1 = sc.integrate.quad(f,a,b)print(&quot;numpy计算结果:&quot;,I1)I3 = 0I4 = 0#n = 10N = [2,4,8,16]for n in N:    h = (b-a)/n    I3,I4=0,0    for i in range(n):        a1 = a + i*h        b1 = a + (i+1)*h        I3 = I3 + trapezoidal(a1,b1)        I4 = I4 + simpson(a1,b1)    print(&quot;复合梯形求积结果:&quot;,I3,&quot;\\n与精确解偏差:&quot;,I3-I1[0]) #误差以4倍速度下降 收敛阶为2    print(&quot;复合Simpson求积结果&quot;,I4,&quot;\\n与精确解偏差:&quot;,I4-I1[0])#误差收敛阶为4    print(&quot;\\n&quot;) 输出结果：\r\nnumpy计算结果: (13.577302400789666, 1.5073833737655101e-13)复合梯形求积结果: 14.663403727504809 与精确解偏差: 1.0861013267151431复合Simpson求积结果 13.581379562032346与精确解偏差: 0.004077161242680205复合梯形求积结果: 13.851885603400463与精确解偏差: 0.2745832026107973复合Simpson求积结果 13.57756442812153与精确解偏差: 0.0002620273318640898复合梯形求积结果: 13.646144721941265与精确解偏差: 0.0688423211515996复合Simpson求积结果 13.577318889241141与精确解偏差: 1.6488451475282773e-05复合梯形求积结果: 13.594525347416171与精确解偏差: 0.017222946626505475复合Simpson求积结果 13.577303433056535与精确解偏差: 1.032266869316345e-06使用Gauss节点结果(N= 3 ): 13.576984579216827与精确解偏差: -0.00031782157283899437使用Gauss节点结果(N= 5 ): 13.57730258966976与精确解偏差: 1.888800937877022e-07使用Gauss节点结果(N= 7 ): 13.577302399995329与精确解偏差: -7.943370405882888e-10PS C:\\Users\\bc\\OneDrive\\桌面\\数值分析&gt; &amp; C:/Users/bc/AppData/Local/Programs/Python/Python310/python.exe c:/Users/bc/OneDrive/桌面/数值分析/数 值逼近/11.09.01.pynumpy计算结果: (13.577302400789666, 1.5073833737655101e-13)复合梯形求积结果: 14.663403727504809 与精确解偏差: 1.0861013267151431复合Simpson求积结果 13.581379562032346与精确解偏差: 0.004077161242680205复合梯形求积结果: 13.851885603400463与精确解偏差: 0.2745832026107973复合Simpson求积结果 13.57756442812153与精确解偏差: 0.0002620273318640898复合梯形求积结果: 13.646144721941265与精确解偏差: 0.0688423211515996复合Simpson求积结果 13.577318889241141与精确解偏差: 1.6488451475282773e-05复合梯形求积结果: 13.594525347416171与精确解偏差: 0.017222946626505475复合Simpson求积结果 13.577303433056535与精确解偏差: 1.032266869316345e-06 ## Gauss 积分公式求积 代码：\r\n# 复合积分方法和 Gauss 积分方法的比较# 复合积积分方法from cmath import piimport scipy as scimport numpy as npdef f(x):    return np.sqrt(1+np.exp(x))def f1(x):    return 2*np.sqrt(1+np.exp(2*x+2))a = 0b = 4I1 = sc.integrate.quad(f,a,b)I3 = 0I4 = 0# Gauss 积分公式N3=np.array([[0.8888888888888888,0.0000000000000000],[0.5555555555555556,-0.7745966692414834],[0.5555555555555556,0.7745966692414834]])N5=np.array([[0.5688888888888889, 0.0000000000000000],[0.4786286704993665, -0.5384693101056831],[0.4786286704993665, 0.5384693101056831],[0.2369268850561891, -0.9061798459386640],[0.2369268850561891, 0.9061798459386640]])N7=np.array([[0.4179591836734694, 0.0000000000000000],[0.3818300505051189, -0.4058451513773972],[0.3818300505051189, 0.4058451513773972],[0.2797053914892766, -0.7415311855993945],[0.2797053914892766, 0.7415311855993945],[0.1294849661688697, -0.9491079123427585],[0.1294849661688697, 0.9491079123427585]])for N in [N3,N5,N7]:    I5 = 0    for i in N:        I5 += 1*i[0]*f1(i[1])    print(&quot;使用Gauss节点结果(N=&quot;,len(N),&quot;):&quot;,I5)    print(&quot;与精确解偏差:&quot;,I5-I1[0]) 输出结果： 使用Gauss节点结果(N= 3 ): 13.576984579216827与精确解偏差: -0.00031782157283899437使用Gauss节点结果(N= 5 ): 13.57730258966976与精确解偏差: 1.888800937877022e-07使用Gauss节点结果(N= 7 ): 13.577302399995329与精确解偏差: -7.943370405882888e-10\r\n","categories":["Math","数值逼近"],"tags":["数值逼近","实验"]},{"title":"Project 4","url":"/2022/11/02/Project%204/","content":"练习 一 (最佳平方逼近多项式)\r\n可能是由于不同软件的计算精度存在差异，上机实验中，在k分别取1，3，5，10时，并没有发现最大误差逐渐变大。但是，当我们进一步增大k至25以后，可以发现明显的计算异常，显然是由于计算机的舍入误差不断累积造成的异常结果。\r\n## 第一个函数 # 最佳平方逼近多项式 $f1import numpy as npimport sympy as spfrom matplotlib import pyplot as pltdef gauss(a,b,k):    A = np.zeros((k+1,k+1))    x = sp.symbols(&quot;x&quot;)    for i in range(k+1):        for j in range(k+1):            A[i,j]=sp.integrate(x**(i+j),(x,a,b))    return Adef d(a,b,k):    B = np.zeros((k+1,1))    x = sp.symbols(&quot;x&quot;)    for i in range(k+1):        B[i,0]=sp.integrate(sp.E**x*x**i,(x,a,b))        #print(sp.E**x*x**i)    return Bdef draw_fit(C,a,b,n,k):    #plt.figure(k+1)    # 拟合曲线    X = np.arange(a,b,1/n)    Y = []    plt.subplot(1,2,1)    for x in X:        sum = 0        for i in range(k+1):            sum = sum + C[i]*pow(x,i)        #print(type(sum.tolist()))        Y.append(sum.tolist()[0][0])    plt.plot(X,Y)    # 散点图    for x in np.arange(a,b,1/n):        y = np.exp(x)        plt.plot(x,y,&quot;r+&quot;)    plt.subplot(1,2,2)    # 误差图    i=0    max = 0    for x in np.arange(a,b,1/n):        y = np.exp(x)        #print(y,Y[i],y-Y[i])        bias = abs(y-Y[i])        plt.plot(x,bias,&quot;b+&quot;)        i += 1        if max &lt; bias:            max = bias    return maxa = -1b = 1  # 区间[-1,1]n = 50s = 25  # 图的个数 MAX = []# 作图for k in range(s):    G = gauss(a,b,k) # 法矩阵    D = d(a,b,k)    # 法方程右边    G = np.matrix(G)    C = G.I.dot(D) # 法方程的解    MAX.append(draw_fit(C,a,b,n,k))S = np.arange(1,s+1,1)plt.figure(s+1)plt.scatter(S,MAX)# 最小二乘z = np.polyfit(S,MAX,5)p = np.poly1d(z)xx = np.arange(0,s,0.1)yy = p(xx)plt.plot(xx,yy)plt.show() ### s=10 （k从0取到10）  ### s=25 （k从0取到25）\r\n\r\n（注1：右图的曲线是最小二乘拟合的，散点为不同阶的最大误差）\r\n（注2：继续增大代码的s，如s=30时，结果已经完全不可信，最大误差已经是几百几千了）\r\n第二个函数\r\n# 最佳平方逼近多项式  # f2import numpy as npimport sympy as spfrom matplotlib import pyplot as pltdef gauss(a,b,k):    A = np.zeros((k+1,k+1))    x = sp.symbols(&quot;x&quot;)    for i in range(k+1):        for j in range(k+1):            A[i,j]=sp.integrate(x**(i+j),(x,a,b))    return Adef d(a,b,k):    B = np.zeros((k+1,1))    x = sp.symbols(&quot;x&quot;)    for i in range(k+1):        B[i,0]=sp.integrate(abs(x)*x**i,(x,a,b))        #print(sp.E**x*x**i)    return Bdef draw_fit(C,a,b,n,k):    #plt.figure(k+1)    # 拟合曲线    X = np.arange(a,b,1/n)    Y = []    plt.subplot(1,2,1)    for x in X:        sum = 0        for i in range(k+1):            sum = sum + C[i]*pow(x,i)        #print(type(sum.tolist()))        Y.append(sum.tolist()[0][0])    plt.plot(X,Y)    # 散点图    for x in np.arange(a,b,1/n):        y = np.abs(x)        plt.plot(x,y,&quot;r+&quot;)    plt.subplot(1,2,2)    # 误差图    i=0    max = 0    for x in np.arange(a,b,1/n):        y = np.abs(x)        #print(y,Y[i],y-Y[i])        bias = abs(y-Y[i])        plt.plot(x,bias,&quot;b+&quot;)        i += 1        if max &lt; bias:            max = bias    return maxa = -1b = 1  # 区间[-1,1]n = 50s = 25  # 图的个数 MAX = []# 作图for k in range(s):    G = gauss(a,b,k) # 法矩阵    D = d(a,b,k)    # 法方程右边    G = np.matrix(G)    C = G.I.dot(D) # 法方程的解    MAX.append(draw_fit(C,a,b,n,k))S = np.arange(1,s+1,1)plt.figure(s+1)plt.scatter(S,MAX)# 最小二乘z = np.polyfit(S,MAX,5)p = np.poly1d(z)xx = np.arange(0,s,0.1)yy = p(xx)plt.plot(xx,yy)plt.show()\r\ns=10 （k从0取到10）\r\n ### s=25 （k从0取到25）\r\n\r\n（注：s大于25后，也出现了最大误差上升） # 练习 二 (正交多项式的应用)\r\n通过实验，我发现不管使用哪种方法计算，所得的结果都是一样的，代码中已经修改过不同计算方式所得曲线的颜色，报告中由于是黑白无法体现出来。观察误差图，可以发现三种方式得到的误差图是一模一样的。\r\n不过，虽然计算结果都是一样的，但是计算的效率却不相同，直观感受上，使用Chebyshev正交多项式的计算时长明显大于另外两个，而第一个的计算速度是最快的。分析可能存在两个影响因素：1.可能是由于计算机对多项式的处理速度比较快；2.从我的代码中可以发现，大量使用了计算库（numpy，sympy，scipy）的函数。事实上，如果通过递推公式，或者已知的两种正交多项式的正交性去计算，可以大量节省计算成本。（为了代码的复用性，我一开始并没打算这样做，但完成后发现了计算速度比较缓慢，故给出反思分析）\r\n可以发现三者的代码是非常相似的。 ## 基函数 # 正交多项式的应用# 朴实无华基函数import numpy as npimport sympy as spfrom matplotlib import pyplot as pltdef gauss(a,b,k):    A = np.zeros((k+1,k+1))    x = sp.symbols(&quot;x&quot;)    for i in range(k+1):        for j in range(k+1):            A[i,j]=sp.integrate(x**(i+j),(x,a,b))    return Adef d(a,b,k):    print(k)    B = np.zeros((k+1,1))    x = sp.symbols(&quot;x&quot;)    for i in range(k+1):        B[i,0]=sp.integrate(4/(4+25*(x+1)**2)*x**i,(x,a,b))    return Bdef draw_fit(C,a,b,n,k):    plt.figure(k+1)    # 拟合曲线    X = np.arange(a,b,1/n)    Y = []    plt.subplot(1,2,1)    for x in X:        sum = 0        for i in range(k+1):            sum = sum + C[i]*pow(x,i)        #print(type(sum.tolist()))        Y.append(sum.tolist()[0][0])    plt.plot(X,Y)    # 散点图    for x in np.arange(a,b,1/n):        y = 4/(4+25*pow((x+1),2))        plt.plot(x,y,&quot;r+&quot;)    plt.subplot(1,2,2)    # 误差图    i=0    max = 0    for x in np.arange(a,b,1/n):        y = 4/(4+25*pow((x+1),2))        #print(y,Y[i],y-Y[i])        bias = abs(y-Y[i])        plt.plot(x,bias,&quot;b+&quot;)        i += 1        if max &lt; bias:            max = bias    return maxa = -1b = 1  # 区间[-1,1]n = 50s = 2  # 图的个数 MAX = []# 作图for k in [5,10]:    G = gauss(a,b,k) # 法矩阵    D = d(a,b,k)    # 法方程右边    G = np.matrix(G)    C = G.I.dot(D) # 法方程的解    print(C)    MAX.append(draw_fit(C,a,b,n,k))S = np.arange(1,s+1,1)plt.figure(s+1)plt.scatter(S,MAX)plt.show() ##\r\nLegendre正交多项式 # Legendre 正交多项式import sympy as spimport scipy as scimport numpy as npfrom math import factorialfrom matplotlib import pyplot as pltnp.set_printoptions(suppress=True)def gauss(a,b,k):    A = np.zeros((k+1,k+1))    x = sp.symbols(&quot;x&quot;)    f = 4/(4+25*(x+1)**2)    for i in range(k+1):        for j in range(k+1):            phi = (1/(2**i*factorial(i)))*sp.diff((x**2-1)**i,x,i)            phj = (1/(2**j*factorial(j)))*sp.diff((x**2-1)**j,x,j)            rho = 1            l = sp.integrate(rho*phi*phj,(x,a,b))            A[i,j]=l        #print(sp.expand(phi))  #测试正交多项式    #print(sp.Rational(sp.expand(phi).coeff(x**4))) #测试系数    #print(A) #测试法矩阵    return Adef d(a,b,k):    print(k)    B = np.zeros((k+1,1))    x = sp.symbols(&quot;x&quot;)    f = 4/(4+25*(x+1)**2)    rho = 1    for i in range(k+1):        phi = (1/(2**i*factorial(i)))*sp.diff((x**2-1)**i,x,i)        g = f*phi*rho        g = sp.lambdify([x], g)       #匿名函数化        l=sc.integrate.quad(g,a,b)[0] #为避免报错采用数值积分        B[i,0]=l    return Bdef draw_fit(C,a,b,n,k):    plt.figure(k+1)    # 拟合曲线    X = np.arange(a,b,1/n)    Y = []    plt.subplot(1,2,1)    x = sp.symbols(&quot;x&quot;)    for t in X:        sum = 0        for i in range(k+1):            phi = (1/(2**i*factorial(i)))*sp.diff((x**2-1)**i,x,i)            sum = sum + C[i]*phi.evalf(subs =&#123;&#x27;x&#x27;:t&#125;)        #print(type(sum.tolist()))        Y.append(sum.tolist()[0][0])    plt.plot(X,Y)    # 散点图    for x in np.arange(a,b,1/n):        y = 4/(4+25*pow((x+1),2))        plt.plot(x,y,&quot;r+&quot;)    plt.subplot(1,2,2)    # 误差图    i=0    max = 0    for x in np.arange(a,b,1/n):        y = 4/(4+25*pow((x+1),2))        #print(y,Y[i],y-Y[i])        bias = abs(y-Y[i])        plt.plot(x,bias,&quot;b+&quot;)        i += 1        if max &lt; bias:            max = bias    return maxa = -1b = 1  # 区间[-1,1]n = 50s = 2  # 图的个数 MAX = []# 作图for k in [5,10]:    G = gauss(a,b,k) # 法矩阵    D = d(a,b,k)    # 法方程右边    print(D)    G = np.matrix(G)    C = G.I.dot(D) # 法方程的解    print(C)    MAX.append(draw_fit(C,a,b,n,k))S = np.arange(1,s+1,1)plt.figure(s+1)plt.scatter(S,MAX)plt.show() ## Chebyshev正交多项式 # Chebyshev 正交多项式import sympy as spimport scipy as scimport numpy as npfrom math import factorialfrom matplotlib import pyplot as pltnp.set_printoptions(suppress=True)def gauss(a,b,k):    A = np.zeros((k+1,k+1))    x = sp.symbols(&quot;x&quot;)    f = 4/(4+25*(x+1)**2)    for i in range(k+1):        for j in range(k+1):            phi = sp.cos(i*sp.acos(x))            phj = sp.cos(j*sp.acos(x))            rho = 1            l = sp.integrate(rho*phi*phj,(x,a,b))            A[i,j]=l        #print(sp.expand(phi))  #测试正交多项式    #print(sp.Rational(sp.expand(phi).coeff(x**4))) #测试系数    #print(A) #测试法矩阵    return Adef d(a,b,k):    print(k)    B = np.zeros((k+1,1))    x = sp.symbols(&quot;x&quot;)    f = 4/(4+25*(x+1)**2)    rho = 1    for i in range(k+1):        phi = sp.cos(i*sp.acos(x))        g = f*phi*rho        g = sp.lambdify([x], g)       # 匿名函数化        l=sc.integrate.quad(g,a,b)[0] # 为避免报错采用数值积分        B[i,0]=l    return Bdef draw_fit(C,a,b,n,k):    plt.figure(k+1)    # 拟合曲线    X = np.arange(a,b,1/n)    Y = []    plt.subplot(1,2,1)    x = sp.symbols(&quot;x&quot;)    for t in X:        sum = 0        for i in range(k+1):            phi = sp.cos(i*sp.acos(x))            sum = sum + C[i]*phi.evalf(subs =&#123;&#x27;x&#x27;:t&#125;)        #print(type(sum.tolist()))        Y.append(sum.tolist()[0][0])    plt.plot(X,Y,&quot;g&quot;)    # 散点图    for x in np.arange(a,b,1/n):        y = 4/(4+25*pow((x+1),2))        plt.plot(x,y,&quot;r+&quot;)    plt.subplot(1,2,2)    # 误差图    i=0    max = 0    for x in np.arange(a,b,1/n):        y = 4/(4+25*pow((x+1),2))        #print(y,Y[i],y-Y[i])        bias = abs(y-Y[i])        plt.plot(x,bias,&quot;b+&quot;)        i += 1        if max &lt; bias:            max = bias    return maxa = -1b = 1  # 区间[-1,1]n = 50s = 2  # 图的个数 MAX = []# 作图for k in [5,10]:    G = gauss(a,b,k) # 法矩阵    D = d(a,b,k)    # 法方程右边    print(D)    G = np.matrix(G)    C = G.I.dot(D) # 法方程的解    print(C)    MAX.append(draw_fit(C,a,b,n,k))S = np.arange(1,s+1,1)plt.figure(s+1)plt.scatter(S,MAX)plt.show() ##\r\n代码结果： 由于图像完全一致，故只粘贴一张。\r\n注意：根据练习一的分析，在k取更大值时，第一种方法会失真，而用正交多项式则不会，但本题所取的k不够大，为避免篇幅过长（k=30），故只粘贴一张。\r\n 左图为k=5，右图为k=10.\r\nk=5的最佳逼近多项式系数 [[ 0.12885774] [-0.19746297] [ 0.44698082]\r\n[-0.61910836] [-0.01585597] [ 0.3170046 ]] k=10的最佳逼近多项式系数 [[\r\n0.13771554] [-0.24145138] [ 0.30710191] [-0.22830788] [ 0.07656059]\r\n[-0.52033777] [ 0.83695426] [ 0.47672007] [-1.18338108] [ 0.03469561] [\r\n0.34327799]]\r\n另外，可以发现选择正交多项式求解时，k的增加不会改变法方程解前面的项，只需要在后面增加一项即可，如果在代码中实现，也将大幅减少计算量。最关键的是使用正交多项式求解可以避免，病态线性方程组的求解。\r\n# 练习 三(多项式最小二乘法) ## 分析\r\n效果上看第三种拟合最符合实际，因为汽车的初速度为0时，刹车距离自然为0. ##\r\n代码 # 多项式的最小二乘法import numpy as npfrom matplotlib import pyplot as plt# 数据及散点图X = [5,10,15,20,25,30,35,40]Y = [3.42,5.96,31.14,41.76,74.54,94.32,133.78,169.16]plt.scatter(X,Y,marker=&#x27;+&#x27;,c=&#x27;r&#x27;)def match(n,X,Y):    l = len(X)    A = np.zeros((n+1,n+1))    B = np.zeros(n+1)    for i in range(n+1):  # 法矩阵        for j in range(n+1):            sum = 0            for k in range(l):                sum = sum + pow(X[k],i+j)                A[i,j]=sum    for i in range(n+1):  # 法方程右边        for j in range(n+1):            sum = 0            for k in range(l):                sum = sum + pow(X[k],i)*Y[k]                B[i]=sum    A = np.matrix(A)    C = A.I.dot(B) # 系数向量    C = np.array(C)    return C# 一次拟合C = match(1,X,Y)xx = np.arange(0,45,0.1)yy =  C[0,1] * xx + C[0,0]plt.plot(xx,yy,label=&#x27;n=1&#x27;)# 二次拟合C = match(2,X,Y)yy = C[0,2] * np.power(xx,2) + C[0,1] * xx + C[0,0]plt.plot(xx,yy,label=&#x27;n=2&#x27;)# 无常数项拟合C = match(2,X,Y)yy = C[0,2] * np.power(xx,2) + C[0,1] * xxplt.plot(xx,yy,label=&#x27;n=2&amp;a_0=0&#x27;)plt.legend()plt.show()\r\n运行结果\r\n\r\n\r\naa5d193dfcbb7ec44df69e848e47991e.png\r\n\r\n练习 四 (指数函数最小二乘法)\r\n代码\r\n# 指数函数的最小二乘法import numpy as npfrom matplotlib import pyplot as plt# 数据及散点图X = np.arange(0,7+1,1)N = np.random.randint(1,len(X),size=len(X))*0.1print(N)Y = np.exp(X)+np.exp(-X)+0.1*Nplt.scatter(X,Y,marker=&#x27;+&#x27;,c=&#x27;r&#x27;)# 线性拟合def match(n,X,Y):    l = len(X)    A = np.zeros((n+1,n+1))    B = np.zeros(n+1)    for i in range(n+1):  # 法矩阵        for j in range(n+1):            sum = 0            for k in range(l):                sum = sum + pow(X[k],i+j)                A[i,j]=sum    for i in range(n+1):  # 法方程右边        for j in range(n+1):            sum = 0            for k in range(l):                sum = sum + pow(X[k],i)*Y[k]                B[i]=sum    A = np.matrix(A)    C = A.I.dot(B) # 系数向量    C = np.array(C)    return C#数据处理Y = np.log(Y)C = match(1,X,Y)xx = np.arange(0,7.3,0.1)yy = np.exp(C[0,1] * xx +C[0,0])plt.plot(xx,yy)plt.show()\r\n运行结果\r\n ## 结果分析\r\n从图像上不容易看出，但在k=7时的绝对误差已经是几十的数量级了，但是相对误差还是比较小的。\r\n","categories":["Math","数值逼近"],"tags":["数值逼近","实验"]},{"title":"向量及矩阵范数","url":"/2022/11/02/%E5%90%91%E9%87%8F%E5%8F%8A%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/","content":"向量范数\r\n定义： 设\\(X\\in\r\n\\R^n\\),若有非负实数\\(||X||\\)满足: - \\(||X||\\geq 0\\),且\\(||X||=0\\Leftrightarrow X=0\\)(非负性,强制性)\r\n- \\(||\\lambda\r\nX||=|\\lambda|\\cdot||X||\\)(正齐次性) - \\(||X+Y||\\leq||X||+||Y||\\)(三角不等式)\r\n则称\\(||X||\\)为向量\\(X\\)的范数.\r\n常用的几种范数 若\\(X=(x_1,x_2,\\cdots,x_n)^T\\) - \\[||X||_1=\\sum_{i=1}^{n}|x_i|\\] - \\[||X||_{\\infty}=\\max_{1\\leq i\\leq n}|x_i|\\]\r\n- \\[||X||_2=\\sqrt{\\sum_{i=1}^{n}|x_i|^2},\\quad\r\n||X||^2_2=X^TX\\]\r\n定理:(范数的连续性定理) 向量范数\\(||X||\\)为关于\\(X\\)每个分量的一致连续函数.\r\n证明: 只需证明\\(\\forall\r\n\\epsilon&gt;0, \\exist\\delta=\\delta(\\epsilon)\\),当\\(\\Delta x_i\\)满足\\(|\\Delta x_i|&lt;\\delta\\)时,有\\(|\\,||X+\\Delta X||-||X||\\,|&lt;\\epsilon\\)\r\n事实上,由逆三角不等式有, \\[|\\,||X+\\Delta\r\nX||-||X||\\,|&lt;||X+\\Delta X-X||&lt;||\\Delta X||\\] 另一方面,\r\n\\[||\\Delta X||=||(\\Delta x_1,\\Delta\r\nx_2,\\cdots,\\Delta x_n)^T||=||\\Delta x_1e_1+\\Delta x_2e_2+\\cdots+\\Delta\r\nx_ne_n||\\] \\[\\leq||\\Delta\r\nx_1e_1||+||\\Delta x_2e_2||+\\cdots+||\\Delta x_ne_n|| &lt;n\\delta\\]\r\n其中, \\[e_2=(0,1,\\cdots,0)\\]\r\n以此类推\r\n定理:(范数等价性定理) \\(\\R^n\\)中任何范数都等价,即若有范数\\(R_1(x)\\)和\\(R_2(x)\\),则 \\[\\exist m,M&gt;0,s.t. \\quad m\\leq\r\n\\frac{R_1(x)}{R_2(x)}\\leq M\\]\r\n证明: 记\\(S=\\{X|R_2(X)=1\\}\\),显然S为有界闭集,则连续函数\\(R_1(X)\\)在S上可以达到最大(小)值,记为, \\[m=\\min R_1(X), \\quad M=\\max R_1(X)\\] 对\r\n\\[\\forall X\\neq 0\\quad \\frac{X}{R_2(X)}\\in\r\nS\\] 且 \\[\\frac{R_1(X)}{R_2(X)}=R_1(\\frac{X}{R_2(X)})\\]\r\n故有, \\[m&lt;\\frac{R_1(X)}{R_2(X)}=R_1(\\frac{X}{R_2(X)})&lt;M\\]\r\n定义: 若\\(\\{X^{(m)}\\}_{m=1}^{\\infty}\\) 为\\(\\R^n\\)上的向量序列,如果\\(\\exist \\alpha\\in\\R^n,\\quad s.t.\r\n\\lim_{m\\rightarrow\\infty}||X^{(m)}-\\alpha||=0\\)则称,序列\\(\\{X^{(m)}\\}_{m=1}^{\\infty}\\)收敛于\\(\\alpha\\).\r\n定理: 向量序列\\(\\{X^{(m)}\\}_{m=1}^{\\infty}\\)收敛等价于每个分量收敛.即\r\n\\[\\lim_{m\\rightarrow\\infty}||X^{(m)}-\\alpha||=\r\n\\Leftrightarrow\r\n\\lim_{m\\rightarrow\\infty}||x_i^{(m)}-\\alpha||=\\alpha_i,\\forall\r\ni\\]\r\n可用1范数证得.\r\n矩阵范数和条件数\r\n矩阵范数\r\n定义: 若\\(A\\in \\R^{m\\times\r\nn}\\)满足: - （非负性） - （正齐次性） - （三角不等式） -\r\n(矩阵范数相容性) \\[||AB||\\leq||A||||B||\\]\r\n定义: \\[||A||=\\sup_{X\\in\r\n\\R^{n},X\\neq 0}\\frac{||AX||}{||X||}=\\sup_{X\\in\r\n\\R^n,||X||=1}||AX||\\] 由定义显然可以推得,(证明是从定义显然得到的)\r\n\\[||AX||\\leq||A||||X||,X\\in\\R^{n}\\]\r\n即,矩阵向量范数相容.\r\n另外,由这个定义也可以推得,矩阵范数的相容性 ,只要令\\(X&#39;=BX\\),显然\\(X&#39;\\)还是个向量.用矩阵向量范数的相容性,得\r\n\\[||AX&#39;||\\leq||A||||X&#39;||\\leq||A||\\cdot||B||\\cdot||X||,X&#39;\\in\\R^{n+1}\\]\r\n即,得, \\[\\frac{||ABX||}{||X||}\\leq||A||\\cdot||B||\\]\r\n由\\(X\\)的任意性, \\[\\sup_{X\\neq\r\n0}{\\frac{||ABX||}{||X||}}\\leq||A||\\cdot||B||\\] 故, \\[||AB||=\\sup_{X\\neq\r\n0}{\\frac{||ABX||}{||X||}}\\leq||A||\\cdot||B||\\]\r\n定理: 矩阵范数是关于\\(n\\times n\\)个元素的一致连续函数.\r\n定理:\r\n矩阵范数都等价.(只要不是计算题,不必过分关心是什么范数)\r\n常用的矩阵范数\r\n\r\n列和范数 \\[||A||_1=\\max_{1\\leq j\\leq\r\nn}\\sum_{i=1}^{n}|a_{ij}|\\]\r\n行和范数 \\[||A||_{\\infty}=\\max_{1\\leq\r\ni\\leq n}\\sum_{j=1}^{n}|a_{ij}|\\]\r\n谱范数 \\[||A||_2=\\sqrt{\\rho(A^*A)}\\] 其中 \\[A^*=A^T,\\rho(A)=\\max_{i}|\\lambda_i(A)|\\]\r\nFrobenius范数 \\[||A||_F=(\\sum_{j=1}^{n}\\sum_{i=1}^{n}|a_{ij}|^2)^{\\frac{1}{2}}\\]\r\n\r\n定理:(列和范数) 设\\(A=(a_{ij})_{n\\times n}\\),则 \\[||A||_1=\\max_{1\\leq j\\leq\r\nn}\\sum_{i=1}^{n}|a_{ij}|\\]\r\nProof: 根据矩阵范数定义 \\[||A||_1=\\sup_{X\\in \\R^{n},X\\neq\r\n0}\\frac{||AX||_1}{||X||_1}\\] 记\\(Y=AX,y_i=\\sum_{j=1}^{n}a_{ij}x_{j}\\),于是\r\n\\[||AX||_1=||Y||_1=\\sum_{i=1}^{n}|y_i|=\\sum_{i=1}^{n}|\\sum_{j=1}^{n}a_{ij}x_{j}|\\]\r\n\\[\\leq\r\n\\sum_{i=1}^{n}\\sum_{j=1}^{n}|a_{ij}||x_{j}|=\\sum_{j=1}^{n}\\sum_{i=1}^{n}|a_{ij}||x_{j}|\\]\r\n记\\(c_j=\\sum_{i=1}^{n}|a_{ij}|\\),于是,\r\n\\[\\sum_{j=1}^{n}\\sum_{i=1}^{n}|a_{ij}||x_{j}|\\leq\r\n||C||_{\\infty}||X||_1\\] 其中, \\[||C||_{\\infty}=\\max_{1\\leq j\\leq\r\nn}|c_j|=\\max_{1\\leq j\\leq n}|\\sum_{i=1}^{n}|a_{ij}||\\] 即, \\[\\frac{||AX||_1}{||X||_1}\\leq||C||_{\\infty}\\]\r\n那么有, \\[||A||_1=\\sup_{X\\neq\r\n0}\\frac{||AX||_1}{||X||_1}\\leq||C||_{\\infty}=\\max_{1\\leq j\\leq\r\nn}|\\sum_{i=1}^{n}|a_{ij}||\\]\r\n另一方面, 记,(第k列达到最大) \\[||A||_1=\\sum_{i=1}^{n}|a_{ik}|\\] 取\\(X=e_k=(0,)\\)则, \\[||A||_1=\\sup{||AX||_1}\\geq\r\n||Ae_k||_1=\\sum_{i=1}^{n}|a_{ik}|=\\max_{1\\leq j\\leq\r\nn}\\sum_{i=1}^{n}|a_{ij}|\\] 命题得证.\r\n定理:(行和范数) 设\\(A=(a_{ij})_{n\\times n}\\),则 \\[||A||_{\\infty}=\\max_{1\\leq i\\leq\r\nn}\\sum_{j=1}^{n}|a_{ij}|\\]\r\nProof: 由矩阵范数定义, \\[||A||_{\\infty}=\\sup_{X\\neq\r\n0}\\frac{||AX||_{\\infty}}{||X||_{\\infty}}\\] 考虑\\(||AX||_{\\infty}\\), 记\\(Y=AX,y_i=\\sum_{j=1}^{n}a_{ij}x_{j}\\),于是\r\n\\[||AX||_{\\infty}=||Y||_{\\infty}=\\max_{1\\leq\r\ni \\leq n}|y_i|=\\max_{1\\leq i \\leq n}{|\\sum_{j=1}^{n}a_{ij}x_{j}|}\\leq\r\n\\max_{0\\leq i\\leq n}\\sum_{j=1}^{n}|a_{ij}||x_{j}|\\] \\[\\leq\\max_{0\\leq i\\leq\r\nn}||d||_1||x_{j}||_{\\infty}\\] 其中, \\[||d||_{1}=\\sum_{j=1}^{n}|d_j|=\\sum_{j=1}^{n}|a_{ij}|\\]\r\n即有, \\[||A||_{\\infty}=\\sup{\\frac{||AX||_{\\infty}}{||X||_{\\infty}}}=\\max_{1\\leq\r\ni\\leq n}\\sum_{j=1}^{n}|a_{ij}|\\]\r\n另一方面， 若 \\[\\max_{1\\leq i\\leq\r\nn}\\sum_{j=1}^{n}|a_{ij}|=\\sum_{j=1}^{n}|a_{kj}|\\] 取\\(\\xi=(\\xi_1,\\cdots,\\xi_n)^T\\),其中, \\[\\xi_j=\\begin{cases}\r\n    1,\\quad 若a_{kj}\\geq 0\\\\\r\n    -1,\\quad 若a_{kj}&lt;0\r\n\\end{cases}\\] 显然\\(||\\xi||_{\\infty}=1\\), 又由, \\[||A||_{\\infty}=\\sup_{||X||_{\\infty}=1}||AX||_{\\infty}\\geq\r\n||A\\xi||_{\\infty}=\\max_{1\\leq i\\leq\r\nn}\\sum_{j=1}^{n}|a_{ij}\\xi_j|\\] (下面是关键部分)\r\n注意:(1)\\(a_{kj}\\)与\\(\\xi_j\\)同号;(2)\\(\\xi_j\\)只影响\\(a_{kj}\\)的符号不影响绝对值 \\[\\max_{1\\leq i\\leq\r\nn}\\sum_{j=1}^{n}|a_{ij}\\xi_j|=\\sum_{j=1}^{n}|a_{kj}\\xi_j|=\\sum_{j=1}^{n}|a_{kj}|=\\max_{1\\leq\r\ni\\leq n}\\sum_{j=1}^{n}|a_{ij}|\\]\r\n引理: 若\\(A\\in C^{n \\times\r\nn}\\),则 1. \\(A^*A\\)为半正定的Hermit矩阵 2. 若\\(A\\)为Hermit矩阵,即\\(A^*=A\\),则其特征根是实的 3. 若\\(A\\)为Hermit矩阵,则不同特征值的特征向量正交\r\nProof:\r\n(1)由Hermit矩阵定义,有\\((A^*A)^*=A^*(A^*)^*=A^*A\\)\r\n对\\(\\forall X\\in C^n\\),有 \\[X^*(A^*A)X=X^*A^*AX=(AX)^*AX=(AX,AX)=||AX||_2^2\\geq\r\n0 \\]\r\n(2)记\\(AV=\\lambda\r\nV\\),两边取共轭转置,得 \\[V^*A^*=(AV)^*=(\\lambda V)^*=\\lambda^*V^*\\]\r\n上式两边右乘\\(V\\)得 \\[V^*A^*V=\\lambda^*V^*V\\] 左边有 \\[V^*A^*V=\\lambda V^*V\\] 于是可得, \\[(\\lambda-\\lambda^*)V^*V=(\\lambda-\\lambda^*)||V||^2_2=0\\]\r\n故有, \\(\\lambda =\r\n\\lambda^*=\\bar{\\lambda}\\),即\\(\\lambda\\)为实数.\r\n(3)记\\(AV=\\lambda V,\\quad AW=\\mu\r\nW\\)\r\n对\\(AW=\\mu W\\),左乘\\(V^*\\),有 \\[V^*AW=V^*\\mu W=\\mu V^* W\\] 等式左边, \\[V^*AW=(A^*V)^*W=(AV)^*W=\\lambda^*V^*W=\\lambda\r\nV^*W\\] 故有, \\[(\\lambda-\\mu)V^*W=0\\] 由于\\(\\lambda\\neq\\mu\\),故有, \\[V^*W=(V,W)=0\\]\r\n一个简单性质 \\[(X,AY)=(A^*X,Y)\\] Proof:\r\n\\[(A^*X,Y)=(A^*X)^*Y=X^*AY=(X,AY)\\]\r\n下面证明2范数.\r\n定理:(2范数 谱范数) 设\\(A=(a_{ij})_{n\\times n}\\),则 \\[||A||_2=\\sqrt{\\rho(A^*A)}\\]\r\nProof: 记半正定的Hermit矩阵\\(A^*A\\)的实特征根为 \\[\\mu_1,\\mu_2,\\cdots,\\mu_n\\] \\(A^*A\\)有一组完备的单位正交的特征向量 \\[\\varphi_1,\\varphi_2,\\cdots,\\varphi_n\\]\r\n则,对\\(\\forall X\\in C^{n}\\),\\(X=\\sum^{n}_{i=1}t_i\\varphi_i\\)\r\n由 \\[||A||_2=\\sup_{||X||_2=1}{||AX||_2}\\]\r\n可取\\(||X||_2=1\\),则, \\[1=||X||_2^2=(X,X)=(\\sum^{n}_{i=1}t_i\\varphi_i,\\sum^{n}_{i=1}t_i\\varphi_i)=\\sum^{n}_{i=1}|t_i|^2||\\varphi_i||_2^2=\\sum^{n}_{i=1}|t_i|^2\\]\r\n由简单性质2, \\[\r\n\\begin{split}\r\n    ||X||_2=&amp;\\sqrt{(AX,AX)}=\\sqrt{(A^*AX,X)}=\\sqrt{(A^*A\\sum^{n}_{i=1}t_i\\varphi_i,\\sum^{n}_{i=1}t_i\\varphi_i)}\\\\=&amp;\\sqrt{(\\sum^{n}_{i=1}t_iA^*A\\varphi_i,\\sum^{n}_{i=1}t_i\\varphi_i)}=\\sqrt{(\\sum^{n}_{i=1}t_i\\mu_i\\varphi_i,\\sum^{n}_{i=1}t_i\\varphi_i)}\\\\\r\n    =&amp;\\sqrt{\\sum^{n}_{i=1}\\mu_i|t_i|^2}\\leq\\sqrt{\\mu_{max}\\sum^{n}_{i=1}|t_i|^2}=\\sqrt{\\mu_{max}}\r\n\\end{split}\r\n\\] 则, \\[||A||_2=\\sup_{||X||_2=1}||AX||_2\\leq\r\n\\sqrt{u_{max}}=\\sqrt{\\rho(A^*A)}\\]\r\n另一方面,取\\(x=\\varphi_n\\),则\\(||\\varphi_n||_2=1\\)(\\(\\varphi_n\\)为\\(\\mu_{max}\\)对应的特征向量) \\[\r\n\\begin{split}\r\n    ||A\\varphi_n||_2=&amp;\\sqrt{(A\\varphi_n,A\\varphi_n)}=\\sqrt{(A^*A\\varphi_n,\\varphi_n)}=\\sqrt{(\\mu_{max}\\varphi_n,\\varphi_n)}\\\\\r\n    =&amp;\\sqrt{u_{max}}=\\sqrt{\\rho(A^*A)}\r\n\\end{split}\r\n\\] 得, \\[||A||_2=\\sup_{||X||_2=1}||AX||_2\\geq\r\n||A\\varphi_n||_2\\geq \\sqrt{u_{max}}=\\sqrt{\\rho(A^*A)}\\]\r\n推论: - \\(\\rho(A)\\leq||A||\\) - 若\\(A\\)是正规阵,即\\(AA^*=A^*A\\) ,则\\(\\rho(A)=||A||_2\\)\r\nProof:\r\n\r\n若\\(A\\varphi=\\lambda\\varphi\\),则,\r\n\\[||A||=\\sup_{||X||\\neq\r\n0}\\frac{||A\\varphi||}{||X||}\\geq\r\n\\frac{||A\\varphi||}{||\\varphi||}=\\frac{||\\lambda\\varphi||}{||\\varphi||}=\\frac{|\\lambda|||\\varphi||}{||\\varphi||}=|\\lambda|\\]\r\n由\\(\\lambda\\)的任意性, \\[\r\n\\max_{i}|\\lambda|=\\rho(A)\\leq ||A||\r\n\\]\r\n当\\(A\\)是正规阵时,可以进行酉对角化,即存在酉矩阵\\(U^*U=UU^*=I\\),使得, \\[\r\nU^{-1}AU=\\Lambda\r\n\\] \\[\r\n\\begin{split}\r\nA^*A&amp;=(U\\Lambda U^{-1})^*U\\Lambda U^{-1}\\\\\r\n&amp;=U^{**}\\Lambda^* U^{*}U\\Lambda U^{-1}\\\\\r\n&amp;=U\\Lambda^*\\Lambda U^{-1}\\\\&amp;=U^{**}\\begin{pmatrix}\r\n    |\\lambda_1|^2&amp;&amp;\\\\\r\n    &amp;\\ddots&amp;\\\\\r\n   &amp;&amp; |\\lambda_n|^2\\\\\r\n\\end{pmatrix} U^{-1}\r\n\\end{split}\r\n\\] 于是\\(\\rho(A^*A)=\\rho^2(A)\\)\r\n\\[||A||_2=\\sqrt{\\rho(A^*A)}=\\sqrt{\\rho^2(A)}=\\rho(A)\\]\r\n\r\n矩阵的条件数与误差分析\r\n定义: 若\\(A\\)非奇异,称 \\(Cond(A)=||A||\\cdot||A^{-1}||\\) 为\\(A\\)的条件数.\r\n条件数越大,误差放大的倍数就越大,矩阵的稳定性就越差,受到微小扰动对计算结果的影响就越大.\r\n\r\n若\\(A\\)的条件数较大,\\(Cond(A)=O(n^2)\\),称\\(AX=b\\)病态的.\r\n\\(1=||I||=||A^{-1}A||\\leq\r\n||A^{-1}||||A||=Cond(A)\\)\r\n\r\n引理: - 若\\(||B||\\leq\r\n1\\),则\\(I+B\\)非奇异,且 \\[||(I+B^{-1}||\\leq\\frac{1}{1-||B||}\\] -\r\n若\\(||A^{-1}||\\cdot||\\delta\r\nA||&lt;1\\),则\\(A+\\delta\r\nA\\)可逆.\r\nProof: (1).用反证法.若\\(I+B\\)奇异,则有\\(X\\neq 0\\)满足, \\[(I+B)X=0\\] 即, \\[BX=-X\\] 则\\(B\\)有一个特征值为\\(-1\\),那么 \\[\\rho(B)\\geq 1\\] 但是我们有, \\[\\rho(B)\\leq ||B||&lt;1\\] 矛盾.故\\(I+B\\)非奇异. 记\\(C=(I+B)^{-1}\\),则, \\[\r\n\\begin{split}\r\n    1&amp;=||I||=||(I+B)C||\\\\\r\n    &amp;=||C+BC||\\geq ||C||-||BC||\\\\\r\n    &amp;=||C||-||B||||C||=(1-||B||)||C||\r\n\\end{split}\r\n\\] 于是就有, \\[\r\n||C||=||(I+B)^{-1}||\\leq\\frac{1}{1-||B||}\r\n\\]\r\n(2)注意到, \\[\r\nA+\\delta A=A(I+A^{-1}\\delta A)\r\n\\] 记\\(B=A^{-1}\\delta\r\nA\\),且注意到, \\[\r\n||B||\\leq||A^{-1}||\\cdot||\\delta A||&lt;1\r\n\\] 故\\(I+B\\)可逆,并且有, \\[||(I+B)^{-1}||\\leq\\frac{1}{1-||B||}\\leq\r\n\\frac{1}{1-||A^{-1}||||\\delta A||}\\] 以下考虑\\(A\\rightarrow A+\\delta A\\),或\\(b\\rightarrow b+\\delta b\\)对 \\[AX=b\\] 解的影响,\r\n\r\n\\(A\\rightarrow A+\\delta A\\),\r\n而\\(b\\)精确. \\[\r\n(A+\\delta A)(X+\\delta X)=b \\Rightarrow \\delta A X+A\\delta X+\\delta\r\nA\\delta X=0\r\n\\] \\[\r\n\\Rightarrow (A+\\delta A)\\delta X=A(I+B)\\delta X=-\\delta A X\r\n\\] \\[\r\n\\Rightarrow \\delta X =-A^{-1}(I+B)^{-1}(\\delta A) X\r\n\\] 于是, \\[\r\n||\\delta X||\\leq||A^{-1}||\\cdot||(I+B)^{-1}||\\cdot||\\delta A||||X||\r\n\\] \\[\r\n\\begin{split}\r\n\\Rightarrow \\frac{ ||\\delta X||}{ ||X||}\\leq&amp;\r\n||A^{-1}||\\cdot||(I+B)^{-1}||\\cdot||\\delta A||\\\\\r\n\\leq &amp; \\frac{ ||A^{-1}||||\\delta A||}{1-||B||}\\leq \\frac{\r\n||A^{-1}||||\\delta A||}{1-||A^{-1}||||\\delta A||}\\\\\r\n= &amp; \\frac{ ||A||||A^{-1}||\\frac{||\\delta\r\nA||}{||A||}}{1-||A||||A^{-1}||\\frac{||\\delta A||}{||A||}}\\\\\r\n=&amp;\\frac{Cond(A)\\frac{||\\delta A||}{||A||}}{1-Cond(A)\\frac{||\\delta\r\nA||}{||A||}}\r\n\\end{split}\r\n\\] 一般有\\(||\\delta\r\nA||&lt;&lt;1\\),此时不等式右边分母约等于1,于是,\r\n$$ Cond(A)\r\n$$\r\n\\(b\\rightarrow b+\\delta b\\),\r\n而\\(A\\)精确. \\[A(X+\\delta X)=b+\\delta b\\] 于是有, \\[\r\n  A\\delta X=\\delta b \\Rightarrow \\delta X=A^{-1}\\delta b\r\n  \\] 且, \\[\r\n  ||\\delta X||=||A^{-1}\\delta b||\\leq ||A^{-1}||||\\delta b||\r\n  \\] 另一方面, \\[||b||=||AX||\\leq\r\n||A||||X||\\] 则, \\[||X||\\geq\\frac{||b||}{||A||}\\] 故有, \\[\r\n  \\frac{||\\delta X||}{||X||}\\leq\\frac{||A^{-1}||||\\delta\r\nb||}{\\frac{||b||}{||A||}}=Cond(A)\\frac{||\\delta b||}{||b||}\r\n  \\]\r\n\r\n例题:行列式小,条件数不一定大\r\n收敛矩阵（第三章铺垫）\r\n定义: \\(\\{A^{(m)}\\}_{m=1}^{\\infty}\\)为\\(\\R^{n\\times m}\\)上的矩阵序列,若, \\[\r\n\\lim_{m\\rightarrow \\infty}||A^{(m)}-A||=0\r\n\\] 则称,\\(\\{A^{(m)}\\}_{m=1}^{\\infty}\\)是收敛的,且\\(A\\)为序列的极限.\r\n定理: 记\\(A^{(m)}=(a_{ij}^{(m)})_{n\\times\r\nn}\\),则\\(\\{A^{(m)}\\}_{m=1}^{\\infty}\\)收敛, 当且仅当,\r\n\\[\\lim_{m\\rightarrow\r\n\\infty}a_{ij}^{(m)}=a_{ij}\\]\r\n推论: 记\\(A^{(m)}=(a_{ij}^{(m)})_{n\\times\r\nn}\\),则\\(\\{A^{(m)}\\}_{m=1}^{\\infty}\\)收敛到零矩阵,则,\r\n\\[\\lim_{m\\rightarrow\r\n\\infty}a_{ij}^{(m)}=0\\]\r\n定义:(收敛矩阵) 记\\(A^2=AA,A^3=A^2A,\\cdots\\),若\\(A^k\\)收敛到零矩阵,则称\\(A\\)为收敛矩阵.\r\n定理: \\(A\\)为收敛矩阵\\(\\quad \\Leftrightarrow\\quad\r\n\\rho(A)&lt;1\\)\r\n证明: 由Jordan对角化,存在可逆矩阵\\(S\\),使得, \\[\r\nA=S^{-1}\r\n\\begin{pmatrix}\r\n        J_1&amp;&amp;\\\\\r\n        &amp;\\ddots&amp;\\\\\r\n       &amp;&amp; J_r\\\\\r\n    \\end{pmatrix}\r\nS\r\n\\] 其中,Jordan块为, \\[\r\nJ_i=\r\n\\begin{pmatrix}\r\n        \\lambda_i&amp;1&amp;&amp;\\\\\r\n      &amp;\\ddots&amp;\\ddots&amp;\\\\\r\n      &amp;&amp;\\ddots&amp;1\\\\\r\n       &amp;&amp;&amp; \\lambda_i\\\\\r\n\\end{pmatrix}_{l_i\\times l_i}\r\n\\quad \\sum_{i=1}^{r}l_i=n\r\n\\] 则, \\[\r\nA^k=S^{-1}\r\n\\begin{pmatrix}\r\n        J_1^k&amp;&amp;\\\\\r\n        &amp;\\ddots&amp;\\\\\r\n       &amp;&amp; J_r^k\\\\\r\n    \\end{pmatrix}\r\nS\r\n\\] 其中,!!!!!!!!!!! \\[\r\nJ_i=\r\n\\begin{pmatrix}\r\n        \\lambda_i&amp;1&amp;&amp;\\\\\r\n      &amp;\\ddots&amp;\\ddots&amp;\\\\\r\n      &amp;&amp;\\ddots&amp;1\\\\\r\n       &amp;&amp;&amp; \\lambda_i\\\\\r\n\\end{pmatrix}_{l_i\\times l_i}\r\n\\quad \\sum_{i=1}^{r}l_i=n\r\n\\]\r\n\r\n对角元: \\(A^k\\)收敛到零矩阵\\(\\Leftrightarrow|\\lambda_i|&lt;1\\)\r\n非对角元(趋于0):由\\(C_k^j=\\frac{}{j!}\\approx k^r\\),非对角元,\r\n\\[  \\]\r\n\r\n推论: 若\\(||A||&lt;1\\),则\\(A\\)为收敛矩阵.(充分条件,上面的是充要)\r\n这是因为,\\(\\rho(A)\\leq ||A||\\)\r\n例题: 设\\(A,B\\in\\R^{n\\times n}\\),试证,当\\(A,B\\)非奇异时, - \\(Cond(A^{-1})=Cond(A)\\) - \\(Cond(\\alpha A)=Cond(A),\\alpha\\in\\R\\) -\r\n\\(Cond(AB)\\leq Cond(A)Cond(B)\\)\r\n证明: 第一条显然.\r\n第二条, \\[Cond(\\alpha A)\r\n=||\\alpha A||||\\alpha A^{-1}||\r\n=|\\alpha|||A||\\frac{1}{|\\alpha|}||A^{-1}||\r\n=Cond(A),\\alpha\\in\\R\\] 第三条, \\[\r\nCond(AB)=||AB||||B^{-1}A^{-1}||\\leq\r\n||A||||A^{-1}||||B||||B^{-1}||=Cond(A)Cond(B)\r\n\\]\r\n","categories":["Math","数值代数"],"tags":["数值代数"]},{"title":"动态规划问题","url":"/2023/05/21/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/","content":"\r\n","categories":["Math","运筹"],"tags":["运筹学"]},{"title":"Huffman编码","url":"/2023/05/28/%E5%AE%9E%E9%AA%8C%E4%B8%89%20Huffman%E7%BC%96%E7%A0%81/","content":"import numpy as npimport copy  # 节点类class Node:    def __init__(self,name=None,value=None):        self._name=name        self._value=value        self.l_child = []    # 子节点列表        self.code=b&quot;&quot;    # 添加子节点    def add_child(self,node):        self.l_child.append(node)  # You can modify the code as what you wantclass huffman_coding_in_byte:    def __init__(self, text):        self.text = text        self.bits = 256        # you can store your encode and decode dict here        self.encode_dict = dict()        self.decode_dict = dict()        self.words=self.get_prob()[0]        self.probs=self.get_prob()[1]        self.L=len(self.words)        self.k=0        while self.k*(self.bits-1)+1 &lt; self.L:            self.k+=1        self.first=self.bits-(self.k*(self.bits-1)+1 - self.L) #第一次合并的项数        self.nodes=[Node(self.words[i],self.probs[i]) for i in range(self.L)]    # you can use this to find all the unique source with sorted prob.    def get_prob(self):        unique = np.array(list(set(self.text)))        prob = np.array([self.text.count(u)/len(self.text) for u in unique])        sort_idx = np.argsort(prob)[::-1]        return list(unique[sort_idx]), list(prob[sort_idx])    def select_sort_nodes(self):        if len(self.nodes) == 1:            return        else:            # 选择概率最小的几个节点合并成新节点            if self.first != 0:                new_node=Node(                    name=self.nodes[-self.first]._name+self.nodes[-1]._name,                    value=sum([self.nodes[i]._value for i in range(-self.first,0)])                )                                for i in range(-self.first,0):                    new_node.add_child(self.nodes[i])                for i in range(0,self.first):                    self.nodes.pop()                        self.first = 0              else:                new_node=Node(                    name=self.nodes[-self.bits]._name+self.nodes[-1]._name,                    value=sum([self.nodes[i]._value for i in range(-self.bits,0)])                )                for i in range(-self.bits,0):                    new_node.add_child(self.nodes[i])                for i in range(0,self.bits):                    self.nodes.pop()              self.nodes.append(new_node)            # 节点排序            values = []            for i in range(len(self.nodes)):                values.append(self.nodes[i]._value)            nodes = []            for i in range(len(self.nodes)):                nodes.append(self.nodes[i]._name)            idx = np.argsort(values)[::-1]            n=[]            for name in np.array(nodes)[idx]:                for i in range(len(self.nodes)):                    if self.nodes[i]._name ==  name:                        n.append(self.nodes[i])            self.nodes=copy.deepcopy(n) #这个没必要好像==================================            self.select_sort_nodes()            return      def generate_encode_dict(self,current_node):        for i in range(0,len(current_node.l_child)):            if current_node.l_child[i].l_child == []: # 如果没有子节点就给一个编码                            current_node.l_child[i].code = current_node.code+i.to_bytes(1,&quot;big&quot;)                self.encode_dict[current_node.l_child[i]._name]=current_node.l_child[i].code                # with open(&quot;编码对照文件.txt&quot;,&quot;a+&quot;,encoding=&quot;utf-8&quot;) as f:                #     f.write(current_node.l_child[i]._name+&quot;:&quot;)                #     f.write(str(current_node.l_child[i]._value))                #     f.write(str(current_node.l_child[i].code)+&quot;\\n&quot;)            else:                current_node.l_child[i].code = i.to_bytes(1,&quot;big&quot;)                self.generate_encode_dict(current_node.l_child[i])        return      def encode(self):        #encode the text with huffman coding        self.select_sort_nodes()        self.generate_encode_dict(self.nodes[0]) #传入根节点        print(&quot;编码字典做好了，编码的字符个数为：&quot;,len(self.encode_dict))        encoded_text=b&quot;&quot;        # 编码        for w in self.text:            encoded_text += self.encode_dict[w]        return encoded_text    def decode(self, encoded_text):        # decode the encoded text        decoded_text = &quot;&quot;        # 解码的字典        self.decode_dict=&#123;v:k for k,v in self.encode_dict.items()&#125;        # 解码        code = b&quot;&quot;        for w in encoded_text:            code = code + w.to_bytes(1,&quot;big&quot;)            #print(code) #前缀码            if code in self.decode_dict:                decoded_text+= self.decode_dict[code]                code = b&quot;&quot;        return decoded_text    ## test 1# decoded text should be the same as the original textwith open(&#x27;孤星.txt&#x27;, &#x27;r&#x27;, encoding=&quot;utf-8&quot;) as f:    file_content = f.read()  my_huffman_coding = huffman_coding_in_byte(file_content)encoded_text = my_huffman_coding.encode()#print(encoded_text)print(my_huffman_coding.encode_dict) # 打印编码字典print(my_huffman_coding.decode(encoded_text))  # 打印解码结果  ## Test 2utf_encoded_text = file_content.encode(&quot;utf-8&quot;)print(&quot;压缩前：&quot;,len(utf_encoded_text))print(&quot;压缩后&quot;,len(encoded_text))\r\n压缩前： 429992压缩后 204812\r\n","categories":["Math","信息论"],"tags":["实验","信息论基础"]},{"title":"决策树构建","url":"/2023/05/12/%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E5%86%B3%E7%AD%96%E6%95%B0%E7%9A%84%E6%9E%84%E5%BB%BA/","content":"import numpy as npimport copy# You can modify the code as what you want  class decision_tree:    def __init__(self, features, output, dataset):        self.features = features        self.output = output        self.dataset = dataset        self.depth = 0            def log(self, x):        return np.log2(x)    # you can use this function to calculate the emprical probability of a random variable under a dataset    def get_prob(self, array):        (unique, counts) = np.unique(array, return_counts=True, axis=0)        return counts/len(array)    # you can use this function to calculate the emprical entropy of a random variable under a dataset    def entropy(self, array):        p = self.get_prob(array)        return -np.sum(p*np.log2(p))    def output_entropy(self):        # calculate the emprical entropy of the output        output_array = []        for data in self.dataset:            output_array.append(data.get(self.output))        #print(self.entropy(output_array)) #测试用        return self.entropy(output_array)    def conditional_entropy(self, feature):        # calculate the emprical conditional entropy of the output relative to the &quot;feature&quot;        feature_array = []        for data in self.dataset:            feature_array.append(data.get(feature))        # 计算权值        weight_array = self.get_prob(feature_array)        (unique, counts) = np.unique(feature_array, return_counts=True)        # 条件下的经验熵        entropy_array = []        for u in unique:            list = []            for data in self.dataset:                if data.get(feature) == u:                    list.append(data.get(self.output))            entropy_array.append(self.entropy(list))        #加权计算得到最后的条件熵        result = np.sum(np.array(weight_array) * entropy_array)        return result    def feature_selection(self):        # select the feature has maximum mutual information        v = 0        selected = &#x27;我是字符串&#x27;        for f in self.features:            #print(&quot;互信息为&quot;,self.output_entropy()-self.conditional_entropy(f))            v1 = self.output_entropy()-self.conditional_entropy(f)            if v1 &gt;= v:              # 这里要取等号，不然互信息为0的时候特征选择会选成“我是字符串”                selected = f         # 出现这种现象很可能是分类已经很细了，样本数据太小（bug找了半天）        #print(&quot;现在选择：&quot;,selected)        return selected# 自己加的一个函数    def tof(self,classify_dataset): # 判断分类 true or false，就是比较分类里去图书馆的人多一些还不去的多一些        (unique, counts) = np.unique([d.get(self.output) for d in classify_dataset],return_counts=True)        # 对这个分类下结论        #print(unique,counts)        if len(counts) == 2:          # false 和 true 是不是同时有            if counts[0] &gt; counts[1]: # false 比 true 多                return unique[0]            else:                return unique[1]        else:            return unique[0]# 自己加的又一个函数，不然predict这个函数看起来太大了    def classify(self,selected_feature,u): # 得到分类好的数据集        # 划分数据集合        classify_dataset = []        for d in self.dataset:            if d.get(selected_feature) == u:                classify_dataset.append(d)        #print(&quot;该分类的元素个数&quot;,len(classify_dataset))        #print(classify_dataset) # 打印分类好的数据集        return classify_dataset  # 又又加的    def train(self, data):        # 训练构建决策树        global decision_order,depth,max_depth,tree,branch        depth = depth + 1        #print(&quot;depth -----------&quot;,depth)        if depth &lt;= max_depth:            selected_feature = self.feature_selection()# 选出当前最优标签            if  len(data) == 0: # 只有一个特征标签时就停止进入递归                depth = depth - 1                max_depth = depth                print(&quot;最大深度为-------------&quot;,max_depth)                return            else:                if max_depth == 100:                    decision_order.append(selected_feature)   # 当前最优标签加入决策序列                feature_array = []                        # 依据当前最优标签分成几叉                for d in self.dataset:                    feature_array.append(d.get(decision_order[depth-1]))                (unique, counts) = np.unique(feature_array, return_counts=True)                decision_feature=list(data)                decision_feature.remove(selected_feature) # 接下来的决策标签 要除去当且最优标签                # 遍历这个特征所有的值                for u in unique:                    #print(&quot;目前所在边为：&quot;,selected_feature,u)                    branch.append(u)                    classify_dataset=self.classify(selected_feature,u)                    # 递归进入下一层                    if depth != max_depth:                        predict_tree=decision_tree(decision_feature,self.output,classify_dataset)                        predict_tree.train(decision_feature)                        #print(&quot;当前深度为&quot;,depth)                    # 对这个分类下结论                    if depth == max_depth:                        a = self.tof(classify_dataset)                        tree[tuple(branch)]=a                    branch.pop(-1)                depth = depth - 1        return      def predict(self, data):        data1 = copy.deepcopy(data)        if self.output in data1: # 如果输入的特征里有决策的特征就丢掉            del data1[self.output]          # make prediction for an arbitrary data input        if tree == &#123;&#125;:            self.train(data1) # 构建决策树            #print(tree) # 打印决策树          # 依据构建的决策树做判断        if len(data1)==len(decision_order):            #print(tree[tuple([data.get(d) for d in decision_order])])            my_judge = tree[tuple([data1.get(d) for d in decision_order])]            #print(my_judge,1231232131)            return my_judge        return    decision_order = [] # 控制决策顺序depth = 0          # 深度max_depth = 100    # 最大深度tree = &#123;&#125;branch = []  dataset = [    &#123;&quot;age&quot;: 19, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: False&#125;,    &#123;&quot;age&quot;: 19, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: False&#125;,    &#123;&quot;age&quot;: 19, &quot;male&quot;: True,  &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 19, &quot;male&quot;: True,  &quot;single&quot;: True,  &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 19, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: False&#125;,    &#123;&quot;age&quot;: 20, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: False&#125;,    &#123;&quot;age&quot;: 20, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: False&#125;,    &#123;&quot;age&quot;: 20, &quot;male&quot;: True,  &quot;single&quot;: True,  &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 20, &quot;male&quot;: False, &quot;single&quot;: True,  &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 20, &quot;male&quot;: False, &quot;single&quot;: True,  &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 21, &quot;male&quot;: False, &quot;single&quot;: True,  &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 21, &quot;male&quot;: False, &quot;single&quot;: True,  &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 21, &quot;male&quot;: True,  &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 21, &quot;male&quot;: True,  &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: True&#125;,    &#123;&quot;age&quot;: 21, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: False&#125;,    &#123;&quot;age&quot;: 21, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: False&#125;,    &#123;&quot;age&quot;: 21, &quot;male&quot;: False, &quot;single&quot;: False, &quot;visit_library_in_Sunday&quot;: True&#125;]  my_tree = decision_tree(\\    [&quot;age&quot;, &quot;male&quot;, &quot;single&quot;], &quot;visit_library_in_Sunday&quot;, dataset)  # Test 1print(my_tree.predict(&#123;&#x27;age&#x27;: 19, &#x27;male&#x27;: False, &#x27;single&#x27;: False&#125;), &quot;should be 0 or False&quot;)  # Test 2# use the feature &quot;single&quot; to classify as last timedef tree_example(data):    if data[&quot;single&quot;]:        return True    else:        return Falsetrue_classification = 0for data in dataset:    if tree_example(data) == data[&quot;visit_library_in_Sunday&quot;]:        true_classification += 1  print(&quot;One feature classification accuracy:&quot;, true_classification/len(dataset))  # use a decision tree to classifytrue_classification = 0  for data in dataset:    if my_tree.predict(data) == data[&quot;visit_library_in_Sunday&quot;]:        true_classification += 1print(&quot;Decision tree classification accuracy:&quot;, round(true_classification/len(dataset),4), &quot;should be around 0.9412&quot;)\r\n最大深度为------------- 3False should be 0 or FalseOne feature classification accuracy: 0.7647058823529411Decision tree classification accuracy: 0.9412 should be around 0.9412\r\n","categories":["Math","信息论"],"tags":["实验","信息论基础"]},{"title":"插值方法（多项式插值）","url":"/2022/10/11/%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC%EF%BC%89/","content":"引言\r\n例子：容格函数\r\n情形\r\n\r\n函数以表格的形式呈现\r\n函数有解析式但太复杂不便于计算\r\n\r\n插值函数的目的是: (1)用更精炼的函数描述离散数据\r\n(2)构造既能反映函数本身性质又能便于计算的简单函数 ##\r\n插值方法概括\r\n由于多项式函数的形式最简单且便于计算,本节主要讨论的都是多项式插值理论和构造方法.\r\n- Lagrange插值方法.由基函数构造,容易拓展到高维 -\r\nNewton插值方法.适合增减插值节点的情况 - Hermit插值方法. -\r\n分段插值方法.为避免Runge现象. # 插值问题 ## 插值问题定义 - 被插值函数 -\r\n插值节点 - 插值条件 - 插值多项式 - 插值余项,也即误差 ##\r\n插值多项式的存在唯一性定理\r\n定理:给定互异的n+1个节点及其对应函数值，则存在唯一次数不超过n的多项式满足已给定的n+1个插值条件。\r\n定理证明：Vandermond矩阵\r\n实际求解线性方程组不会这样做（ 待定系数法） - 这个矩阵是病态的 -\r\n待定系数法计算量大 -\r\n存在唯一性指的是待定的系数是存在且唯一的，多项式的表示形式是多样的不唯一的\r\n余项公式定理\r\n这个定理用来说明插值多项式对被插值函数的逼近程序的好坏.\r\n定理:设\\(x_0,x_1,\\cdots,x_n\\)是\\([a,b]\\)内\\(n+1\\)个互不相同的插值节点,且\\(x\\in[a,b]\\).又设\\(f\\in C^{n+1}([a,b])\\).则插值多项式\\(p_n\\in P_n\\)在\\(x\\)点处的插值余项为,\r\n\\[\r\nR_n(x)=f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\pi_{n+1}(x)\r\n\\]\r\n其中,\\(\\xi_x\\in(a,b)\\),\\(\\pi_{n+1}(x)\\)为\\(n+1\\)次节点多项式,即,\r\n\\[\r\n\\pi_{n+1}(x)=\\prod_{i=0}^{n}(x-x_i)\r\n\\]\r\n证明:构造辅助函数.\r\n\\[\r\n\\phi(T)=f(T)-p_n(T)-\\frac{f(x)-p_n(x)}{\\pi_{n+1}(x)}\\pi_{n+1}(T),T\\in\r\n[a,b]\r\n\\]\r\n容易验证,辅助函数有\\(n+2\\)个零点,分别\\(x,x_0,x_1,\\cdots,x_n\\).应用Rolle定理,\r\n可以证明存在\\(\\xi_x\\in(a,b)\\),使得,\r\n\\[\r\n\\phi^{(n+1)}(\\xi_x)=0\r\n\\]\r\n于是对辅助函数求n+1次导有,\r\n\\[\r\n\\phi^{(n+1)}(\\xi_x)=f^{(n+1)}(\\xi_x)-0-\\frac{f(x)-p_n(x)}{\\pi_{n+1}(x)}(n+1)!=0\r\n\\]\r\n整理后得证.\r\n\r\n这个定理说明了插值多项式对被插值函数逼近程度的好坏\r\n证明是构造函数之后用Rolle定理\r\n首系数为1的n+1次多项式求n+1次导结果为\\((n+1)!\\)\r\n\r\nLagrange插值方法\r\nLagrange插值方法主要避免了待定系数法的两个问题: -\r\n求解线性方程组的计算量大 -\r\n范德蒙德矩阵是病态的,所以待定系数法得到的插值多项式是不可靠的 ##\r\nL插值定理 定理:设\\(x_0,x_1,\\cdots,x_n\\)为\\(n+1\\)个互异节点,被插值函数\\(f(x)\\)在插值节点的函数值已知.那么存在唯一次数不超过\\(n\\)的L插值多项式\\(L_n(x)\\in P_n\\),满足插值条件,\r\n\\[\r\nL_n(x_k)=f(x_k),k=0,1,\\cdots,n\r\n\\]\r\n而\\(L_n(x)\\)多项式形如,\r\n\\[\r\nL_n(x)=\\sum_{k=0}^{n}l_{k,n}(x)f(x_k)\r\n\\]\r\n其中,\r\n\\[\r\nl_{k,n}(x)=\\prod_{i=0,i\\neq k}^{n}\\frac{x-x_i}{x_k-x_i},k=0,1,\\cdots,n\r\n\\]\r\n证明:由基函数要满足如下性质:\r\n\\[\r\nl_{k,n}(x_j)=\\left\\{\\begin{matrix}\r\n1,j=k\\\\\r\n0,j\\neq k\r\n\\end{matrix}\\right. \\quad j,k=0,1,\\cdots,n\r\n\\]\r\n易知,\\(l_{k,n}(x)\\)含有因子\\(\\prod_{i=0,i\\neq\r\nk}^{n}(x-x_i)\\),又由于这个因子与\\(l_{k,n}(x)\\)的次数相同为n,因此两者间只差一个常数.又由\\(l_{k,n}(x_k)=1\\)可以推得定理结论.\r\n\r\n插值基函数 也叫特征多项式\r\n基函数这三个字其实体现的就是一种正交性\r\n被插值函数为多项式的插值多项式就是它本身，从余项公式为0可以看出\r\n变形形式 记\\(\\pi_{n+1}(x)=\\prod_{i=0}^{n}(x-x_i)\\),则基函数可以表示成,\r\n\r\n\\[\r\nl_{k,n}(x)=\\frac{\\pi_{n+1}(x)}{x-x_k}\\cdot\r\n\\frac{1}{\\pi_{n+1}&#39;(x_k)},k=0,1,\\cdots,n\r\n\\]\r\nL插值算法\r\n2.3.2.1 可以发现插值基函数只与节点有关，可以提前计算出所需要的基函数\r\n多元插值的方法（后面介绍\r\nNeville插值方法(略过了?)\r\nNewton插值方法\r\n引出\r\n给定n+1个节点，Newton插值的目的同样是要找到一个次数不超过n次的多项式\\(N_n(x)\\)，既满足插值条件，且同时\\(N_n(x)\\)可以表示成\\(N_{n-1}(x)\\)和一个次数不超过n次的多项式的和的形式，也即，\r\n\\[\r\nN_n(x)=N_{n-1}(x)+q(x)\r\n\\]\r\n优点\r\n\r\n本质是L插值多项式的等价形式\r\n牛顿法最大的优点是当需要增加一个节点时可以在原来的基础上加上一项，而拉格朗日法则要完全重新计算（基函数，整个插值多项式都要重新算）\r\n## 牛顿差商 由插值条件知，\r\n\r\n\\[\r\nq(x_i)=N_n(x_i)-N_{n-1}(x_i)=0,\\quad i=0,1,\\cdots,n-1\r\n\\]\r\n因此,\\(q(x)\\)应该含有因子\\(\\prod_{i=0}^{n-1}(x-x_i)\\),由于两者都是n次的多项式,所以他们之间只相差一个常数,而这可以用插值条件\\(N_n(x_n)=y_n\\)确定.\r\n\\[\r\nN_n(x_n)=N_{n-1}(x_n)+q(x_n)\r\n\\]\r\n\\[\r\ny_n-N_{n-1}(x)=q(x_n)=a_n\\prod_{i=0}^{n-1}(x_n-x_i)=a_n\\pi_n(x_n)\r\n\\]\r\n故有,\r\n\\[\r\na_n=\\frac{y_n-N_{n-1}(x_n)}{\\pi_n(x_n)}\r\n\\]\r\n系数\\(a_n\\)被称为牛顿差商. 记为,\r\n\\[\r\na_n=f[x_0,x_1,\\cdots,x_n],n\\geq1\r\n\\]\r\n牛顿差商是什么\r\nNewton差商实际上是多项式的一个系数。\r\n有了牛顿差商,我们可以把牛顿插值多项式改写一下,\r\n\\[\r\nN_n(x)=N_{n-1}(x)+a_n\\pi_n(x)=\\sum_{i=0}^{n}a_i\\pi_i(x)\r\n\\]\r\n其中,我们规定\\(f[x_0]=y_0,\\pi_0(x)=1\\).\r\n由插值多项式的唯一性,可知,Newton插值多项式跟Lagrange插值多项式是等价的.\r\n差商的性质\r\n公式\r\n\\[\r\na_n=\\frac{y_n-N_{n-1}(x_n)}{\\pi_n(x_n)}\r\n\\]\r\n虽然给出了一种计算差商的办法,但是要用到\\(N_{n-1}(x_n)\\),这并不便于计算.\r\n通过对牛顿差商性质的了解,我们可以给出更加实用的Newton插值多项式的构造方法.\r\n#### Newton差商性质 - 差商与节点的排序无关 首项系数与\r\nLagrange插值多项式的首项系数一致\r\nL插值多项式的首系数也是N插值多项式的首系数,也就是n阶Newton差商.\r\n\\[\r\nf[x_0,x_1,\\cdots,x_n]=\\sum_{i=0}^{n}\\frac{y_i}{\\pi_{n+1}&#39;(x_i)}\r\n\\]\r\n\r\n差商具有线性性质，若\\(f=\\alpha g+\\beta h\\),那么\r\n\r\n\\[\r\nf[x_0,x_1,\\cdots,x_n]=\\alpha g[x_0,x_1,\\cdots,x_n]+\\beta\r\nh[x_0,x_1,\\cdots,x_n]\r\n\\]\r\n\r\n递推公式\r\n\r\n\\[\r\nf[x_i,x_{i+1},\\cdots,x_n]=\\frac{f[x_{i+1},\\cdots,x_n]-f[x_i,\\cdots,x_{n-1}]}{x_n-x_i},n\\geq\r\n1\r\n\\]\r\n\r\n差商与高阶导数的联系 设\\(f\\in C^n[a,b],x_i,i=0,1,\\cdots,n\\)是\\([a,b]\\)中互异节点,则存在\\(\\xi\\in[a,b]\\)使得,\r\n\r\n\\[\r\nf[x_0,x_1,\\cdots,x_n]=\\frac{f^{(n)}(\\xi)}{n!}\r\n\\]\r\n值得注意的是,如果所有节点\\(x_0,x_1,\\cdots,x_n\\)都重合(认为是一种极限过程),这牛顿差商退化成,\r\n\\[\r\nf[x,x,\\cdots,x]=\\frac{f^{(n)}(x)}{n!}\r\n\\]\r\n进而,Newton插值多项式退化成Taylor多项式. -\r\nLeibniz公式,若\\(f=gh\\)，那么\r\n\\[\r\nf[x_0,x_1,\\cdots,x_n]=\\sum_{j=0}^{n}g[x_0,x_1,\\cdots,x_j]\\cdot\r\nh[x_j,x_1,\\cdots,x_n]\r\n\\]\r\nNewton插值算法\r\n差商表 1. 构建差商表 2. 取对角线\r\nHorner方法 将Newton插值多项式写成嵌套形式\r\nN插值多项式的误差\r\n\\[\r\nR_n(x)=f[x_0,x_1,\\cdots,x_n,\\textbf{x}]\\pi_{n+1}(x)\r\n\\]\r\n证明: 关于\\(x_0,x_1,\\cdots,x_n\\)以及\\(x\\)构造\\(N_{n+1}(x)\\),\r\n\\[\r\nN_{n+1}(t)=N_{n}(t)+f[x_0,x_1,\\cdots,x_n,x]\\pi_{n+1}(t)\r\n\\]\r\n这里我们应该要注意到插值多项式\\(N_{n+1}(t)\\)在\\(t=x\\)处的插值条件就是\r\n\\[\r\nN_{n+1}(x)=f(x)\r\n\\]\r\n因此将式子中的t用x替换,即得,\r\n\\[\r\nN_{n+1}(x)-N_{n}(x)=f[x_0,x_1,\\cdots,x_n,x]\\pi_{n+1}(x)\r\n\\]\r\n\\[\r\nf(x)-N_{n}(x)=f[x_0,x_1,\\cdots,x_n,x]\\pi_{n+1}(x)\r\n\\]\r\n于是,就证明了\\(R_n(x)=f[x_0,x_1,\\cdots,x_n,\\textbf{x}]\\pi_{n+1}(x)\\).\r\n# 差分与等距节点\r\n当插值节点等距的时候,可以对Newton插值多项式进一步化简.为此,我们需要引入差分的概念.\r\n基本概念\r\n差分\r\n定义:设在等距节点\\(x_i=x_o+ih,i=0,1,2,\\cdots,n\\)上,已知函数\\(f(x)\\)的值为\\(y_0,y_1,\\cdots,y_n\\),其中\\(y&gt;0\\)为相邻两个节点的步长.称,\r\n\\[\r\n\\Delta^1f_i=f_{i+1}-f_i,i=0,1,2,\\cdots,n\r\n\\]\r\n\r\n零阶差分 定义为:\\(\\Delta^0f_i=f_i,i=0,1,2,\\cdots,n\\)\r\nm阶向前差分\r\n\r\n\\[\r\n\\Delta^mf_i=\\Delta^{m-1}f_{i+1}-\\Delta^{m-1}f_i=\\Delta^{m-1}(f_{i+1}-f_i)=\\Delta^{m-1}\\Delta^{1}f_i,i=0,1,2,\\cdots,n\r\n\\]\r\n差分性质\r\n\r\n差分与牛顿差商的关系\r\n\r\n\\[\r\nf[x_0,x_1,\\cdots,x_m]=\\frac{\\Delta^mf_0}{m!h^{m}}\r\n\\]\r\n\\[\r\nf[x_i,x_{i+1},\\cdots,x_{i+m}]=\\frac{\\Delta^mf_i}{m!h^{m}}\r\n\\]\r\n\r\n高阶差分与函数值的关系\r\n\r\n\\[\r\n\\Delta^mf_i=\\sum_{j=0}^{m}(-1)^{j}C_{j}^{m}f_{i+m-j}\r\n\\]\r\nNewton向前差分公式\r\n\\[\r\nN_n(x)=\\sum_{i=0}^{n}f[x_0,x_1,\\cdots,x_i]\\pi_i(x)=\\sum_{i=0}^{n}\\frac{\\Delta^if_0}{i!h^{i}}\\pi_i(x)\r\n\\]\r\n再做线性替换\\(x=x_0+th,\\quad 0\\leq t\\leq\r\nn\\),则\\(x-x_i=(t-i)h,i=0,1,2,\\cdots,n\\),上面的公式可以简化为,\r\n\\[\r\nN_n(x_0+th)=\\sum_{i=0}^{n}\\frac{\\Delta^if_0}{i!h^{i}}\\pi_i(x_0+th)=\\sum_{i=0}^{n}\\frac{\\Delta^if_0}{i!h^{i}}\\prod_{j=0}^{i-1}(h(t-j))=\\sum_{i=0}^{n}\\frac{\\Delta^if_0}{i!}\\prod_{j=0}^{i-1}(t-j)\r\n\\]\r\n类似的,可以把插值余项公式简化成,\r\n\\[\r\nR_n(x)=\\frac{h^{n+1}f^{(n+1)}(\\xi_x)}{(n+1)!}\\prod_{j=0}^{n}(t-j)\r\n\\]\r\n注:类似向前差分,我们可以定义向后差分,\r\n\\[\r\n\\nabla^1f_i=f_{i}-f_{i-1}\r\n\\]\r\n有差不多的结论,区别在于,向前差分公式适合在右侧增加节点,向后差分公式则是向左.\r\nHermit插值\r\n满足插值条件和导数条件的插值\r\nHermit插值与前面插值方法最大的区别就是,在插值节点处除了满足插值条件外,还需要满足导数插值条件.\r\n## 几何意义\r\n这种方式构造的插值函数,除了过插值节点外,还保持了在节点处的光滑性 ##\r\n构造H多项式 2.7.3.1 一种构造 2.7.3.2 Newton 插值余项\r\n一般情况下，同次数的尔米特多项式比拉格朗日多项式更精确 #\r\nRunge现象和分段插值\r\n容格现象启示：不要轻易使用高次插值多项式. ## 分段插值\r\n主要思想是将插值区间划分成一个个小区间,在每个小区间上用低次的插值多项式逼近函数.\r\n最简单的一种方法就是分段线性插值.\r\n分段线性插值\r\n分段插值的几何意义就是:在每个小区间内用直线段连起来.\r\n定义:(分段插值函数)\r\n函数空间维数\r\n2.8.2.1.1 自由度条件 2.8.2.1.2 连续性条件 ###\r\n分段线性插值多项式具有一致收性\r\n分段线性和分段三次hermit插值\r\n样条插值\r\n弹性势能最小的插值方式，稳定性很好\r\n分段线性插值多项式的光滑性差,只有连续性.\r\n而分段3次Hermit插值具有一阶可导性,但是要知道节点处的导数值才行.\r\n3次样条插值多项式\r\n定义: 设\\(f(x)\\)为定义在区间\\([a,b]\\)内的函数,已知\\(f(x)\\)在区间\\([a,b]\\)内的\\(n+1\\)个互异的点\\(a\\leq x_0&lt;x_1&lt;\\cdots&lt;x_n\\leq\r\nb\\)处的函数值为\\(y(x_i)=y_i,i=0,\\cdots,n\\).设\\(s_3(x)\\)是定义在区间\\([a,b]\\)上的函数,若\\(s(x)\\)满足以下条件, -\r\n(局部性质)\\(s(x)\\)在每个小区间\\([x_i,x_{i+1}],i=0,\\cdots,n-1\\)内是次数不超过3次的多项式\r\n- (插值条件)\\(s(x)\\)满足插值条件\\(s(x_i)=y_i,i=0,\\cdots,n\\) -\r\n(整体性质)\\(s(x)\\)是插值区间上的二阶连续可导函数\r\n则称\\(s(x)\\)是插值区间内的3次样条插值函数,简称3次样条.\r\n定义如下函数空间\r\n\\[\r\nS^{2,3}=\\{s\\in C[a,b]|s_{I_i}\\in\r\nP_3(I_i),I_i=[x_i,x_{i+1}],i=0,\\cdots,n-1]\\}\r\n\\]\r\n该空间的维度为\\(4n-(3n-3)=n+3\\),即3次样条自由度为\\(n+3\\),插值条件提供了\\(n+1\\)个自由度,于是发现,我们还需要额外的两个自由度.\r\n边界条件\r\n由于求解仍缺少两个自由度,而缺少的只能由插值区间\\([a,b]\\)的两个端点给出,我们称由端点给出的条件为边界条件.\r\n边界条件通常有三类: - 自然边界条件\r\n\\[\r\ns&#39;&#39;(x_0)=s&#39;&#39;(x_n)=0\r\n\\]\r\n这样构造的样条称为自然样条. - 固支边界条件\r\n\\[\r\ns&#39;&#39;(x_0)=y&#39;_0\\quad s&#39;&#39;(x_n)=y&#39;_n\r\n\\]\r\n固支边界条件包含了更多信息,通常比自然条件更精确,\r\n这样构造的样条称为固支样条. - 循环边界条件\r\n\\[\r\ns(x_0)=s(x_n)\r\n\\]\r\n\\[\r\ns&#39;(x_0)=s&#39;(x_n)\r\n\\]\r\n\\[\r\ns&#39;&#39;(x_0)=s&#39;&#39;(x_n)\r\n\\]\r\n这样构造的样条称为周期样条.\r\n三次样条的构造\r\n三弯矩构造法(解线性方程组)\r\n三弯矩构造法利用3次样条在内部节点上的二阶连续可导性化简计算,将问题化简为求解线性方程组.\r\n构造过程: 记3次样条在节点处的二阶导数值为\\(M_i=s&#39;&#39;(x_i),i=0,\\cdots,n\\).由于\\(s&#39;&#39;(x)\\)在每个小区间上都是一次多项式,故有,\r\n\\[\r\ns&#39;&#39;_i(x)=\\frac{x_{i+1}-x}{h_i}M_i+\\frac{x-x_{i}}{h_i}M_{i+1}\r\n\\]\r\n其中\\(h_i=x_{i+1}-x_i\\),将上面的式子积分两次,有\r\n留空（）\r\n总之利用完插值条件和一阶连续可导的条件后,得到,\r\n\\[\r\n\\mu_{i+1}M_i+2M_{i+1}+\\lambda_{i+1}M_{i+2}=d_{i+1}\r\n\\]\r\n其中\r\n\\[\r\n\\begin{cases}\r\n\\mu_{i+1}=\\frac{h_i}{h_i+h_{i+1}}\\\\\r\n\\\\\r\n\\lambda_{i+1}=\\frac{h_{i+1}}{h_i+h_{i+1}}\\\\\r\n\\\\\r\nd_{i+1}=6f[x_i,x_{i+1},x_{i+2}]\r\n\\end{cases}\r\n\\]\r\n接下来考虑边界条件 (1) 自然边界 即已知\\(M_0=M_n=0\\),所以得到的线性方程组为,\r\n(2) (3)\r\nB样条构造法(基函数)\r\n多元插值方法\r\n","categories":["Math","数值逼近"],"tags":["数值逼近"]},{"title":"对偶问题和对偶理论","url":"/2023/05/21/%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98%E5%92%8C%E5%AF%B9%E5%81%B6%E7%90%86%E8%AE%BA/","content":"对偶问题\r\n对偶的含义\r\n这里的对偶是指对同一事物(问题)从不同的角度(立场)观察,有两种拟似对立的表述。如“平面中矩形的面积与周长的关系”。可分别表述为：周长一定，面积最大的矩形是正方形；面积一定,周长最短的矩形是正方形。又如同一个数据集的线性规划问题,可以有两种优化的表述：一个企业决策者做生产规划时，可以提出最大利润为目标函数；也可以提出以最小资源消耗为目标。\r\n对偶问题的一般形式\r\n原问题 \\[\r\n\\begin{array}{c}\r\n\\max z=c_{1} x_{1}+c_{2} x_{2}+\\cdots+c_{n} x_{n} \\\\\r\n{\\left[\\begin{array}{cccc}\r\na_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1 n} \\\\\r\n\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\\r\na_{m 1} &amp; a_{m 2} &amp; \\cdots &amp; a_{m n}\r\n\\end{array}\\right]\\left[\\begin{array}{c}\r\nx_{1} \\\\\r\nx_{2} \\\\\r\n\\vdots \\\\\r\nx_{n}\r\n\\end{array}\\right] \\leqslant\\left[\\begin{array}{c}\r\nb_{1} \\\\\r\n\\vdots \\\\\r\nb_{m}\r\n\\end{array}\\right]} \\\\\r\nx_{1}, x_{2}, \\cdots, x_{n} \\geqslant 0\r\n\\end{array}\r\n\\] 对偶问题 \\[\r\n\\begin{array}{c}\r\n\\min \\omega=y_{1} b_{1}+y_{2} b_{2}+\\cdots+y_{m} b_{m} \\\\\r\n\\left(y_{1}, y_{2}, \\cdots, y_{m}\\right)\\left[\\begin{array}{cccc}\r\na_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1 n} \\\\\r\n\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\\r\na_{m 1} &amp; a_{m 2} &amp; \\cdots &amp; a_{m n}\r\n\\end{array}\\right] \\geqslant\\left(c_{1}, c_{2}, \\cdots, c_{n}\\right) \\\\\r\ny_{1}, y_{2}, \\cdots, y_{m} \\geqslant 0\r\n\\end{array}\r\n\\] 以上是原问题与对偶问题的标准形式。\r\n\r\n原问题收益最大化=maxz→对偶问题代价最小化(min w)\r\n原问题方程个数=资源种类数→对偶问题的决策变量数\r\n原问题的价值系数=原有收益（c向量）→对偶问题约束条件右端项向量\r\n原问题的资源约束=资源个数（b向量）→对偶问题的价值系数\r\n\r\n基本性质\r\n弱对偶性\r\n弱对偶性：若 \\(\\mathbf{X}\\)\r\n是原问题的可行解， \\(\\mathbf{Y}\\)\r\n是对偶问题可行解，则恒有： \\[\r\n\\mathbf{C X} \\leq \\mathrm{Y}^{\\mathrm{T}} \\mathbf{b}\r\n\\]\r\n证: 已知条件为: 有： \\(\\mathbf{Y}^{\\mathbf{T}} \\mathbf{b} \\geq\r\n\\mathbf{Y}^{\\mathrm{T}} \\mathbf{A X} \\geq \\mathbf{C X}\\)\r\n，得证\r\n根据弱对偶性，我们得到如下推论: -\r\n原问题最优解目标函数值是对偶问题目标函数值的下界， -\r\n对偶问题最优解目标函数值是原问题目标函数值的上界。 -\r\n原问题有无界解，则对偶问题无可行解，反之亦然\r\n即对偶问题有无界解，则原问题无可行解，但逆不成立\r\n， 对偶问题无可行解时，原问题也可能无可行解。 -\r\n原问题有可行解而对偶问题无可行解，则原问题为无界解，反之亦然。\r\n强对偶性\r\n\r\n影子价格\r\n对偶单纯形法\r\n","categories":["Math","运筹"],"tags":["运筹学"]},{"title":"报告","url":"/2023/02/18/%E6%8A%A5%E5%91%8A/","content":"实验一\r\n题目摘要\r\n\r\n\r\n92121416f71acd201a329cdec03cb1d3.png\r\n\r\n意义和目的\r\n计算希尔伯特矩阵的无穷范数的条件数，从而知道希尔伯特矩阵是“病态的”。\r\n数学原理\r\n条件数是线性方程组Ax=b的解对b中的误差或不确定度的敏感性的度量。数学定义为矩阵A的条件数等于A的范数与A的逆的范数的乘积，即cond(A)=‖A‖·‖A的逆‖，对应矩阵的3种范数，相应地可以定义3种条件数。\r\n条件数事实上表示了矩阵计算对于误差的敏感性。对于线性方程组Ax=b，如果A的条件数大，b的微小改变就能引起解x较大的改变，数值稳定性差。如果A的条件数小，b有微小的改变，x的改变也很微小，数值稳定性好。它也可以表示b不变，而A有微小改变时，x的变化情况。\r\n## 程序设计流程 # 试估计 5 至 20 阶Hilbert 矩阵的无穷范数条件数import numpy as npnp.set_printoptions(suppress=True)# 希尔伯特矩阵def H(n):    H = np.zeros((n, n))    for i in range(n):        for j in range(n):            H[i,j] = 1/(i+j+1)    return H#无穷范数def norm(H):    nm = 0    l = len(H)    for i in range(l):        sum = 0        for j in range(l):            sum = sum + abs(H[i,j])        if nm &lt;= sum:            nm = sum    return nmN = [5,10,15,20]for n in N:    H1 = H(n)    HI = np.linalg.inv(H1)    cond = norm(H1)*norm(HI)    print(n,&#x27;阶Hilbert 矩阵的条件数为：&#x27;,cond)    #print(np.linalg.cond(H1,p=np.inf)) 这条用来验证\r\n实验结果和讨论\r\n高阶希尔伯特矩阵的条件数非常大。\r\n\r\n\r\nd5f06d0a4bd8e4e95ffb8f566167156a.png\r\n\r\n实验二\r\n题目摘要\r\n\r\n\r\n04016e99a3ea21ebad22b76737d5383a.png\r\n\r\n意义和目的\r\n追赶法适用于三对角矩阵，可以有效减少计算量。 ## 数学原理\r\n追赶法的基本原理是矩阵的LU分解，即将矩阵A 分解为 \\[\r\nA=LU\r\n\\] 其中，L为一个对角线上元素为1的下三角矩阵，U为一个上三角矩阵.\r\n容易验证，一个三对角矩阵作LU分解以后，得到一个下二对角矩阵与一个上二对角矩阵的乘积。\r\n## 程序设计流程 # 用追赶法解三对角方程组import numpy as npA = np.array([[2, -1, 0, 0, 0],              [-1, 2, -1, 0, 0],              [0, -1, 2, -1, 0],              [0, 0, -1, 2, -1],              [0, 0, 0, -1, 2]])b = np.array([1, 0, 0, 0, 0])# 左乘A逆print(&#x27;传统方法：&#x27;, np.linalg.inv(A).dot(b))# 追赶法X0 = np.diag(A)X1 = np.diag(A,1)X1 = np.insert(X1,0,0)X2 = np.diag(A,-1)X2 = np.insert(X2,0,0)#print(X0,X1,X2) #测试用n = len(A)alpha = np.zeros(n)beta = np.zeros(n-1)beta[0] = X1[1]/X0[0]X = np.zeros(n)Y = np.zeros(n)for i in range(1,n-1): #LU分解相关计算    beta[i] = X1[i]/(X0[i]-X2[i]*beta[i-1])for i in range(0,n): #追    if i == 0:        Y[i] = b[i]/X0[i]        continue    Y[i] = (b[i]-X2[i]*Y[i-1])/(X0[i]-X2[i]*beta[i-1])for i in range(n-1,-1,-1): #赶    if i == n-1:        X[i] = Y[i]        continue    X[i] = Y[i] - beta[i]*X[i+1]print(&#x27;追赶法：&#x27;, X)\r\n实验结果和讨论\r\n如果在代码中加入计录运行时间的代码，应该可以发现两种运算方式在速度上的区别，但是由于计算阶数较小，差别不会很明显。\r\n\r\n\r\n218069d12964700cadf7e4db4f0f3ba0.png\r\n\r\n实验三\r\n题目摘要\r\n \r\n意义和目的\r\n利用 Gauss 列主元消去法、显式相对 Gauss 列主元消去法求解线性方程组。\r\n## 数学原理\r\n如果系数矩阵的元素按绝对值在数量级方面相差很大，那么，在进行列主元消元过程前，先把系数矩阵的元素进行行平衡：系数矩阵的每行元素和相应的右端向量元素同除以该行元素绝对值最大的元素。这就是所谓的平衡技术。然后再进行列主元消元过程。\r\n如果真正进行运算去确定相对主元，则称为显式相对\r\nGauss列主元消去法；如果不进行运算，也能确定相对主元，则称为隐式相对\r\nGauss 列主元消去法。\r\n显式相对 Gauss 列主元消去法：对给定的n阶线性方程组 \\(Ax=b\\)首先进行列主元消元过程，在消元过程中利用显式平衡技术，然后进行回代过程，最后得到解或确定该线性方程组是奇异的。\r\n程序设计流程\r\n# Gauss 列主元消元法import numpy as npimport copynp.set_printoptions(precision=8)np.set_printoptions(suppress=False)def swap(a, b, k, j): # 用来交换矩阵的行向量    tmp = copy.deepcopy(a[:,k])    a[:,k] = a[:,j]    a[:,j] = tmp    tmp = copy.deepcopy(b[k])    b[k] = b[j]    b[j] = tmp    return a,bdef select(A,k):    X = list(A[k])    j = X.index(max(A[k]))    return k, j#Gauss 列主元def gauss(a, b):    n = len(b)    for k in range(n):              #k表示迭代次数        if a[k,k] == 0:             #防止出现0做分母            k, j = select(a,k)                                swap(a, b, k, j)                   # k, j = select(a,k)          #选列主元                  # swap(a, b, k, j)           #交换列主元        for i in range(k+1, n):               l = a[i,k] / a[k,k]                          a[i,:] = a[i,:] - l * a[k,:]             b[i] = b[i] - l *b[k]         #     print(a,b)        # print(&#x27;------------&#x27;)     # 回代求解    x = np.zeros(n)    x[n-1] = b[n-1] / a[n-1, n-1] #先算最后一位的x解    for i in range(n-2, -1, -1):      #依次回代倒着算每一个解        for j in range(i+1, n):            b[i] -= a[i,j] * x[j]        x[i] = b[i] / a[i,i]    # for i in range(n):              # 输出每个分量    #     print(&quot;x&quot; + str(i + 1) + &quot; = &quot;, x[i])     print(&quot;Gauss法:x&quot; &quot; = &quot;, x)# A = np.array([[0.4096, 0.1234, 0.3678, 0.2943], #             [0.2246, 0.3872, 0.4015, 0.1129], #             [0.3645, 0.1920, 0.3781, 0.0643],#             [0.1784, 0.4002, 0.2786, 0.3927]])# b = np.array([1.2951, 1.1262, 0.9989, 1.2499])A = np.array([[10, 7, 8, 7],             [7, 5, 6, 5],             [8, 6, 10, 9],            [7, 5, 9, 10]],dtype=float)b = np.array([32, 23, 33, 31],dtype=float)# print(np.linalg.cond(A, p=np.inf))print(&#x27;传统方法：&#x27;, np.linalg.inv(A).dot(b))gauss(A, b)\r\n实验结果和讨论\r\n\r\n\r\n14d2b5b8d15769e84e333af5a439dd85.png\r\n\r\n由于顺序消去法会因为的值过小而引入计算误差，为了减少计算过程中舍入误差对方程组求解的影响，因此是否可以选择绝对值尽可能大的主元作为除数。\r\n","categories":["Math","数值代数"],"tags":["数值代数"]},{"title":"数值积分","url":"/2022/11/12/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86/","content":"引言\r\n数值积分的概念\r\n基本思想\r\n数值积分的基本思想是：用多项式函数\\(p\\)去逼近函数\\(f\\),然后用近似多项式的积分值去代替原来函数的积分值.\r\n\\[\r\n\\int_{a}^{b}f\\,dx\\approx\\int_{a}^{b}p\\,dx\r\n\\]\r\n&lt;______________________假装是图片_______________________________&gt;\r\n最常用的逼近多项式就是前面所学的插值多项式.\r\n\\[\r\n\\int_{a}^{b}f\\,dx\\approx\\sum_{i=0}^{n}A_if(x_i)=I_n(f)\r\n\\] - \\(A_i\\)为求积系数,它只与节点选取有关,与函数\\(f\\)无关. - \\(I_n(f)\\)为数值求积公式.\r\n代数精度\r\n定义: 如求积公式对被积函数\\(f(x)=1,x,\\cdots,x^m\\)都能精确成立,即 \\[\r\n\\int_{a}^{b}f\\,dx=\\sum_{i=0}^{n}A_if(x_i)=I_n(f)\r\n\\] 但对\\(f(x)=x^{m+1}\\)不能精确成立,即 \\[\r\n\\int_{a}^{b}x^{m+1}\\,dx\\neq\\sum_{i=0}^{n}A_ix^{m+1}_i\r\n\\] 则称求积公式有\\(m\\)次代数精度.\r\n若 \\[\r\nI_n(f)=\\sum_{i=0}^{n}A_if(x_i)\r\n\\] 具有\\(n\\)次代数精度,问:\\(A_i=?\\) 实际上,分别令\\(f=1,x,\\cdots,x^n\\),有 \\[\r\n\\int_{a}^{b}f\\,dx=\\sum_{i=0}^{n}A_if(x_i)=I_n(f)\r\n\\] 将这\\(n+1\\)个方程写成线性方程组的形式, \\[\r\n\\left(\\begin{array}{cccc}\r\n1 &amp; 1 &amp; \\cdots &amp; 1 \\\\\r\nx_{0} &amp; x_{1} &amp; \\cdots &amp; x_{n} \\\\\r\n\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\\r\nx_{0}^{n} &amp; x_{1}^{n} &amp; \\cdots &amp; x_{n}^{n}\r\n\\end{array}\\right)\\left(\\begin{array}{c}\r\nA_{0} \\\\\r\nA_{1} \\\\\r\n\\vdots \\\\\r\nA_{n}\r\n\\end{array}\\right)=\\left(\\begin{array}{c}\r\nb-a \\\\\r\n\\frac{b^{2}-a^{2}}{2} \\\\\r\n\\vdots \\\\\r\n\\frac{b^{n+1}-a^{n+1}}{n+1}\r\n\\end{array}\\right)\r\n\\] 由于这\\(n+1\\)个节点互异,所以求积系数\\(A_i\\)是存在且唯一的.通过解上面的线性方程组得到求积系数的方法被称为待定系数法.\r\n结合上面的描述,我们可以很容易得到下面的定理. 定理:\r\n给定\\(n+1\\)个互异节点,那么总存在相应的求积系数\\(A_i\\)使得求积公式 \\[\r\n\\sum_{i=0}^{n}A_if(x_i)=I_n(f)\r\n\\] 至少具有\\(n\\)次的代数精度.\r\n插值型求积公式\r\n基本想法: \\[\r\nf(x)\\approx L_n(x)=\\sum_{i=0}^{n}l_{i,n}f(x_i)\\\\\r\n\\int_{a}^{b}f(x)\\,dx\\approx\\int_{a}^{b}\\sum_{i=0}^{n}l_{i,n}f(x_i)\\,dx=\\sum_{i=0}^{n}\\int_{a}^{b}l_{i,n}(x)\\,dxf(x_i)\r\n\\]\r\n定义: 若 \\[\r\n\\sum_{i=0}^{n}A_if(x_i)=I_n(f)\r\n\\] 其中, \\[\r\nA_i=\\int_{a}^{b}l_{i,n}(x)\\,dx\r\n\\] 则称\\(I_n(x)\\)为插值型求积公式.\r\n误差: \\[\r\n\\begin{split}\r\nR_n(f)&amp;=\\int_{a}^{b}f(x)\\,dx-\\int_{a}^{b}l_{i,n}(x)\\,dx\\\\\r\n&amp;=\\int_{a}^{b}(f(x)-l_{i,n}(x))\\,dx\\\\\r\n&amp;=\\int_{a}^{b}\\frac{f^{(n+1)}{(\\xi_n)}}{(n+1)!}\\pi_{n+1}(x)\\,dx\r\n\\end{split}\r\n\\]\r\n定理: 求积公式 \\[\r\n\\sum_{i=0}^{n}A_if(x_i)=I_n(f)\r\n\\] 为插值型求积公式的充要条件为:\\(I_n(x)\\)至少具有n次代数精度.\r\nProof: (必要性) (充分性)\r\nNewton-Cotes 求积公式\r\n节点为等距节点 \\[\r\nx_i=x_0+ih,\\quad h=\\frac{b-a}{n}\r\n\\] 变形, \\[\r\n\\begin{split}\r\n    I_n(f)&amp;=\\sum_{i=0}^{n}A_if(x_i)\\\\\r\n    &amp;=(b-a)\\sum_{i=0}^{n}\\frac{A_i}{b-a}f(x_i)\\\\\r\n    &amp;=(b-a)\\sum_{i=0}^{n}C_{i,n}f(x_i)\\\\\r\n\\end{split}\r\n\\] 由\\(x=x_0+th,(0\\leq t\\leq\r\nn)\\),可知, \\[\r\n\\begin{split}\r\n    C_{i,n}&amp;=\\frac{1}{b-a}A_i\\\\\r\n    &amp;=\\frac{1}{b-a}\\int_{a}^{b}l_{i,n}(x)\\,dx\\\\\r\n    &amp;=\\frac{1}{b-a}\\int_{a}^{b}\\prod^{n}_{j=0,i\\neq\r\ni}\\frac{x-x_j}{x_i-x_j}\\,dx\\\\\r\n    &amp;=\\frac{1}{b-a}\\int_{a}^{b}\\prod^{n}_{j=0,i\\neq\r\ni}\\frac{t-j}{i-j}h\\,dx\\\\\r\n    &amp;=\\frac{h}{b-a}\\int_{a}^{b}\\prod^{n}_{j=0,i\\neq\r\ni}\\frac{t-j}{i-j}\\,dx\\\\\r\n    &amp;=\\frac{1}{n}\\int_{a}^{b}\\prod^{n}_{j=0,i\\neq\r\ni}\\frac{t-j}{i-j}\\,dx\\\\\r\n\\end{split}\r\n\\] 而\\(C_{i,n}\\)被称为Cotes系数(只与\\(i,n\\)有关) 当\\(n=1\\)时, \\[\r\nC_{0,1}=\\frac{1}{2},C_{1,1}=\\frac{1}{2}\\\\\r\nI_1(f)=(b-a)(\\frac{f(b)+f(a)}{2})\r\n\\] 称为梯形公式. 当\\(n=2\\)时,\r\n\\[\r\nC_{0,2}=\\frac{1}{6},C_{1,2}=\\frac{4}{6},C_{2,2}=\\frac{1}{6}\\\\\r\nI_1(f)=(b-a)(\\frac{f(b)+f(a)+4f(\\frac{a+b}{2})}{6})\r\n\\] 称为Simpson(辛普森)求积公式.\r\nCotes系数的性质:\r\n\r\nCotes系数的代数和为1 \\[\\sum_{i=0}^{n}C_{i,n}=1 \\]\r\n由于NC求积公式至少具有\\(n\\)阶代数精度,\r\n\\[Let\\ f(x)\\equiv 1,so\\,we\\,have\\\\\r\n\\int_{a}^{b}f(x)\\,dx=b-a=(b-a)\\sum_{i=0}^{n}C_{i,n}f(x_i)=(b-a)\\sum_{i=0}^{n}C_{i,n}\\]\r\n中心对称性质. \\[C_{i,n}=C_{n-i,n}\r\n\\]\r\n\r\nNewton-Cotes 公式的误差\r\nSimpson求积公式具有3次代数精度.\r\n定理:\r\nNewton-Cotes公式当n为奇数时,有n次代数精度;当n为偶数时,有n+1次代数精度.\r\nProof:\r\nn为奇数,显然.\r\nn为偶数.\\(f(x)=x^{n+1}\\) \\[\r\n\\begin{split}\r\n    &amp;\\int_{a}^{b}f(x)\\,dx-(b-a)\\sum_{i=0}^{n}C_{i,n}f(x_i)\\\\\r\n    &amp;=\\int_{a}^{b}[f(x)-L_n(x)]\\,dx\\\\\r\n    &amp;=\\int_{a}^{b}\\frac{f^{(n+1)}(\\xi)}{(n+1)!}\\pi_{n+1}(x)\\,dx\\\\\r\n    &amp;=\\int_{a}^{b}\\frac{(n+1)!}{(n+1)!}\\pi_{n+1}(x)\\,dx\\\\\r\n    &amp;=\\int_{a}^{b}\\pi_{n+1}(x)\\,dx\\\\\r\n    &amp;=\\int_{a}^{b}(x-x_0)\\cdots(x-x_n)\\,dx\r\n\\end{split}\r\n\\] 由于是等距节点,所以有,！！！！！！！！！！！！！！！！！！！！\r\n\\[\r\n\\begin{split}\r\n    &amp;\\int_{a}^{b}\\pi_{n+1}(x)\\,dx\\\\\r\n    &amp;=\\int_{a}^{b}(x-x_0)\\cdots(x-x_n)\\,dx\\\\\r\n    &amp;=\\int_{a}^{b}(x-x_0)\\cdots(x-x_n)\\,dx\r\n\\end{split}\r\n\\]\r\nNewton-Cotes公式的稳定性\r\n定义:(数值稳定性)\r\n定理: 数值求积公式\\(I_n(f)=\\sum_{i=0}^{n}A_if(x_i)\\)为数值稳定的充分必要条件是:\\(A_i\\geq 0,i=0,\\cdots,n\\).\r\nProof\r\n\\[\r\n\\forall\r\n\\epsilon&gt;0,\\qquad|\\sum_{i=0}^{n}A_if(x_i)-\\sum_{i=0}^{n}{A_i}\\tilde{f}(x_i)|\\leq\r\n\\sum_{i=0}^{n}|A_if(x_i)-\\sum_{i=0}^{n}{A_i}\\tilde{f}(x_i)|\\\\ \\leq\r\nM\\sum_{i=0}^{n}{A_i}&lt;\\epsilon,as\\ long\\ as\\\r\nM&lt;\\delta=\\frac{\\epsilon}{\\sum_{i=0}^{n}{A_i}}\r\n\\]\r\n复合求积公式\r\n为了避免高阶求积公式的弊端，就要用到插值中的分段思想，即把积分区间分段，再在各个区间上应用低阶的求积公式，称为复合求积公式。\r\n复合梯形求积公式\r\n\\[\r\n\\begin{split}\r\n    \\int_{a}^{b}f(x)\\,dx&amp;=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx\\\\\r\n    &amp;\\approx\\sum_{i=0}^{n-1}\\frac{x_{i+1}-x_i}{2}(f(x_i)+f(x_{i+1}))\r\n\\end{split}\r\n\\]\r\n特别地，考虑等距节点的情况，间距为\\(h\\), \\[\r\n\\begin{split}\r\n    \\int_{a}^{b}f(x)\\,dx&amp;=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx\\\\\r\n    &amp;\\approx \\frac{h}{2}(f(x_0)+2\\sum_{i=1}^{n-1}f(x_i)+f(x_n))\r\n\\end{split}\r\n\\]\r\n复合梯形求积公式的误差\r\n上面得出的复合梯形求积公式记为\\(T_n(x)\\).\r\n\\[\r\n\\begin{split}\r\n    \\Big|\\int_{a}^{b}f(x)\\,dx-T_n(x)\\Big|&amp;=\\Big|\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx-T_n(x)\\Big|\\\\\r\n    &amp;=\\Big|\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx-\\sum_{i=0}^{n-1}\\frac{x_{i+1}-x_i}{2}(f(x_i)+f(x_{i+1}))\\Big|\\\\\r\n    &amp;\\leq\r\n\\sum_{i=0}^{n-1}\\Big|\\int_{x_i}^{x_i+1}f(x)\\,dx-\\frac{x_{i+1}-x_i}{2}(f(x_i)+f(x_{i+1}))\\Big|\\\\\r\n    &amp;=\\sum_{i=0}^{n-1}\\Big|+\\frac{(x_{i+1}-x_i)^3}{12}f&#39;&#39;(\\xi_i)\\Big|\\\\\r\n    &amp;=\\frac{M}{12}\\sum_{i=0}^{n-1}\\Big|(x_{i+1}-x_i)^3\\Big| \\qquad\r\nM=\\max{f&#39;&#39;(\\xi_i)}\\\\\r\n    &amp;=\\frac{M}{12}h^3\\sum_{i=0}^{n-1}(1) \\qquad\r\nh=\\max{(x_{i+1}-x_i)}\\\\\r\n    &amp;=\\frac{M}{12}h^2(hn)=\\frac{M}{12}h^2(b-a)\\qquad\r\nif\\  nodes\\  spaced\\  equally\r\n\\end{split}\r\n\\]\r\n复合Simpson求积公式\r\n\\[\r\n\\begin{split}\r\n    \\int_{a}^{b}f(x)\\,dx&amp;=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx\\\\\r\n    &amp;\\approx\\sum_{i=0}^{n-1}\\frac{x_{i+1}-x_i}{6}(f(x_i)+4f(\\frac{x_i+x_{i+1}}{2})+f(x_{i+1}))\r\n\\end{split}\r\n\\]\r\n特别地，考虑等距节点的情况，间距为\\(h\\), \\[\r\n\\begin{split}\r\n    \\int_{a}^{b}f(x)\\,dx&amp;=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx\\\\\r\n    &amp;\\approx\r\n\\frac{h}{6}(f(x_0)+2\\sum_{i=1}^{n-1}f(x_i)+f(x_n)+4\\sum_{i=1}^{n-1}f(\\frac{x_i+x_{i+1}}{2}))\r\n\\end{split}\r\n\\]\r\n复合Simpson求积公式的误差\r\n上面得出的复合Simpson求积公式记为\\(S_n(x)\\).\r\n\\[\r\n\\begin{split}\r\n    &amp;\\Big|\\int_{a}^{b}f(x)\\,dx-S_n(x)\\Big|\\\\\r\n    &amp;=\\Big|\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx-S_n(x)\\Big|\\\\\r\n    &amp;=\\Big|\\sum_{i=0}^{n-1}\\int_{x_i}^{x_i+1}f(x)\\,dx-\\sum_{i=0}^{n-1}\\frac{x_{i+1}-x_i}{6}(f(x_i)+4f(\\frac{x_i+x_{i+1}}{2})+f(x_{i+1}))\\Big|\\\\\r\n    &amp;\\leq\r\n\\sum_{i=0}^{n-1}\\Big|\\int_{x_i}^{x_i+1}f(x)\\,dx-\\frac{x_{i+1}-x_i}{6}(f(x_i)+4f(\\frac{x_i+x_{i+1}}{2})+f(x_{i+1}))\\Big|\\\\\r\n    &amp;=\\sum_{i=0}^{n-1}\\Big|-\\frac{(x_{i+1}-x_i)^5}{2880}f^{(4)}(\\xi_i)\\Big|\\\\\r\n    &amp;=\\frac{M}{2880}\\sum_{i=0}^{n-1}\\Big|(x_{i+1}-x_i)^5\\Big| \\qquad\r\nM=\\max{f^{(4)}(\\xi_i)}\\\\\r\n    &amp;=\\frac{M}{2880}h^5\\sum_{i=0}^{n-1}(1) \\qquad\r\nh=\\max{(x_{i+1}-x_i)}\\\\\r\n    &amp;=\\frac{M}{2880}h^4(hn)=\\frac{M}{2880}h^4(b-a)\\qquad\r\nif\\  nodes\\  spaced\\  equally\r\n\\end{split}\r\n\\]\r\nRichardson 外插值法和Romberg\r\n算法\r\n上一节得到了复合求积公式，通过外插值方法可以进一步提高复合求积公式的效率，即由低阶求积公式构造高阶求积公式。\r\nRichardson 外插值法\r\n通项公式\r\n\\[\r\n\\begin{cases}\r\n    R(j,0)=\\Phi(\\frac{h}{2^j}),\\quad j\\geq 0\\\\\r\n    \\\\\r\n    R(j,k)=\\frac{2^kR(j,k-1)-R(j,k-1)}{2^{k}-1},\\quad j\\geq k&gt; 0\r\n\\end{cases}\r\n\\]\r\nRomberg 算法\r\nEuler-Maclaurin展开式\r\n设\\(f\\in C^{2m}([a,b])\\)，那么，\r\n\\[\r\n\\begin{split}\r\n    \\int_{a}^{b}f(x)\\,dx-T_n(f)&amp;=\\sum_{r=1}^{n-1}C_rh^{2r}[f^{(2r-1)}(b)-f^{(2r-1)}(a)]+O(h^{2r})\\\\\r\n    &amp;C_r=\\frac{}{}\r\n\\end{split}\r\n\\]\r\n注意，当\\(f\\)为周期函数时，\r\n\\[\r\n\\begin{split}\r\n    f(b)&amp;=f(a)\\\\\r\n    f^{(2r-1)}(b)&amp;=f^{(2r-1)}(a)\\\\\r\n    \\int_{a}^{b}f(x)\\,dx-T_n(f)&amp;=O(h^{2r})\\\\\r\n\\end{split}\r\n\\]\r\n精度已经很高了.\r\n梯形加速公式\r\nSimpson加速公式\r\nRomberg 算法的误差\r\n定理：设\\(f\\in\r\nC^{2m+2}([a,b])\\)，那么Romberg 算法的误差估计为：\r\n\\[\r\n\\int_{a}^{b}f(x)\\,dx-T_k^m(f)=O(h^{2m+2}),\\qquad k\\geq 0,m\\geq 0\r\n\\]\r\nRomberg 算法的数值稳定性\r\n定理：若Romberg 算法可以展开为\r\n\\[\r\nT_k^m(f)=\\sum_{i=0}^{2^k}c_{i,m}f(x_i),\\qquad k\\geq m,m=1,2\\cdots\r\n\\]\r\n则所有系数\\(c_{i,m}\\)为正数。\r\nGauss 求积公式\r\n为了简化处理过程,前面都是使用的等距节点作为求积节点,实际上,节点的选取也会影响代数精度.本节将介绍具有更高代数精度的求积方法.\r\n考虑定积分 \\[\r\n\\int_{a}^{b}\\rho(x)f(x)\\,dx\\approx\\sum_{i=0}^{n}A_{i}f(x_i)\r\n\\]\r\n定理: 求积公式\\(\\sum_{i=0}^{n}A_{i}f(x_i)\\)的代数精度最高不超过\\(2n+1\\).\r\nProof: 只要找到一个\\(2n+2\\)次的多项式求积公式,求积公式不能精确成立.\r\n设 \\[\r\np(x)=\\pi_(n+1)^2(x)=\\prod_{i=0}^{n}(x-x_i)\\in P_{2n+2}\r\n\\]\r\n\\[\r\n\\int_{a}^{b}\\rho(x)p(x)\\,dx=\\int_{a}^{b}\\rho(x)\\prod_{i=0}^{n}(x-x_i)\\,dx&gt;0\r\n\\]\r\n令一方面,\r\n\\[\r\n\\sum_{i=0}^{n}A_{i}p(x_i)=0\r\n\\]\r\n故,求积公式对\\(p(x)\\)不能精确成立.\r\n定义: 若由一组节点\\(x_i,i=0,\\cdots,n\\)使得\\(\\sum_{i=0}^{n}A_{i}f(x_i)\\)具有\\(2n+1\\)次代数精度,则称这组节点为Gauss点,相应的求积公式为Guass求积公式.\r\n常用Gauss求积公式\r\n\r\nGauss-Legendre 求积公式\r\nGauss-Chebyshev 求积公式\r\n\r\nGauss 求积公式的误差估计\r\n","categories":["Math","数值逼近"],"tags":["数值逼近"]},{"title":"计算机网络概述","url":"/2023/05/15/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%BD%91%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"\r\n基本概念\r\n体系结构、网络协议和网络设备\r\n网络系统的分析、设计和应用\r\n\r\n` RTT：往返传播时延\r\n计算机网络概述\r\n概念、组成、功能、分类\r\n概念和功能\r\n计算机网络:是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。\r\n计算机网络的功能： - 资源共享 - 数据通信 - 分布式处理 - 提高可靠性 -\r\n负载均衡\r\n因特网发展阶段： ARPAnet -internet→lnterne 三级结构的因特网\r\n多层次ISP结构的因特网\r\n计算机网络的组成\r\n组成部分：硬件、软件、协议（一系列规则和约定的集合）\r\n工作方式： - 边缘部分\r\n用户直接使用：C/S方式；B/S方式；P2P方式（对等连接） - 核心部分\r\n为边缘部分服用\r\n功能组成： - 通信子网：通信子网\r\n(各种传输介质、通信设备、相应的网络协议组成) - 资源子网：资源子网\r\n(实现资源共享功能的设备和软件的集合)\r\n计算机网络的分类\r\n按分布范围分： 广域网WAN、城域网MAN、局域网LAN、个人区域网PAN\r\n（交换技术） （广播技术）\r\n按使用者分： 公用网、专用网\r\n按交换技术分： 电路交换、 报文交换、分组交换 （占用释放）\r\n（存储转发）\r\n按拓扑结构分： 总线型、星型、环型、网型\r\n按传播技术分： 广播室网络、点对点网络\r\n标准化工作及相关组织\r\n标准化工作\r\n要实现不同厂商的硬、软件之间相互连通，必须遵从统一的标准。\r\n标准分类：法定标准、事实标准\r\nRFC（request for comment） RFC上升为因特网标准的阶段: Internet\r\nDraft、Proposed Standard；Internet Standard\r\n相关组织\r\nISO 国际标准化组织 ITU 国际电信联盟 IEEE 电气电子工程师学会 IETF\r\nInternet工程任务组 ## 性能指标 ### 速率、带宽和吞吐量\r\n连接在计算机网络上的主机在数字信道上传送数据位数的速率。\r\n“带宽”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz)。计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s，kb/s，Mb/s，Gb/s。网络设备所支持的最高速度。\r\n表示在单位时间内通过某个网络（或信道、接口）的数据量。单位b/s，kb/s，Mb/s等。\r\n时延、时延带宽积、RTT、利用率\r\n\r\n时延\r\n\r\n发送时延：数据长度除以信道带宽（发送速率）\r\n传播时延：链路长度除以电磁波传播速率\r\n排队时延：等入口\r\n处理时延：找出口\r\n\r\n时延带宽积\r\n\r\n时延带宽积（bit） = 传播时延（s） * 带宽（b/s）\r\n时延带宽积又称为以比特为单位的链路长度。即“某段链路现在有多少比特”。容量\r\n\r\n往返时延RTT\r\n\r\n从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认)总共经历的时延。\r\nRTT包括传播时延（它的两倍）和末端处理时延\r\n\r\n利用率\r\n\r\n信道利用率\r\n网络利用率\r\n\r\n\r\n体系结构和参考模型\r\n分层结构与协议、接口、服务\r\n为什么要分层\r\n把大问题分成小问题解决\r\n怎么分层\r\n实体、对等实体 协议（对等实体才有协议，对等实体间的规定 ）\r\n接口（相邻层次才有） 服务（上层要求服务、下层提供服务）\r\n分层的基本原则： - 各层独立、每层只实现一种相对独立功能 -\r\n每层之间的界面清晰自然，易于理解，交互尽可能少 -\r\n结构上可以分割、都采用最合适的技术实现 -\r\n保持下层对上层的独立性，上层单向使用下层提供的服务 -\r\n整个分层结构应该能促进标准化工作。\r\n正式认识分层结构\r\n？？？\r\nlSO/OSI模型 7\r\n记忆：用示会输网链物（倒读）\r\n应用层 表示层 会话层 （上三层数据处理\r\n传输层\r\n网络层 数据链路层 物理层 （下三层数据通信\r\n点到点、端到端\r\nTCP/IP模型 4\r\n","categories":["Computer","计网"],"tags":["计算机网络"]},{"title":"曲线曲面的拟合","url":"/2022/10/18/%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E7%9A%84%E6%8B%9F%E5%90%88/","content":"Bernstein多项式\r\n概念\r\n形如：（QAQ）\\(B_{i,n}(t)=C_{n}^{i}t^i(1-t)^{n-i},0\\leq t\r\n\\leq1\\)的多项式，成为Bernstein多项式。\r\n其实就是（QAQ）\\(1=(t+1-t)^n\\)的二项式展开式中的一项。\r\n性质\r\n\r\n单位分解性 （QAQ）\\(\\sum_{i=0}^{n}B_{i,n}(t)=\\sum_{i=0}^{n}C_{n}^{i}t^i(1-t)^{n-i}=(t+1-t)^n\\equiv\r\n1\\)\r\n非负性 （QAQ）\\(B_{i,n}(t)\\geq 0,\\forall t\\ \\ 0\\leq t\r\n\\leq1\\)\r\n端点特性 （QAQ）\\(B_{0,n}(0)=B_{n,n}(1)=1\\) 对其他的有\r\n（QAQ）\\(B_{i,n}^{(k)}(0)=0,对0&lt;i&lt;n,k=0,1,\\cdots,i-1\\)\r\n（QAQ）\\(B_{i,n}^{(k)}(1)=0,对0&lt;i&lt;n,k=0,1,\\cdots,n-i-1\\)\r\n极大值 （QAQ）\\(B_{i,n}(t)\\)在（QAQ）\\(t=\\frac{i}{n}\\)处达到（QAQ）\\([0,1]\\)上的最大值\r\n递推性质 （QAQ）\\(B_{i,n}(t)=tB_{i-1,n-1}(t)-(1-t)B_{i,n-1}(t)\\)\r\n对称性 （QAQ）\\(B_{i,n}(t)=B_{n-i,n}(1-t)\\)\r\n导数 （QAQ）\\(B_{i,n}^{&#39;}(t)=n(B_{i-1,n-1}(t)-B_{i,n-1}(t))\\)\r\nBernstein多项式可构成多项式空间的一组基（选作基的好处）\r\n相比幂基，Bernstein多项式作为基在端点处有更好的性质，并且基中的每一个项都是相同次数的。\r\n用Bernstein多项式的单位分解性可以得到：幂基到B基的转换。\r\n\r\nBezier曲线\r\n定义：给定有序点列（QAQ）\\(\\{P_i\\},i=0,1,\\cdots,n\\)相应的n次Bezier曲线定义为:\r\n（QAQ）\\(P(t)=\\sum_{i=0}^{n}P_iB_{i,n}(t)\\)（这是一个参数方程曲线，P可以是n维空间中的点）\r\n几何系数（QAQ）\\(\\{P_i\\}\\)称为此Bezier曲线的控制点。控制点依次连接构成的多边形称为控制多边形。\r\nbezier曲线的几何特性\r\n\r\nbezier曲线总是插值首末控制点 （QAQ）\\(P(0)=P_0,P(1)=P_n\\)\r\n首末点处切天方向分别平行与邻近控制点确定的直线\r\n即分别与（QAQ）\\(P_1-P_0,P_n-P_{n-1}\\)平行\r\n伤射不变性（仿射变换又叫刚体变换，包括平移旋转对称），对控制点进行仿射变换，就是对曲线上所有点进行相同的变化，这表明曲线构造不依赖坐系选取。\r\n凸包性，Bezier曲线总是在控制多边形控制点的凸包内。（确保了在图像终端的可见，可用于碰撞检测）（注意是控制点的凸包）\r\n变差减缩性，任意直线于Bezier曲线的交点数量小于或等于该支线与控制多边形的交点数量。变差减缩性保证了曲线的震荡次数不会超过控制多边形的震荡次数。\r\n保线性（可减少振荡）：如果控制点都在一条线上，则bezier曲线也是一条线。\r\n\r\nBezier曲线的运算\r\n定义算子\r\n等同算子（QAQ）\\(\\mathcal{I}:\\mathcal{I}P_i=P_i\\)\r\n位移算子（QAQ）\\(\\varepsilon:\\varepsilon P_i =\r\nP_{i+1}\\) 差分算子（QAQ）\\(\\Delta:\\Delta P_i=P_{i+1}-P_{i}\\)\r\n（QAQ）\\(\\mathcal{L}:=(1-t)\\mathcal{I}+t\\varepsilon\\)\r\n求值和分割算法\r\n定理（de\r\nCasteljau算法 德卡斯特里奥算法）给定任意n次的Bezier曲线（QAQ）\\(P(t)=P_{n}\\)\r\n升阶算法\r\n作用：可以把低于最高次数的曲线提高到最高次数从而获得一致的次数。\r\n关于降阶\r\n类比多项式，升阶是比较容易的，但是既要降阶又要保持原有性质，这显然是困难的。如下：\r\n\\[\r\nx^2=x^2(1-x+x)\r\n\\] 但是怎么降到1次，似乎没有很好的办法。\r\n对于Bezier曲线的降阶，可以分为准确降阶和近似降阶。一般情况的准确降阶是不可能的，近似降阶，一种方式可以利用升阶公式反演出一个公式（蒙了）；另一种方式可以在低维空间中寻找这个曲线的最佳逼近元素（最近一致逼近、最佳平方逼近……）\r\n应该不会考（wu\r\n光滑拼接\r\n控制点增多时，曲线次数高计算量大，各个控制点的控制性减弱，为了避免这些缺点，我们可以将其分成几段再拼接起来。\r\n但是简单的连接往往不能满足我们的需求，为此我们需要根据设计的需求，保持连接点位置连续、切矢连续或曲率连续。\r\n开花\r\n所谓开花的想法就是：把一个n次曲线表示成多变量的仿射对称多项式。\r\n定义（仿射函数）\r\n若函数（QAQ）\\(f(x)\\)对任意的（QAQ）\\(a_1,\\cdots,a_m\\),（QAQ）\\(t_1,\\cdots,t_m\\) 满足, \\[\r\nf(\\sum_{i=1}^{m}a_it_i)=\\sum_{i=1}^{m}a_if(t_i)\r\n\\] 其中，（QAQ）\\(\\sum_{i=1}^{m}a_i=1\\)，则称此函数是仿射的。\r\n定义（多元仿射函数）\r\n指对多元函数中的每个变量都是仿射的。\r\n可以发现（能这样说吗？）仿射跟线性很像。\r\n定义（对称多项式）\r\n简单解释就是多元变量中任意两个变量交换位置不会改变函数的值。\r\n开花定理\r\n任意一元的n次多项式（QAQ）\\(F(t)\\)，存在唯一的n元仿射对称多项式（QAQ）\\(f(t_1,\\cdots,t_n)\\),使得 （QAQ）\\(F(t)=f(t,\\cdots,t)\\)。函数（QAQ）\\(f(t_1,\\cdots,t_n)\\)称为（QAQ）\\(F(t)\\)的开花多项式（Blossom）\r\nProof： （存在性） （唯一性）\r\n","categories":["Math","数值逼近"],"tags":["数值逼近"]},{"title":"正交多项式与函数逼近","url":"/2022/10/27/%E6%AD%A3%E4%BA%A4%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%91/","content":"引言\r\n寻找函数逼近的之前考虑以下问题： -\r\n已知函数解析形式，但过于复杂不变计算，希望有更简单的函数来代替原函数 -\r\n不知道函数的解析形式，但知道一些离散点的值，同样想要找到一个较为简单的函数来逼近离散数据\r\n通常的简单函数包括：多项式函数、三角函数、指数函数等，但本节只会讨论多项式函数。（明显多项式比其他的还有简单hhh）\r\n寻找函数逼近，实际上就是想要找到下面这个式子\r\n\\[\r\n||f(x)-P(x)||\r\n\\]\r\n在某种范数意义下，尽可能小，同时多项式的次数也尽可能小。\r\n常见的范数： - 2范数----------平方逼近 - 无穷范数--------一致逼近\r\n还有就是，离散数据的最佳平方逼近多项式，就是通常所说的“最小二乘法”，这是在自然科学当中及其常用的方法。\r\n本节介绍函数逼近之前先从介绍正交多项式开始。\r\n正交多项式理论有助于我们寻找函数逼近，在最佳一致逼近和最佳平方逼近中都有应用。并且在后续章节中也能看到正交多项式的身影（Gauss求积公式）\r\n正交多项式\r\n前提须知（内积空间理论）\r\n定义\r\n\r\n内积空间\r\n正交的定义\r\n由内积诱导的范数\r\nCauchy-Schwarz不等式\r\n\r\n\\[\r\n|&lt;f,g&gt;|\\leq ||f||||g||\r\n\\]\r\n\r\n范数是什么 （满足非负性、线性和三角不等式性质的函数）\r\n线性附范空间 （给内积空间配以范数）\r\n权函数\r\n（在开区间上定义的正的、连续的、可积的函数）\r\n\r\n正交多项式的概念和性质\r\n设\\(P_n\\)为次数不超过n次的多项式的集合.在\\(P_n\\)上定义内积\r\n\\[\r\n&lt;p_n,p_m&gt;=\\int_{a}^{b}\\rho(x)p_n(x)p_m(x)\\,dx,\\quad \\forall\r\np_n(x)p_m(x)\\in P_n\r\n\\]\r\n其中\\(\\rho(x)\\)为定义在\\((a,b)\\)上的权函数.相应的诱导范数为\r\n\\[\r\n||p_n||^{2}_{2}=\\int_{a}^{b}\\rho(x)p_n^2(x)\\,dx\r\n\\]\r\n正交多项式系\r\n定义:设\\(\\rho(x)\\)为定义在\\((a,b)\\)上的权函数,如果多项式序列\\(\\{p_j\\},j=0,1\\cdots\\)满足一下条件: - \\(p_j\\)的次数为j -\r\n\\[\r\n&lt;p_k,p_j&gt;=\\int_{a}^{b}\\rho(x)p_k(x)p_j(x)\\,dx=\\left\\{\\begin{matrix}\r\n0 \\quad k\\neq j\\\\\r\n\\neq 0 \\quad k=j\r\n\\end{matrix}\\right.\r\n\\]\r\n则称\\(\\{p_j\\},j=0,1\\cdots\\)为正交多项式序列.\r\n生成首1的正交多项式\r\n一般可以通过以下两种办法生成:\r\n(1)Gram-Schmidt正交化\r\n设\\(p_0(x)=1\\),假设\\(\\{p_j\\},j=0,1\\cdots,n\\)已经存在并且正交,下面将构造\\(p_{n+1}(x)\\).令\r\n\\[\r\nq(x)=x^{n+1}-\\sum_{j=0}^{n}a_jp_j(x)\r\n\\]\r\n其中,\r\n\\[\r\na_j=\\frac{&lt;x^{n+1},p_j&gt;}{&lt;p_j,p_j&gt;},j=0,1\\cdots,n\r\n\\]\r\n显然\\(q(x)\\)是次数为n+1且首系数为1的多项式,\r\n下面验证它与其他的多项式正交,对\\(i=0,1\\cdots,n\\)\r\n\\[\r\n&lt;q,p_i&gt;=&lt;x^{n+1}-\\sum_{j=0}^{n}a_jp_j(x),\\,p_i&gt;=&lt;x^{n+1},p_j&gt;-\\sum_{j=0}^{n}a_j&lt;p_j,p_i&gt;\r\n\\]\r\n\\[\r\n=&lt;x^{n+1},p_j&gt;-a_j&lt;p_j,p_j&gt;=&lt;x^{n+1},p_j&gt;-\\frac{&lt;x^{n+1},p_j&gt;}{&lt;p_j,p_j&gt;}&lt;p_j,p_j&gt;=0\r\n\\]\r\n故\\(q(x)\\)就是我们要找的\\(p_{n+1}(x)\\).\r\n值得说明的是:这样的构造方法,每新增一项要用到其他所有的多项式,这显然是不便于我们计算的,因此这种方法的理论价值大于实际应用价值.\r\n下面介绍的构造方法只用到的相邻的前两项.\r\n(2)三项递推公式\r\n\\[\r\n\\begin{aligned}\r\n\\begin{cases}\r\n&amp;p_0(x)=1\\\\\r\n&amp;p_1(x)=(x-a_0)p_0(x)=x-a_0\\\\\r\n&amp;p_{n+1}(x)=(x-a_n)p_n(x)-b_{n-1}p_{n-1}(x)\r\n\\end{cases}\\end{aligned}\r\n\\]\r\n其中,\r\n\\[\r\na_n=\\frac{&lt;xp_n,p_n&gt;}{&lt;p_n,p_n&gt;}\r\n\\]\r\n\\[\r\nb_n=\\frac{&lt;p_n,p_n&gt;}{&lt;p_{n-1},p_{n-1}&gt;}\r\n\\]\r\n证明: 数学归纳法.\r\n重要命题\r\n命题: 由上面两种方式生成的正交多项式\\(p_n(x),n\\geq 1\\)在定义域\\([a,b]\\)内有n个不同的实零点.\r\n证明: - 反证不保号(假设\\(p_n(x)\\)保号) -\r\n反证无重根(假设\\(x_1\\)是二重根) - 反证有\\(n\\)个实根(假设有\\(j\\)个根,\\(j&lt;n\\))\r\n定理\r\nChristoffel-Darbourx恒等式\r\n略一下\r\nLegendre 正交多项式系\r\nLegendre 正交多项式系的定义域为\\([-1,1]\\),权函数\\(\\omega(x)=1\\) 其表达为,\r\n\\[\r\nP_n(x)=\\frac{1}{2^n n!}\\frac{d^n}{dx^n}\\{(x^2-1)^2\\}\r\n\\]\r\n性质\r\n\r\n首项系数\r\n\r\n\\[\r\n\\frac{(2n)!}{2^n (n!)^2}\r\n\\]\r\n\r\n正交性质\r\n\r\n\\[\r\n&lt;P_n,P_m&gt;=\\int_{-1}^{1}P_n(x)P_m(x)\\,dx=\\begin{cases}0,m\\neq n\\\\\r\n\\frac{2}{2n+1},m=n\\end{cases}\r\n\\]\r\n\r\n三项递推公式\r\n\r\n\\[\r\n\\begin{cases}P_0(x)=1\\\\ P_1(x)=x\\\\\r\n(n+1)P_{n+1}(x)=(2n+1)xP_n(x)+nP_{n-1}(x)\\end{cases}\r\n\\]\r\n\r\n奇偶性\r\n\r\n\\[\r\nP_n(-x)=(-1)^{n}P_n(x)\r\n\\]\r\n\r\n特征方程\r\n\r\n\\[\r\n\\frac{d}{dx}((1-x^2)y&#39;)+\\lambda y=0,\\quad \\lambda = n(n+1)\r\n\\]\r\n\r\n边界值\r\n\r\n\\[\r\nP_n(1)=1\r\n\\]\r\n\\[\r\nP_n&#39;(1)=\\frac{n(n+1)}{2}\r\n\\]\r\nTchebyshev 正交多项式系\r\nChebyshev正交多项式系的定义域为\\([-1,1]\\),权函数\\(\\rho (x)=\\frac{1}{\\sqrt{1-x^2}}\\)\r\n其表达为,\r\n\\[\r\nT_n(x)=\\cos(n\\arccos(x))\r\n\\]\r\n性质\r\n\r\n三项递推公式\r\n\r\n\\[\r\n\\begin{cases}T_0(x)=1\\\\ T_1(x)=x\\\\\r\nT_{n+1}(x)=2xT_n(x)-T_{n-1}(x)\\end{cases}\r\n\\]\r\n简要说明,令\\(x=\\cos\\theta\\),则\r\n\\[\r\nT_{n+1}(x)=\\cos((n+1)\\theta) \\\\\r\nT_{n-1}(x)=\\cos((n-1)\\theta)\\\\T_{n+1}(x)+T_{n-1}(x)=2\\cos\\theta\\cos(n\\theta)=2xT_{n}(x)\r\n\\]\r\n\r\n首项系数 从三项递推公式得出\r\n\r\n\\[\r\n2^{n-1}\r\n\\]\r\n\r\n正交性质\r\n\r\n\\[\r\n&lt;T_n,T_m&gt;=\\int_{-1}^{1}\\frac{T_n(x)T_m(x)}{\\sqrt{1-x^2}}\\,dx=\\begin{cases}0,m\\neq\r\nn\\\\ \\frac{\\pi}{2},m= n\\neq 0\\\\ \\pi,m=n=0\\end{cases}\r\n\\]\r\n\r\n奇偶性\r\n\r\n\\[\r\nT_n(-x)=(-1)^{n}T_n(x)\r\n\\]\r\n数学归纳法简要证明:\r\n\\[\r\nT_{n+1}(-x)=-2xT_n(-x)-T_{n-1}(-x)\r\n\\]\r\n由归纳假设\r\n\\[\r\nT_{n+1}(-x)=-2x(-1)^nT_n(x)-(-1)^{n-1}T_{n-1}(x)\r\n\\]\r\n\\[\r\nT_{n+1}(-x)=2x(-1)^{n+1}T_n(x)-(-1)^{n-1+2}T_{n-1}(x)\r\n\\]\r\n\\[\r\nT_{n+1}(-x)=(-1)^{n+1}T_{n+1}(x)\r\n\\]\r\n故得证。 - 关于\\(T_n\\)的零点:它有n个实零点,表达式为,\r\n\\[\r\nx_k=\\cos(\\frac{2k-1}{2n}\\pi),\\quad k=1,\\cdots,n\r\n\\]\r\n简证\r\n\\[\r\n0=T_{n}(x)=\\cos(n\\theta)\r\n\\]\r\n于是得到, \\(n\\theta =\r\n\\frac{(2k-1)\\pi}{2}\\Rightarrow x=\\cos(\\frac{2k-1}{2n}\\pi)\\quad\r\nk=1,\\cdots,n\\) - \\(T_{n}(x)\\) 在\\(\\tilde{x}_k,k=0,1,\\cdots,n\\)上交错取到\\(\\pm 1\\)\r\n\\[\r\n\\tilde{x}_k=\\cos(\\frac{2k}{2n}\\pi)=\\cos(\\frac{k}{n}\\pi)\\quad\r\nk=0,1,\\cdots,n\r\n\\]\r\n与上一条的证明一样 - 在\\([-1,1]\\)上与零函数偏差最小的首1的n次多项式为:!!!!!!!!!!!!!!!!!!!!!!!(及其重要)\r\n\\[\r\n\\tilde{T}_n(x)=\\frac{T_n(x)}{2^{n-1}}\r\n\\]\r\n其最小偏差为\\(\\frac{1}{2^{n-1}}\\)\r\n证明:(反证法)假设存在一个首1的n次多项式使得,\r\n\\[\r\n\\max_{-1\\leq x\\leq1}{|Q(x)|}\\leq \\frac{1}{2^{n-1}}\r\n\\]\r\n令\\(q(x)=Q(x)-\\tilde{T}_n(x)\\in\r\nP_{n-1}([-1,1])\\),在\\(\\tilde{x}_k\\)处取值\\(\\tilde{T}_{n}(x)\\) 在\\(\\tilde{x}_k,k=0,1,\\cdots,n\\)上交错取到\\(\\pm\\frac{1}{2^{n-1}}\\)\r\n\\[\r\nq(\\tilde{x}_k )=\\begin{cases}\\leq 0 ,\\quad k \\ is\\ even \\\\ \\geq 0 ,\\quad\r\nk \\ is \\ odd\\end{cases}\\quad k=0,1,\\cdots,n\r\n\\]\r\n推出\\(q(x)\\)有n个零点,而\\(q\\)的次数为\\(n-1\\),由此推得矛盾. 故最佳的多项式是\\(\\tilde{T}_n(x)\\)\r\nLaguerre 正交多项式系\r\n略 ## Hermit 正交多项式系 略 # 最佳一致逼近 问题:\r\n\\(f\\in C([a,b])\\),若\\(q\\in V\\)使得,\r\n\\[\r\n||f(x)-p(x)||_{\\infty}=\\min_{q\\in V}||f(x)-q(x)||_{\\infty}\r\n\\]\r\n如果\\(V=P_n\\),则\\(p(x)\\)称为\\(f(x)\\)的最佳一致逼近多项式.\r\n最佳一致逼近多项式的存在性\r\n下面的定理说明了,多项式的次数不受限制时,可以逼近任意给定的精度.\r\n定理(Weierstress逼近定理): \\(\\forall \\epsilon &gt;0,f\\in\r\nC([a,b])\\),那么一定存在多项式\\(p(x)\\)使得,\r\n\\[\r\n||f(x)-p(x)||_{\\infty}=\\max_{a\\leq x\\leq b}|f(x)-p(x)|\\leq \\epsilon\r\n\\]\r\n注意:\\(\\epsilon\\)的大小和多项式p的次数我们不能同时固定住.\r\n下面定理说明的是,n固定时,最佳一致逼近多项式的存在性.\r\n定理: 设\\(f\\in\r\nC([a,b])\\),那么存在\\(p\\in\r\nP_n\\)使得,\r\n\\[\r\n||f(x)-p(x)||_{\\infty}=\\min_{p\\in P_n}||f(x)-p(x)||_{\\infty}\r\n\\]\r\n证明: 令\\(p(x)=\\sum_{i=0}^{n}C_i x^i\\), 记\\(E(C)=||f(x)-\\sum_{i=0}^{n}C_i x^i||_{\\infty},\\quad\r\nC\\in \\mathcal{R}^{n+1}\\) 分三步证明: (1)\r\nE是连续函数;\r\n\\[\r\n|E(\\lambda)-E(\\mu)|=|\\ ||f(x)-\\sum_{i=0}^{n}\\lambda_i\r\nx^i||_{\\infty}-||f(x)-\\sum_{i=0}^{n}\\mu_i x^i||_{\\infty} \\ |\r\n\\]\r\n\\[\r\n\\leq \\max_{a\\leq x\\leq b}|f(x)-\\sum_{i=0}^{n}\\lambda_i\r\nx^i-f(x)+\\sum_{i=0}^{n}\\mu_i x^i|\\leq \\max_{a\\leq x\\leq b}|\r\n\\sum_{i=0}^{n}(\\lambda_i-\\mu_i )x^i|\r\n\\]\r\n\\[\r\n\\leq\\sum_{i=0}^{n}|\\lambda_i-\\mu_i |\\,||x^i||_{\\infty}\\leq \\max_{a\\leq\r\nx\\leq b}| \\lambda_i-\\mu_i |M\r\n\\]\r\n其中,\r\n\\[\r\n\\max_{a\\leq x\\leq b}(\\sum_{i=0}^{n}||x^i||)\r\n\\]\r\n只要令,\r\n\\[\r\n\\max_{a\\leq x\\leq b}| \\lambda_i-\\mu_i |&lt;\\frac{\\epsilon}{M}\r\n\\]\r\n就有,\r\n\\[\r\n|E(\\lambda)-E(\\mu)|&lt;\\epsilon\r\n\\]\r\n故连续性得证.\r\n(2)定义有界闭集\r\n\\[\r\nS=\\{(c_0,c_1,\\cdots,c_n)\\in\r\n\\mathcal{R}^{n+1}|E(c_0,c_1,\\cdots,c_n)\\leq||f||_{\\infty}+1\\}\r\n\\]\r\n又由于,\r\n\\[\r\nE(0,0,\\cdots,0)=||f||_{\\infty}\\leq ||f||_{\\infty}+1\r\n\\]\r\n故S不为空集.因此在S中存在E的极值点.不妨设E在S中的极值小点为\\((c_0^*,c_1^*,\\cdots,c_n^*)\\),极小值为d.由于\\((0,0,\\cdots,0)\\in S\\),所以有,\r\n\\[\r\nd=E(c_0^*,c_1^*,\\cdots,c_n^*)\\leq E(0,0,\\cdots,0)=||f||_{\\infty}\r\n\\]\r\n(3)另一方面,根据S的定义,我们知道,\r\n\\[\r\nE(c_0,c_1,\\cdots,c_n)&gt;||f||_{\\infty}+1,\\forall\r\n(c_0,c_1,\\cdots,c_n)\\in \\mathcal{R}^{n+1}-S\r\n\\]\r\n也就是说,如果\\((c_0,c_1,\\cdots,c_n)\\notin\r\nS\\)那么就有,\r\n\\[\r\nE(c_0,c_1,\\cdots,c_n)&gt;d+1&gt;d\r\n\\]\r\n故,E在S中的极小值也是E在\\(\\mathcal{R}^{n+1}\\)中的极小值.即E在\\(\\mathcal{R}^{n+1}\\)中的极小值点也为\\((c_0^*,c_1^*,\\cdots,c_n^*)\\),因此由\\((c_0^*,c_1^*,\\cdots,c_n^*)\\)确定的多项式\r\n\\[\r\np^*(x)=\\sum_{i=0}^{n}c^*_i x^i\r\n\\]\r\n为\\(f\\)的最佳一致逼近多项式.\r\n最佳一致逼近多项式的性质\r\n问题导入\r\n例:\\(f\\in\r\nC([a,b])\\)单调递增,那么他的零次最佳一次逼近多项式是什么?\r\n\\[\r\nP_0=\\frac{1}{2}(f(a)+f(b))\r\n\\]\r\n如果不单调呢?\r\n\\[\r\nP_0=\\frac{1}{2}(f_{max}(x)+f_{min}(x))\r\n\\]\r\n直觉地,我们可以发现交错最大偏差的绝对值相同,零次的多项式有两个交错偏差,那么一次的多项式有三个交错偏差,以此类推n次多项式有n+2个交错偏差\r\n定理(De la Valle Poussin定理)\r\n定理内容: 设\\(f\\in C([a,b]),r\\in\r\nP_n\\),又存在\\([a,b]\\)上的\\(n+2\\)个点\\(x_0&lt;\\cdots&lt;x_n\\)使得\r\n\\[\r\nf(x_i)-r(x_i)\r\n\\]\r\n与\r\n\\[\r\nf(x_{i+1})-r(x_{i+1})\r\n\\]\r\n异号,那么有,\r\n\\[\r\n\\min_{p\\in P_n}||f(x)-p(x)||_{\\infty}\\geq \\min_{i\\in\r\n\\{0,1,\\cdots,n+1\\}}|f(x_i)-r(x_i)|_{\\infty}\r\n\\]\r\n定理内涵:只要我们找到的多项式不是最佳一致逼近多项式,就可以找到一个偏差比最佳一致逼近多项式的偏差要小.\r\n例题: \\(r(x)\\in\r\nP_3\\),如果正负交错偏差点小于3+2=5个的时候,我们就可以找到一个更好的修正\\(r^*(x)\\)使得偏差更小.\r\nChebyshev定理\r\n定理内容:设\\(f\\in C([a,b])\\),若\\(p_n\\in P_n\\)为\\(f\\)在\\([a,b]\\)上的最佳一种逼近多项式.当且仅当\r\n设\\(f-p_n\\)在\\([a,b]\\)上至少有\\(n+2\\)个交错偏差点.\r\n这个定理上课时没有去证.\r\nChebyshev定理的应用\r\n\r\n利用Chebyshev定理可以证明最佳一致逼近多项式的唯一性\r\n定理:(唯一性):设\\(f\\in\r\nC([a,b]),r\\in P_n\\),则存在唯一的\\(n\\)次最佳一致逼近多项式.\r\n\r\n证明: (反证法)假设\\(q_n,p_n\\)都是\\(f\\)在\\([a,b]\\)上的最佳一致逼近多项式,且\\(q_n\\neq p_n\\). 首先,我们有,\r\n\\[\r\nE_n(f)=||f-q_n||_{\\infty}=||f-p_n||_{\\infty}\r\n\\]\r\n令\\(h(x)=\\frac{1}{2}(p_n+q_n)\\),那么,\r\n\\[\r\n\\begin{split}\r\n2||f-h||_{\\infty}=&amp;||f-p_n+f-q_n||_{\\infty}\\\\\\leq\r\n&amp;||f-p_n||_{\\infty}+||f-q_n||_{\\infty}\\\\=&amp;2E_n(f)\\\\\r\n\\Rightarrow||f-h||_{\\infty}&amp;\\leq E_n(f)\r\n\\end{split}\r\n\\]\r\n由于\\(q_n,p_n\\)都是\\(f\\)在\\([a,b]\\)上的最佳一致逼近多项式,因此只能有,\r\n\\[\r\n||f-h||_{\\infty}= E_n(f)\r\n\\]\r\n即\\(h\\)也是\\(f\\)在\\([a,b]\\)上的最佳一致逼近多项式.\r\n那么由Chebyshev定理,我们知道\\(f-h\\)至少有\\(n+2\\)个交错偏差点\\(x_i,i=0,\\cdots,n+1\\),\r\n\\[\r\n|f(x_i)-h(x_i)|=E_n(f)\r\n\\]\r\n等价于\r\n\\[\r\n2|f(x_i)-h(x_i)|=|f(x_i)-p_n(x_i)+f(x_i)-q_n(x_i)|=2E_n(f)\r\n\\]\r\n\r\n另一个应用 定理: 设\\(f\\)在\\([a,b]\\)上的\\(n+1\\)阶导数存在,且\\(f^{(n+1)}\\)在\\([a,b]\\)上保号.若\\(p_n\\)为\\(f\\)在\\([a,b]\\)上的最佳一致逼近多项式,则\\(a,b\\)在\\(f-p_n\\)的交错偏差点组内.\r\n\r\n证明: (反证)假设\\(a\\)或者\\(b\\)不在\\(f-p_n\\)的交错偏差点组内. 那么至少有\\(n+1\\)个交错偏差点在开区间\\((a,b)\\)内部, 因此误差函数\\(e(x)=f(x)-p_n(x)\\)在\\((a,b)\\)内至少有\\(n+1\\)个驻点,记为\\(x_i,i=0,\\cdots,n\\)即,\r\n\\[\r\ne&#39;(x_i)=0,\\quad x_i\\in(a,b),i=0,\\cdots,n\r\n\\]\r\n应用Rolle定理,则存在\\(\\xi\\in(a,b)\\),使得,\r\n\\[\r\n0=e^{(n+1)}(\\xi)=f^{(n+1)}(\\xi)-p_n^{(n+1)}(\\xi)=f^{(n+1)}(\\xi)\r\n\\]\r\n而这与\\(f^{(n+1)}\\)在\\([a,b]\\)上保号矛盾.\r\n例题: 设\\(f\\in\r\nC^2([a,b])\\),\\(f&#39;&#39;\\)在\\([a,b]\\)上保号, 求\\(p_1(x)=a_1+a_2x\\)是\\(f\\)在\\([a,b]\\)上的一次最佳一致逼近多项式.\r\n解: 假设交错偏差点\\(a,b,c\\)\r\n\\[\r\nf(a)-p_1(a)=-(f(c)-p_1(c))=f(b)-p_1(b)\r\n\\]\r\n\\[\r\nf&#39;(c)-p_1&#39;(c)=0\r\n\\]\r\n三个方程三个未知数.\r\n最佳一致逼近多项式的近似方法\r\n例子\r\nRemez迭代方法求\r\n迭代的方法永远不是精确的!!!!!!!! 计算量很大,解是近似解不是精确解\r\n近似方法 - Lagrange插值法\r\n\\[\r\nf(x)-L_n(x)=\\frac{f^{(n+1)}}{(n+1)!}\\pi_(n+1)(x)=\\frac{f^{(n+1)}}{(n+1)!}(x-x_0)\\cdots(x-x_n)\r\n\\]\r\n\r\nChebyshev级数截断法 假设\\(f\\in\r\nC([a,b])\\),\\(f\\)可在正交多项式系\\(T_n(x)\\)下展开,\r\n\r\n\\[\r\nf(x)=\\frac{a_0}{2}+\\sum_{i=1}^{\\infty}a_iT_i(x)\r\n\\]\r\n\\[\r\na_i=\\frac{-2}{\\pi}\\int_{-1}^{1}\\frac{f(x)T_i(x)}{\\sqrt{1-x^2}}\\,dx\r\n\\]\r\n\\[\r\nf(x)\\approx\\frac{a_0}{2}+\\sum_{i=1}^{n}a_iT_i(x)=P_n(x)\r\n\\]\r\n当\\(n\\)足够大时,\r\n\\[\r\na_n\\sim \\frac{f^{(n)}(0)}{n!2^{n-1}}\r\n\\]\r\n可以发现\\(a_n\\)随着\\(n\\)变大,(大于)指数级下降,那么\r\n\\[\r\nf(x)-p_n(x)\\approx a_{n+1}T_{n+1}(x)\r\n\\]\r\n注意到\\(T_{n+1}(x)\\)有\\(n+2\\)个交错偏差点.\r\n最佳平方逼近\r\n问题: \\(f\\in\r\nC([a,b])\\),若\\(q\\in V\\)使得,\r\n\\[\r\n||f(x)-p(x)||_{2}=\\min_{q\\in V}||f(x)-q(x)||_{2}\r\n\\]\r\n如果\\(V=P_n\\),则\\(p(x)\\)称为\\(f(x)\\)的最佳平方逼近多项式.\r\n唯一性\r\n定理: 设\\(\\varphi_0,\\cdots,\\varphi_n\\in\r\nL^2_{\\rho}([a,b])\\) 则,\\(\\varphi_0,\\cdots,\\varphi_n\\)线性无关,当且仅当\\(det(G_n)\\neq 0\\) 其中,\r\n\\[\r\n\\begin{pmatrix}\r\n&lt;\\varphi _0,\\varphi _0&gt; &amp; \\cdots &amp;  &lt;\\varphi _0,\\varphi\r\n_n&gt;\\\\\r\n\\vdots &amp; \\ddots  &amp;\\vdots \\\\\r\n&lt;\\varphi _n,\\varphi _0&gt;  &amp; \\cdots &amp; &lt;\\varphi _n,\\varphi\r\n_n&gt;\r\n\\end{pmatrix}\r\n\\]\r\n高代学过&gt;_&lt;\r\n定理:(唯一性) 设\\(f \\in\r\nL^2_{\\rho}([a,b])\\),则\\(f\\)在\\(P_n\\)中存在唯一的最佳平方逼近多项式\\(S^*(x)\\).\r\n证明: (1)法方程有唯一\r\n(2)解是最佳平方逼近多项式. 记\r\n\\[\r\ns^*(x)=\\sum_{i=0}^{n}a_i^*\\varphi_i(x)\r\n\\]\r\n\\[\r\n\\begin{split}\r\n  &amp;||f-s||^2_2-\r\n||f-s^*||^2_2\\\\&amp;=&lt;f,f&gt;-2&lt;f,s&gt;+&lt;s,s&gt;-(&lt;f,f&gt;-2&lt;f,s^*&gt;+&lt;s^*,s^*&gt;)\\\\\r\n  &amp;=\r\n\\end{split}\r\n\\]\r\n定理: 若\\(P\\)为\\(f\\in\r\nL^{2}_{\\rho}([a.b])\\)在\\([a,b]\\)上的最佳平方逼近多项式,则\r\n\\[\r\n&lt;f-p,q&gt;=0,\\quad q\\in P_n\r\n\\]\r\nHilbert矩阵\r\n例题:\r\n正交多项式在最佳平方逼近的应用\r\n若\\(\\varphi_i,\\quad\r\ni=0,1,\\cdots,n\\)是一组正交多项式,那么\r\n\\[\r\n&lt;\\varphi_i,\\varphi_j&gt;=0,i\\neq j\r\n\\]\r\n法方程,\r\n\\[\r\n\\begin{pmatrix}\r\n  &lt;\\varphi_0,\\varphi_0&gt;&amp;0&amp;\\cdots&amp;0\\\\\r\n  0&amp;&lt;\\varphi_1,\\varphi_1&gt;&amp;\\cdots&amp;0\\\\\r\n  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\\r\n  0&amp;0&amp;\\cdots&amp;&lt;\\varphi_n,\\varphi_n&gt;\r\n\\end{pmatrix}\r\n\\begin{pmatrix}\r\n  0\\\\\r\n  0\\\\\r\n  0\\\\\r\n  -\\\\\r\n\\end{pmatrix}=\r\n\\begin{pmatrix}\r\n  0\\\\\r\n  0\\\\\r\n  0\\\\\r\n  -\\\\\r\n\\end{pmatrix}\r\n\\]\r\n命题: 若\\(f\\in\r\nL^{2}_{\\rho}([a.b])\\)且\\(\\{\\varphi_0,\\cdots,\\varphi_n\\}\\)是\\(L^{2}_{\\rho}([a.b])\\)中的一组正交多项式,那么,\r\n\\[\r\n\\sum_{i=0}^{n}\\frac{|&lt;f,\\varphi_i&gt;|^2}{||\\varphi||^2_2}\\leq||f||^2_2\r\n\\]\r\n证明: 令\\(e_i=\\frac{\\varphi_i}{||\\varphi||_2}\\),\r\n\\[\r\n\\begin{split}\r\n  0&amp;\\leq||f-\\sum_{i=0}^{n}&lt;f,e_i&gt;e_i||_2^2\\\\&amp;=&lt;f,f&gt;-2&lt;f,\\sum_{i=0}^{n}&lt;f,e_i&gt;e_i&gt;+&lt;\\sum_{i=0}^{n}&lt;f,e_i&gt;e_i,\\sum_{i=0}^{n}&lt;f,e_i&gt;e_i&gt;\\\\\r\n  &amp;=\r\n\\end{split}\r\n\\]\r\n几何意义\r\n最佳平方逼近多项式是原函数在某个多项式空间中的投影.\r\n最佳一致逼近多项式与最佳平方逼近多项式的比较\r\n(1) 通常情况下,最佳一致逼近多项式\\(\\neq\\)最佳平方逼近多项式\r\n(2)当\\(n\\)足够大时,最佳一致逼近多项式解决最佳平方逼近多项式.\r\n定理: 设\\(n\\geq 0,\\quad\r\nf\\in C[a,b]\\),又设\\(p_n\\in\r\nP_n\\)是\\(f\\)的最佳平方逼近多项式,则 \\(f-p_n\\)在\\([a,b]\\)内至少变化了\\(n+1\\)次符号.\r\n证明: \\(&lt;f-p_n,1&gt;=0\\Rightarrow f-p_n\\)在\\([a,b]\\)上不保号,不妨设\\(f-p_n\\)有\\(k\\)个零点\\(\\xi_i,i=1,\\cdots,k\\)\r\n(3)最佳平方逼近多项式提高次数时只需要增加一项.\r\n\\[\r\n\\begin{split}\r\n&amp;\\quad p_{n+1}=p_n+\\gamma_{n+1}\\varphi_{n+1}\\\\\r\n&amp;\\Rightarrow&lt;f-p_{n+1},\\varphi_{n+1}&gt;=0\\\\\r\n&amp;\\Rightarrow&lt;f-p_n-\\gamma_{n+1}\\varphi_{n+1},\\varphi_{n+1}&gt;=0\\\\\r\n&amp;\\Rightarrow&lt;f-p_{n},\\varphi_{n+1}&gt;=\\gamma_{n+1}&lt;\\varphi_{n+1},\\varphi_{n+1}&gt;\\\\\r\n&amp;\\Rightarrow\r\n\\gamma_{n+1}=\\frac{&lt;f-p_{n},\\varphi_{n+1}&gt;}{&lt;\\varphi_{n+1},\\varphi_{n+1}&gt;}=\\frac{&lt;f,\\varphi_{n+1}&gt;}{&lt;\\varphi_{n+1},\\varphi_{n+1}&gt;}  \r\n\\end{split}\r\n\\]\r\n最小二乘法\r\n问题引入\r\n数据(采样点) - 有误差 - 数据过多(百万级,插值不划算)\r\n定义:(数据拟合 fitting) 用简单函数\\(P(x)\\)取逼近数据集,使得误差\\(\\delta_i=P(x_i)-y_i\\)在某种意义下达到最小.\r\n常见误差度量方式: - 无穷范数:\\(||\\delta||_{\\infty}=\\max_{0\\leq i\\leq\r\nn}|\\delta_i|\\) - 1范数:\\(||\\delta||_{1}=\\sum_{i=0}^{n}|\\delta_i|\\) -\r\n2范数:\\(||\\delta||_{2}^2=\\sum_{i=0}^{n}\\delta_i^2\\)\r\n最小二乘拟合\r\n内积:\r\n\\[\r\n&lt;p,q&gt;=\\sum_{i=0}^{n}\\rho_ip_iq_i,\\qquad p,q\\in\\mathcal{R}^{n+1}\r\n\\]\r\n范数:\r\n\\[\r\n||p||_2^2=\\sum_{i=0}^{n}\\rho_ip_i^2\r\n\\]\r\n最小二乘法的目的:\r\n\\[\r\n||p-y||^2_2=||\\delta||_2^2=\\min_{q\\in P_n}||q-y||_2^2\r\n\\]\r\n令\\(p(x)=\\sum_{j=0}^{m}a_j\\varphi_j(x),\\quad p\\in\r\nP_m\\)\r\n\\[\r\n\\begin{split}\r\n  E(a_0,\\cdots,a_m)&amp;=||p-y||^2_2\\\\\r\n  &amp;=\r\n\\end{split}\r\n\\]\r\n一般情况: 设线性无关函数系\\(\\varphi_i(x)=x^m,i=0,\\cdots,m\\),且权系数为\\(\\rho_i=1\\),拟合多项式为,\r\n\\[\r\np(x)=\\sum_{j=0}^{m}a_jx^j\r\n\\]\r\n相应的法方程为:\r\n\\[\r\n\\left(\\begin{array}{cccc}\r\n\\sum_{i=0}^{n} 1 &amp; \\sum_{i=0}^{n} x_{i} &amp; \\ldots &amp;\r\n\\sum_{i=0}^{n} x_{i}^{m} \\\\\r\n\\sum_{i=0}^{n} x_{i} &amp; \\sum_{i=0}^{n} x_{i}^{2} &amp; \\ldots &amp;\r\n\\sum_{i=0}^{n} x_{i}^{m+1} \\\\\r\n\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\\r\n\\sum_{i=0}^{n} x_{i}^{m} &amp; \\sum_{i=0}^{n} x_{i}^{m+1} &amp; \\ldots\r\n&amp; \\sum_{i=0}^{n} x_{i}^{2 m}\r\n\\end{array}\\right)\\left(\\begin{array}{c}\r\na_{0} \\\\\r\na_{1} \\\\\r\n\\vdots \\\\\r\na_{m}\r\n\\end{array}\\right)=\\left(\\begin{array}{c}\r\nd_{0} \\\\\r\nd_{1} \\\\\r\n\\vdots \\\\\r\nd_{m}\r\n\\end{array}\\right)\r\n\\]\r\n但是,当\\(m\\)较大时,上面方程的系数矩阵(法矩阵)是病态的,通过数值软件解得的结果是不可靠的.\r\n正交多项式拟合\r\n为了避免求解病态法方程带来的麻烦,可以通过正交多项式来构造拟合多项式.\r\n设所选择的线性无关函数系具有正交性质,于是法方程可简化为:\r\n\\[\r\n\\begin{pmatrix}\r\n  &lt;\\varphi_0,\\varphi_0&gt;&amp;0&amp;\\cdots&amp;0\\\\\r\n  0&amp;&lt;\\varphi_1,\\varphi_1&gt;&amp;\\cdots&amp;0\\\\\r\n  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\\r\n  0&amp;0&amp;\\cdots&amp;&lt;\\varphi_n,\\varphi_n&gt;\r\n\\end{pmatrix}\r\n\\begin{pmatrix}\r\n  a_0\\\\\r\n  a_1\\\\\r\n  \\vdots\\\\\r\n  a_n\\\\\r\n\\end{pmatrix}=\r\n\\begin{pmatrix}\r\n  d_0\\\\\r\n  d_1\\\\\r\n  \\vdots\\\\\r\n  d_n\\\\\r\n\\end{pmatrix}\r\n\\]\r\n！！！！！ ## 例题 (1). 非线性的情况 尽量想办法变成线性\r\n(2). 超定方程 - 高代角度:\r\n\\(A^TAX=A^TC\\) - 数据拟合角度\r\n","categories":["Math","数值逼近"],"tags":["数值逼近"]},{"title":"数据链路层的功能","url":"/2023/05/15/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","content":"数据链路层的功能\r\n基本概念\r\n\r\n结点：主机、路由器\r\n链路：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。\r\n数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路.\r\n帧：链路层的协议数据单元，封装网络层数据报。\r\n\r\n数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。\r\n## 功能概述\r\n数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。\r\n\r\n功能一：为网络层提供服务。无确认无连接、有确认无连接、有确认面向连接\r\n功能二：链路管理，即连接的建立、维持、释放（用于面向连接的服务）。\r\n功能三：组帧。\r\n功能四：流量控制。限制发送方\r\n功能五：差错控制\r\n\r\n组帧\r\n封装成帧\r\n[[Pasted image 20230512233215.png]]\r\n封装成帧：就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。\r\n\r\n帧界定：首部和尾部中含有很多控制信息，它们的一个重要作用是确定帧的界限\r\n帧同步：指的是接收方应能从接收到的二进制比特流中区分出帧的起始与终止\r\n最大传送单元 MTU\r\n组帧的四种方法\r\n\r\n字符计数\r\n\r\n指在帧头部使用一个计数字段来标明帧内字符数。 [[Pasted image\r\n20230512234126.png]]\r\n\r\n字符填充 [[Pasted image 20230512234437.png]]\r\n零比特填充\r\n\r\n经过这种零比特填充后的数据，就可以保证不会出现6个连续1 [[Pasted\r\nimage 20230513002925.png]]\r\n\r\n违规编码法\r\n\r\n在物理层进行比特编码时，通常采用违规编码法。例如，曼彻斯特编码方法将数据比特“1”编码成“高-低”电平对，将数据比特“0”编码成“低-高”电平对，而“高-高”电平对和“低-低”电平对在数据比特中是违规的（即没有采用)。可以借用这些违规编码序列来定界帧的起始和终止。局域网IEEE\r\n802标准就采用了这种方法。\r\n违规编码法不需要采用任何填充技术，便能实现数据传输的透明性，但它只适用于采用冗余编码的特殊编码环境。\r\n\r\n\r\n\r\n由于字节计数法中计数字段的脆弱性和字符填充法实现上的复杂性与不兼容性，目前较常用的组帧方法是比特填充法和违规编码法。\r\n透明传输\r\n如果在数据中恰好出现与帧定界符相同的比特组合（会误认为“传输结束”而丢弃后面的数据)，那么就要采取有效的措施解决这个问题，即透明传输。更确切地说，透明传输就是不管所传数据是什么样的比特组合，都应当能在链路上传送。\r\n差错控制\r\n检错编码\r\n\r\n奇偶检验\r\nCRC冗余检验（概率1无差错、但还不是可靠传输）\r\n\r\n[[Pasted image 20230513013644.png]]\r\n\r\n\r\n纠错编码\r\n流量控制与可靠传输机制\r\n流量控制、可靠传输与滑动窗口机制\r\n停止-等待协议\r\n后退Ⅳ帧协议（GBN);\r\n选择重传协议(SR)\r\n介质访问控制\r\n1．信道划分\r\n频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理\r\n2．随机访问 ALOHA协议;CSMA协议;CSMA/CD协议;CSMA/CA协议\r\n3．令牌传递协议\r\n局域网\r\n局域网的基本概念与体系结构;以太网与IEEE 802.3IEEE\r\n802.11无线局域网;VLAN基本概念与基本原理\r\n广域网\r\n广域网的基本概念;PPP协议(八)数据链路层设备\r\n局域网交换机及其工作原理\r\n","categories":["Computer","计网"],"tags":["计算机网络"]},{"title":"绪论","url":"/2022/10/10/%E7%BB%AA%E8%AE%BA/","content":"数值分析简介\r\n三类问题\r\n\r\n理论上没解法，需要数值解\r\n理论上有解法，实际不实用\r\n理论上可解，但需要方法的稳定性分析 ##\r\n数值分析研究内容分为三大类\r\n数值逼近\r\n数值代数\r\n微分方程数值解 # 误差分析 ## 误差分类\r\n按误差来源\r\n\r\n模型误差\r\n测量误差\r\n截断误差(模型精确解与数值方法解之间的误差，也叫方法误差)\r\n舍入误差(由计算机字长限制产生)\r\n\r\n按度量方法\r\n\r\n绝对误差\r\n相对误差\r\n有效数字（跟高中学的不一样）\r\n\r\n\r\n误差限的概念\r\n先验估计和后验估计\r\n避免和减小误差的原则\r\n\r\n避免相近数相减\r\n避免绝对值过小的数做除数\r\n避免大数吃掉小数 舍入算法使得大数吃掉了小数 ## 简化计算步骤 ##\r\n用数值稳定的解法\r\n\r\n","categories":["Math","数值逼近"],"tags":["数值逼近"]},{"title":"线性规划和单纯形法","url":"/2023/05/15/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%92%8C%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/","content":"1.线性规划问题及数学模型\r\n\r\n在线性约束条件下，寻找目标函数的最优化问题\r\n\r\n一些概念\r\n\r\nCPF:corner-point feasible 角点可行解\r\n可行解、非可行解\r\n目标函数、约束函数\r\n松弛变量（slack variables）\r\n\r\n问题形式\r\n一般形式\r\n\\[\\begin{array}{c}\r\n\\max (\\min ) z=\\sum_{j=1}^{\\mathrm{n}} c_{\\mathrm{j}} x_{j} \\\\\r\n\\text { s.t. }\\left\\{\\begin{array}{l}\r\n\\sum_{j=1}^{\\mathrm{n}} \\mathrm{a}_{\\mathrm{ij}} \\mathrm{x}_{\\mathrm{j}}\r\n\\leq(=, \\geq) b_{i}(i=1,2, \\ldots, m) \\\\\r\nx_{\\mathrm{j}} \\geq 0 \\qquad(j=1,2, \\ldots, n)\r\n\\end{array} \\right.\r\n\\end{array}\\] ### 矩阵形式 \\[\\begin{array}{r}\r\nm \\alpha x(\\min ) z=C X \\\\\r\n\\text { s.t. }\\left\\{\\begin{array}{l}\r\nA X \\leq(=, \\geq) b \\\\\r\nX \\geq 0\r\n\\end{array}\\right.\r\n\\end{array}\\] ## 线性规划的标准化\r\n原因:在求解模型时，需要将数学语言转化为机器语言（任意一条语句都有明确且唯一的意义)，这涉及到一个转化的过程，即标准化。\r\n### 线性规划模型的标准形式 \\[\\begin{array}{c}\r\n\\max z=\\sum_{j=1}^{\\mathrm{n}} c_{\\mathrm{j}} x_{j} \\\\\r\n\\text { s.t. }\\left\\{\\begin{array}{l}\r\n\\sum_{j=1}^{\\mathrm{n}} \\mathrm{a}_{\\mathrm{ij}} \\mathrm{x}_{\\mathrm{j}}\r\n= b_{i}\\ (i=1,2, \\ldots, m) \\\\\r\nx_{\\mathrm{j}} \\geq 0 \\qquad\\qquad(j=1,2, \\ldots, n)\r\n\\end{array} \\right.\r\n\\end{array}\\]\r\n\r\n目标函数最大(max)\r\n约束条件为等式\r\n资源限量非负\r\n决策向量非负\r\n\r\n非标准形式可以转化为标准形式: - min ---&gt; max :取相反数 - 不等式\r\n---&gt; 等式:加减非负变量 - 决策变量无约束: 转化成两非负向量的差\r\n有关线性规划的假设\r\n比例性\r\n\r\n假设针对对象:目标函数和约束函数\r\n内容:一个活动的贡献值与这个活动级别成比例,或者说方程中不会出现二次及其以上次数的项\r\n\r\n可加性\r\n\r\n对象:模型中的每一个函数\r\n内容:就是假设每个函数中不会出现交叉项,或者说不同活动做的贡献不是简单的相加关系\r\n\r\n可分性\r\n\r\n对象:决策变量\r\n内容:感觉就是说假设决策变量是实数域上的连续函数\r\n\r\n确定性\r\n\r\n对象:模型参数\r\n内容:模型中的参数假设为已知常量\r\n注意:实际应用中,确定性假设很少完全满足,使用的参数值可能是将来条件的一种预期,不可避免地带有一定程度的不确定性。\r\n出于这一原因,在假设的参数下确定的最优解被找到后,通常要进行灵敏度分析(sensitivity\r\nanalysis)。目的之一是识别灵敏度参数(该参数的改变必然导致最优解的变化),因为灵敏度参数值的变化需要立即去改变正在使用的解。\r\n\r\n正确地假设(assumption in\r\nperspective)\r\n感觉中文译本中这个标题（‘前景假设’）翻译的不好.\r\n这一节是想告诉读者假设有时候并不会全都满足,但是我们可以通过其他的方式进行弥补.如:不满足确定性假设时,我们为此对灵敏度参数进行了灵敏度分析,这就是对不满足假设时的弥补.\r\n当四个假设中某个不满足时,要怎么处理问题.\r\n图解法\r\n图解法可以解决具有两个变量的任何线性规划问题。在增加一些难度的情况下,可以对它进行扩展来解决三个变量但不能多于三个变量的问题(下一章我们将研究用单纯形法解决较大规模的问题)。\r\n运筹学求解软件包\r\n\r\nlingo/lindo\r\nexcel solver\r\nmpl cplex\r\n\r\n2.线性规划几何意义\r\n图解法\r\n(画个表格) 图解法难以解决高维问题。\r\n解的情况\r\n\r\n唯一\r\n无穷多\r\n无界解（可行域不封闭、无界）\r\n无解（没有可行域）\r\n\r\n出现后两者就有可能是数学建模出现了问题，如缺乏必要的约束条件、出现矛盾的约束条件。\r\n3.解的概念\r\n4.单纯形法原理\r\n基本概念\r\n凸集\r\n（通俗版本）集合中任意两点的连线仍在集合中。\r\n（严格定义）设n维度欧式空间中点集\\(\\mathbb{K}\\)，\\(X_1,X_2\\)为集合中任意两点，若对任意实数\\(\\alpha\\in [0,1]\\)，满足： \\[\r\n\\alpha X_1+(1-\\alpha)X_2\\in\\mathbb{K}\r\n\\] 则称该集合\\(\\mathbb{K}\\)为凸集。\r\n凸组合 设n维度欧式空间中点集\\(\\mathbb{K}\\)，\\(X_1,\\cdots,X_k\\)为集合中任意\\(k\\)个点，若存在\\(k\\)个实数\\(0\\leq\\alpha_i\\leq 1,i=1,\\cdots,k\\)并且\\(\\sum_{i=1}^{k}\\alpha_i =1\\)，满足： \\[\r\nX=\\sum_{i=1}^{k}\\alpha_i X_i\r\n\\] 则称\\(X\\)为\\(X_1,\\cdots,X_k\\)的凸组合。\\(0 &lt;\\alpha_i&lt;\r\n1,i=1\\)，称为严格凸组合。\r\n顶点 设\\(\\mathbb{K}\\)凸集，\\(X\\in\\mathbb{K}\\),如果\\(X\\)不能用\\(\\mathbb{K}\\)中不同两点的严格凸组合表示，则称\\(X\\)为\\(\\mathbb{K}\\)的一个顶点。\r\n也即，对\\(0 &lt;\\alpha&lt; 1\\)有，\r\n\\[\r\nX\\neq \\alpha X_1+(1-\\alpha)X_2,\\forall X_1,X_2\\in\\mathbb{K},X_1\\neq X_2\r\n\\] ## 前置定理\r\n定理1（线性规划问题的可行域为凸集）\r\n若线性规划问题存在可行域， \\[\r\nD=\\{\\textbf{X}\\vert \\sum_{i=1}^{n}\\textbf{P}_ix_i=\\textbf{b},x_i\\geq 0\\}\r\n\\] 是凸集。（小写的x代表\\(X\\)的分量）\r\nproof 设\\(X_1,X_2\\)为\\(D\\)中任意两个相异的点，\\(A\\)是以\\(P_i\\)为行向量的矩阵。 则有， \\[\r\nAX_1=b,AX_2=b\r\n\\] 于是，两点连线上任意一点\\(X\\)满足， \\[\r\n\\begin{align*}\r\nAX=&amp; A(\\alpha X_1+(1-\\alpha)X_2)\\\\\r\n=&amp;\\alpha AX_1+AX_2-\\alpha AX_2\\in\\mathbb{K}\\\\\r\n=&amp; \\alpha b+b-\\alpha b\\\\\r\n=&amp; b\r\n\\end{align*}\r\n\\] 故\\(X\\in D\\)，\\(D\\)凸集。\r\n定理2 若\\(\\mathbb{K}\\)为有界凸集，则集合内任意一点可以表示为\\(\\mathbb{K}\\)的顶点的凸组合。\r\nproof 对于二维的情况比较形象。\r\n已知三角形为有界凸集。任何有界凸集可以用凸多边形逼近，而任意凸多边形可以划分成可数个三角形。承认上诉逻辑，我们只需要证明：三角形的任意一点可以用顶点的凸组合表出。\r\n设\\(X_1,X_2,X_3\\)为三角形的三个顶点。\\(X\\)为三角形内任意一点。若\\(X\\)在三条边上（即落在任意两个顶点的连线上），由凸集定义显然有顶点的凸组合表示。\r\n若不在三条边上，做过\\(X\\)与\\(X_1\\)的射线交另外两点的连线于\\(X&#39;\\)，于是有， \\[\r\nX&#39;=\\alpha X_2+(1-\\alpha)X_3\r\n\\] \\[\r\nX=\\lambda X&#39;+(1-\\lambda)X_1\r\n\\] \\[\r\n\\lambda,\\alpha\\in(0,1)\r\n\\] 代入即得， \\[\r\nX=(1-\\lambda)X_1+\\lambda\\alpha X_2+\\lambda(1-\\alpha)X_3\r\n\\] 将三个系数相加不难发现和为\\(1\\)。 至此，我们得到了\\(X\\)用顶点的凸组合的表示。\r\n但是对于二维以上的情形，就没有这么直观了，我们需要将三角形换成所谓的“单纯形”。\r\n\r\n单纯形是二维的三角形，三维的四面体，在任意维度的推广。n-维单纯形是一个有\r\nn+1 个顶点，n+1 个面 (facet) 的多面体。这个词译自英语\r\nsimplex，「单纯」其实意味着基本，因为他是组成更复杂结构（复形\r\ncomplex）的基本构件。\r\n\r\n迭代定理\r\n整个迭代过程的基本思想是:先寻找到初始基可行解，然后判断其是否最优、非最优，寻找到单位变动能创造更大收益的非基变量作为入基变量，然后确定入基变量变动后最先因资源受限而降为0的基变量作为出基变量，通过换基得到一个更接近最优值的解，不断重复，直到目标函数取到最优。\r\n# 5.单纯形法的计算步骤 ## 单纯形法的计算步骤 ### 寻找初始基可行解\r\n最优性检验&amp;入基变量选取\r\n由迭代原理可知，基变量对应的检验数必为0，非基变量则存在如下几种情况:\r\n1.\r\n所有非基变量的检验数均小于0，代表达到最优，任何变动都会使得目标值往更小的方向变化。\r\n2.\r\n部分非基变量的检验数小于0，其余非基变量的检验数等于0。代表已经达到最优，但存在部分约束，它们的变动并不会导致目标函数值发生变化，即模型存在无穷多最优解。\r\n3.\r\n部分非基变量的检验数大于0，代表现有的生产组合并没有达到最优，存在部分约束，它们的变动能使目标函数值往更大的方向变化，根据单纯形法，选择单位变动使目标函数值变化量最大的变量作为入基变量。\r\n出基变量选取\r\nemmm\r\n ###\r\n换基&amp;更新单纯形表\r\n单纯形法的变形\r\n大M法(人工变量法)\r\n考虑如下线性规划问题: \\[\r\n\\begin{array}{c}\r\n\\max z=-3 x_{1}+x_{3} \\\\\r\n\\text { s.t. }\\left\\{\\begin{array}{r}\r\nx_{1}+x_{2}+x_{3} \\leq 4 \\\\\r\n-2 x_{1}+x_{2}-x_{3} \\geq 1 \\\\\r\n3 x_{2}+x_{3}=9 \\\\\r\nx_{1}, x_{2}, x_{3} \\geq 0\r\n\\end{array}\\right.\r\n\\end{array}\r\n\\] 化为标准形式: \\[\r\n\\max z=-3 x_{1}+0 x_{2}+x_{3}+0 x_{4}+0 x_{5}\r\n\\] \\[\r\n\\text { s.t. }\\left\\{\\begin{array}{r}\r\nx_{1}+x_{2}+x_{3}+x_{4}=4 \\\\\r\n-2 x_{1}+x_{2}-x_{3}-x_{5}=1 \\\\\r\n3 x_{2}+x_{3}=9 \\\\\r\nx_{1}, x_{2}, x_{3}, x_{4}, x_{5} \\geq 0\r\n\\end{array}\\right.\r\n\\]\r\n有时我们并不能很方便地找出一组基来，为了更好地找到初始基，我们需要引入人工变量来构造一组基。\r\n\\[\r\n\\mathbf{A}=\\left(\\begin{array}{ccccc}\r\n1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\\r\n-2 &amp; 1 &amp; -1 &amp; 0 &amp; -1 \\\\\r\n0 &amp; 3 &amp; 1 &amp; 0 &amp; 0\r\n\\end{array}\\right), \\quad \\mathbf{b}=\\left(\\begin{array}{l}\r\n4 \\\\\r\n1 \\\\\r\n9\r\n\\end{array}\\right)\r\n\\]\r\n人工变量法的目的是为了构造一组基，原模型中只有一个单位列向量，但基的秩为\r\n3 ，即应找到三个单位列向量， 由此我们引入人工变量 \\(x_{6}\\) 和 \\(x_{7}\\) 。 由于这是我们人工引入\r\n(实际上并不存在的产品)，我们需要控制它最终的值只能为 0\r\n，所以在目标函数中，它的价值系数为 \\(-M\\) (其中 \\(M\\)\r\n是个足够大的数，并假设其能参与运算)，代表它每生产一件，都会导致目标函数变得足够小，由此，新的模型标准式为:\r\n\\[\r\n\\begin{array}{c}\r\n\\max z=-3 x_{1}+0 x_{2}+x_{3}+0 x_{4}+0 x_{5}-M x_{6}-M x_{7} \\\\\r\n\\text { s.t. }\\left\\{\\begin{array}{c}\r\nx_{1}+x_{2}+x_{3}+x_{4}=4 \\\\\r\n-2 x_{1}+x_{2}-x_{3}-x_{5}+x_{6}=1 \\\\\r\n3 x_{2}+x_{3}+x_{7}=9 \\\\\r\nx_{j} \\geq 0(j=1,2, \\ldots, 7)\r\n\\end{array}\\right.\r\n\\end{array}\r\n\\]\r\n由于人工变量是我们构建的，实际并不存在，所以要求它最终取值为0，若是单纯形表迭代到所有非基变量检验数均小于0，但基变量中含非0的人工变量时，说明该线性规划问题无解。\r\n两阶段法\r\n模型求解的过程一般都靠计算机完成，需要将数学语言转化为含义明确唯一的程序语言，使用人工变量法虽然可以帮助寻找初始基，但M这个足够大的数含义并非明确，在不同问题中，“足够”有不同的衡量标准，为此我们引入两阶段法。其基本思路是将添加人工变量后的线性规划问题拆分成两个阶段:\r\n\r\n第一阶段:求解一个目标函数只包含人工变量的线性规划问题，在决策变量非负的约束条件下，人工变量只有取0才能取到最小值，此时的最优解即原问题的一个基可行解。\r\n第二阶段:回归原问题，并用第一阶段最后的基为初始基，对原问题用单纯形法迭代。\r\n\r\n还是以上一道题为例 \\[\r\n\\max z=-3 x_{1}+0 x_{2}+x_{3}+0 x_{4}+0 x_{5}\r\n\\] \\[\r\n\\text { s.t. }\\left\\{\\begin{array}{r}\r\nx_{1}+x_{2}+x_{3}+x_{4}=4 \\\\\r\n-2 x_{1}+x_{2}-x_{3}-x_{5}=1 \\\\\r\n3 x_{2}+x_{3}=9 \\\\\r\nx_{1}, x_{2}, x_{3}, x_{4}, x_{5} \\geq 0\r\n\\end{array}\\right.\r\n\\] 第一阶段： 加入人工变量 \\(x_{6}\\) 和 \\(x_{7}\\) ，构建目标函数只包含人工变量的模型:\r\n\\[\r\n\\max z= 0 x_{1}+0 x_{2}+0 x_{3}+0 x_{4}+0 x_{5}-x_{6}-x_{7}\r\n\\] \\[\r\n\\text { s.t. }\\left\\{\\begin{array}{r}\r\nx_{1}+x_{2}+x_{3}+x_{4}=4 \\\\\r\n-2 x_{1}+x_{2}-x_{3}-x_{5}=1 \\\\\r\n3 x_{2}+x_{3}=9 \\\\\r\nx_{1}, x_{2}, x_{3}, x_{4}, x_{5} \\geq 0\r\n\\end{array}\\right.\r\n\\]\r\n第二阶段：\r\n第一阶段最后的基为初始基，对原问题用单纯形法迭代。\r\n若第一阶段迭代最终结果中的基变量仍含有非0的人工变量，即目标函数值不为0，则说明问题无解。\r\n单纯形法的其他讨论\r\n一些可能出现的情况\r\n\r\n目标函数极小值时解的最优性判别\r\n根据单纯形法的迭代原理，在目标函数取极小值时，只需确保所有检验数大于0即可保证最优。\r\n退化 按最大检验数和最小比值\\(\\theta\\)确定入基变量和出基变量时，有时会存在两个及以上相同的最大或最小值，从而使得下个表中的基可行解中出现一个或多个基变量等于0的退化解(模型中存在多余约束，使得多个基可行解对应同一顶点)，进而可能导致迭代计算陷入循环，为避免重复的运算，规定:存在多个检验数大于0取得相同最大值时，始终取下标值最小(或最大)的变量作为入基变量;存在多个\\(\\theta\\)出现相同最小比值，始终取下标值最小(或最大)的变量作为出基变量。\r\n无可行解的判别\r\n从人工变量法和两阶段法的计算步骤中可以看出，当求解结果出现所有检验数均小于等于0，但基变量中仍存在非零的人工变量(两阶段法第一阶段目标函数值不为0)时，表明问题无可行解，即人工变量最终求解结果必须为0.\r\n\r\n修正单纯形法 (求解过程的优化)\r\n单纯形法的矩阵描述\r\n主要是对换基过程的优化，把求逆过程优化，直接在单纯形表上操作。不严格地说，其实就是把求逆换成初等行变换。\r\nemmm \r\n","categories":["Math","运筹"],"tags":["运筹学"]},{"title":"物理层","url":"/2023/05/15/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%89%A9%E7%90%86%E5%B1%82/","content":"\r\n","categories":["Computer","计网"],"tags":["计算机网络"]},{"title":"解线性方程组的直接法","url":"/2022/11/02/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%B3%95/","content":"消元法（上三角阵）\r\nGauss消元法\r\n以\\(3\\times3\\)为例, \\[\r\n\\left\\{\\begin{matrix}\r\na_{11}^{(1)}x_1 &amp;  +a_{12}^{(1)}x_2 &amp;  +a_{13}^{(1)}x_3 &amp;=\r\nb_{1}^{(1)}\\\\\r\n  a_{21}^{(1)}x_1 &amp; + a_{22}^{(1)}x_2 &amp; + a_{23}^{(1)}x_3 &amp;=\r\nb_{2}^{(1)} \\\\\r\n  a_{31}^{(1)}x_1 &amp;  +a_{32}^{(1)}x_2 &amp;  +a_{33}^{(1)}x_3 &amp;=\r\nb_{3}^{(1)}\r\n\\end{matrix}\\right.\r\n\\] 第一次消元 \\[\r\n\\left\\{\\begin{matrix}\r\na_{11}^{(1)}x_1 &amp;  +a_{12}^{(1)}x_2 &amp;  +a_{13}^{(1)}x_3 &amp;=\r\nb_{1}^{(1)}\\\\\r\n0&amp; a_{22}^{(2)}x_2 &amp; + a_{23}^{(2)}x_3 &amp;= b_{2}^{(2)} \\\\\r\n0&amp; a_{32}^{(2)}x_2 &amp;  +a_{33}^{(2)}x_3 &amp;= b_{3}^{(2)}\r\n\\end{matrix}\\right.\r\n\\] 第二次消元 \\[\r\n\\left\\{\\begin{matrix}\r\na_{11}^{(1)}x_1 &amp;  +a_{12}^{(1)}x_2 &amp;  +a_{13}^{(1)}x_3 &amp;=\r\nb_{1}^{(1)}\\\\\r\n0&amp; a_{22}^{(2)}x_2 &amp; + a_{23}^{(2)}x_3 &amp;= b_{2}^{(2)} \\\\\r\n0&amp;  0 &amp; a_{33}^{(3)}x_3 &amp;= b_{3}^{(3)}\r\n\\end{matrix}\\right.\r\n\\]\r\n总结算法:!!!!!!!!!!!!!!!!! \\[\r\n\\left\\{\\begin{matrix}\r\n\\\\\r\n\\\\\r\n\\end{matrix}\\right.\r\n\\]\r\n定理: \\(A\\)可以进行Gauss消元,即\\(a_{ii}^i\\neq 0,i=1,\\cdots,k\\Leftrightarrow\r\nA\\)的各阶顺序主子式不为0.\r\n证明: \\(\\Leftarrow\\) 当\\(k=1\\)时,\\(D_1=a_{11}^{(1)}\\neq 0\\),显然成立.\r\n若充分性对\\(k-1\\)成立,即当\\(D_i\\neq 0,i=1,\\cdots,k-1\\),有\\(a_{ii}^{(i)}\\neq 0,i=1,\\cdots,k-1\\).\r\n往证,当\\(D_k\\neq 0\\)时,有\\(a_{kk}^{(k)}\\neq 0\\).\r\n推论: 如果\\(A\\)的各阶顺序主子式\\(D_k\\neq 0\\),则 \\[\r\na_{11}^{(1)}=D_1,\\cdots,a_{kk}^{(k)}=\\frac{D_k}{D_{k-1}},\\cdots\r\n\\]\r\nGauss列主元\r\n若有\\(a_{kk}^{(k)}\\approx\r\n0\\)会把舍入误差放大,引起解的失真.为了避免Gauss消元法的这种局限性,我们选取列主元后再进行消元,精确度就有不错的提高.\r\nGauss全主元\r\n一般情况下,选取列主元再消元的列主元消元法已经可以满足精度需求,但是再一些情况下,我们需要更高的精度,我们可以尝试全主元消元法提高精度和稳定性.\r\n消元法和矩阵分解的关系\r\n初等矩阵: 由单位矩阵经过一次初等变换得到的矩阵.\r\n用得到的说明 \\[\r\nl_{i1}=\\frac{a^{(1)}_{i1}}{a_{11}^{(1)}},\\quad L_{1}^{-1}A=A^{(2)}\\\\\r\nl_{ik}=\\frac{a^{(k)}_{ik}}{a_{kk}^{(k)}},\\quad\r\nL_{k}^{-1}A^{(k)}=A^{(k+1)}\\\\\r\n\\vdots\\\\\r\nA^{(k+1)}=L_{k}^{-1}L_{k-1}^{-1}\\cdots\r\nL_{1}^{-1}A^{(1)}=L_{k}^{-1}L_{k-1}^{-1}\\cdots L_{1}^{-1}A\r\n\\] 若\\(A\\)为\\(n\\)阶方阵,则需要进行\\(n-1\\)次消元于是有 \\[\r\nA^{(n)}=L_{n-1}^{-1}L_{n-2}^{-1}\\cdots L_{1}^{-1}A^{(1)}\r\n\\] 记, \\[\r\nL=L_1L_2\\cdots L_{n-1}\\\\\r\nL^{-1}=L_{n-1}^{-1}L_{n-2}^{-1}\\cdots L_{1}^{-1}\\\\\r\nU=A^{(n)}\r\n\\] 于是就有, \\[\r\nU=L^{-1}A,\\quad A=LU\r\n\\]\r\n\\[\r\nL_{1}=\\left(\\begin{array}{cccc}\r\n1 &amp; &amp; &amp; \\\\\r\nl_{21} &amp; 1 &amp; &amp; \\\\\r\nl_{31} &amp;&amp; 1 &amp; &amp; \\\\\r\n\\vdots &amp; &amp;&amp; \\ddots &amp; \\\\\r\nl_{n 1} &amp; &amp;&amp; &amp; 1\r\n\\end{array}\\right)\r\nL_{k}=\\left(\\begin{array}{cccccc}\r\n1 &amp; &amp; &amp; &amp; &amp; \\\\\r\n&amp; 1 &amp; &amp; &amp; &amp; \\\\\r\n&amp; &amp; \\ddots &amp; &amp; &amp; \\\\\r\n&amp; &amp; &amp;1 &amp; &amp;  \\\\\r\n&amp; &amp; &amp;l_{k+1,k} &amp; 1 &amp; &amp; \\\\\r\n&amp; &amp;&amp; \\vdots &amp; &amp; \\ddots &amp; \\\\\r\n&amp; &amp;&amp; l_{n k} &amp;&amp; &amp; 1\r\n\\end{array}\\right)\r\n\\] \\[\r\nL_{1}^{-1}=\\left(\\begin{array}{cccc}\r\n1 &amp; &amp; &amp; \\\\\r\n-l_{21} &amp; 1 &amp; &amp; \\\\\r\n-l_{31} &amp;&amp; 1 &amp; &amp; \\\\\r\n\\vdots &amp; &amp;&amp; \\ddots &amp; \\\\\r\n-l_{n 1} &amp; &amp;&amp; &amp; 1\r\n\\end{array}\\right)\r\nL_{k}^{-1}=\\left(\\begin{array}{cccccc}\r\n1 &amp; &amp; &amp; &amp; &amp; \\\\\r\n&amp; 1 &amp; &amp; &amp; &amp; \\\\\r\n&amp; &amp; \\ddots &amp; &amp; &amp; \\\\\r\n&amp; &amp; &amp;1 &amp; &amp;  \\\\\r\n&amp; &amp; &amp;-l_{k+1,k} &amp; 1 &amp; &amp; \\\\\r\n&amp; &amp;&amp; \\vdots &amp; &amp; \\ddots &amp; \\\\\r\n&amp; &amp;&amp; -l_{n k} &amp;&amp; &amp; 1\r\n\\end{array}\\right)\r\n\\]\r\n定理: 若\\(A\\)的各阶顺序主子式不为0,则\\(A\\)必可以分解成一个下三角阵与一个上三角阵的乘积.\r\n\\[\r\nA=LU\r\n\\] 下三角的对角线元素全为\\(1\\),上三角的对角线元素不为\\(0\\).\r\nProof: (存在性)显然. (唯一性)用反证法.若不然,有\\(A=LU=L&#39;U&#39;\\)！！！！！！！！！！\r\n则有 \\[\r\nL^{-1}L&#39;=U(U&#39;)^{-1}\r\n\\]\r\n矩阵的三角分解\r\nDoolittle 三角分解\r\n计算流程！！！！\r\n计算流程(自己算一下) \\[\r\nA=\\left(\\begin{array}{rrrr}\r\n2 &amp; 4 &amp; 2 &amp; 0 \\\\\r\n2 &amp; 3 &amp; 6 &amp; 0 \\\\\r\n0 &amp; 4 &amp; 2 &amp; 24 \\\\\r\n0 &amp; 0 &amp; 5 &amp; 1\r\n\\end{array}\\right)\r\n\\] ## Crout 分解\r\n定理: 若\\(A\\)的各阶主子式不为0,则\\(A\\)必可以分解成一个下三角阵与一个上三角阵的乘积.\r\n\\[\r\nA=LU\r\n\\] 其中\\(L\\)为下三角阵,\\(U\\)为单位上三角阵.\r\nProof: \\(A^{T}\\)也有LU分解,即, \\[\r\nA^{T}=LU\r\n\\] 其中\\(L\\)为单位下三角阵,则,\r\n\\[\r\nA=U^{T}L^{T}\r\n\\] 得证.\r\n(用这分解算算上面的A)\r\n三对角阵的追赶法\r\n设方程组\\(AX=d\\),其中, \\[\r\n\\left(\\begin{array}{l}\r\na_{1} &amp; b_{1} &amp; &amp; &amp; &amp; \\\\\r\nc_{2} &amp; a_{2} &amp; b_{2} &amp; &amp; &amp; \\\\\r\n&amp; c_{3} &amp; a_{3} &amp; b_{3} &amp; \\\\\r\n&amp; &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\\\\r\n&amp;&amp; &amp; \\ddots &amp; \\ddots  &amp; b_{n-1}\\\\\r\n&amp;&amp;&amp;&amp;c_n&amp;a_n\r\n\\end{array}\\right)\r\n\\]\r\n主对角线严格占优\r\n10.21\r\n对称正交阵的平方根法\r\n对称阵的\\(LDL^T\\)分解\r\n定理: 若\\(A\\)为\\(n\\)阶方阵,且其各阶顺序主子式不为零,则当\\(A\\)对称时,可唯一分解为\\(LDL^T\\),其中\\(L\\)为单位下三角阵,\\(D\\)为对角阵.\r\nProof: 显然,由定理条件可知,\\(A\\)可以进行LU分解. \\[\r\nA=LU\r\n\\] 其中, \\[\r\nL=\\left(\\begin{array}{cccc}\r\n1 &amp; &amp; &amp; \\\\\r\nl_{21} &amp; 1 &amp; &amp; \\\\\r\nl_{31} &amp;l_{32}&amp; 1 &amp; &amp; \\\\\r\n\\vdots &amp; \\vdots&amp;&amp; \\ddots &amp; \\\\\r\nl_{n 1} &amp;l_{n2} &amp;\\cdots&amp;l_{n,(n-1)} &amp; 1\r\n\\end{array}\\right)\r\n\\] !!!!!!!!!!!!!!\r\n对称正定阵的平方根法(\\(LL^T\\)分解、Cholesky分解)\r\n定理: 若\\(A\\)为\\(n\\)阶对称正定阵,则存在一个实非奇异下三角阵\\(L\\),使得 \\[A=LL^T\\] 当限定\\(L\\)的对角元为正时,分解唯一.\r\nProof: !!!!!!!!!!!!!!!!!!\r\n计算流程\r\nGauss-Jordan 求逆矩阵\r\n内容\r\n\\((A\\ |\\ I)\\Rightarrow(I\\ |\\\r\nA^{-1})\\)\r\n思想\r\nGauss消元法+对角线全消+对角元归一化\r\n计算例题\r\n矩阵的正交三角化及应用\r\n初等反射阵与 Household 变换\r\n基本内容\r\n定义:\r\n定理: 设\\(w^Tw=1,H(w)=I-2ww^T\\)为初等反射阵,则:\r\n\r\n\\(H\\)为对称阵\r\n\\(H\\)为正交阵\r\n若\\(A\\)为对称阵,则\\(A_1=H^{-1}AH=HAH\\)也对称\r\n\r\nProof:\r\n\r\n因\r\n\r\n任意向量构造初等反射阵\r\n初等反射阵的几何意义\r\n\r\n\\(w\\) 与 \\(X-HX\\) 平行\r\n\\(||X||_2=||HX||_2\\)\r\n\r\n初等反射阵计算意义\r\n通过选取合适的\\(w\\),使得对任意的\\(X\\neq 0\\),存在一个\\(H(w)\\),满足 \\[\r\nHX=-\\sigma e_1,\\quad where\\ \\sigma=\\pm||X||_2,e_1=(1,0,\\cdots)\r\n\\] 即 \\[\r\nX=,\r\nHX=\r\n\\]\r\n引理:\\(\\forall x,y\\in\r\n\\R^n,x\\neq y\\),且\\(||X||_2=||Y||_2\\),则存在初等反射矩阵\\(H\\),使得 \\[\r\nX=HY\r\n\\]\r\nproof:\r\n令\\(w=\\frac{X-Y}{||X-Y||_2}\\)，显然\\(||w||_2=1\\)于是有,\r\n\\[\r\nH(w)=I-2ww^T=I-2\\frac{(X-Y)(X-Y)^T}{||X-Y||_2^2}\r\n\\]\r\n那么,\r\n\\[\r\nHX=(I-2\\frac{(X-Y)(X-Y)^T}{||X-Y||_2})X\r\n\\]\r\n注意到,\r\n\\[\r\nX^TX=(X,X)=||X||_2^2=||Y||_2^2=(Y,Y)=Y^TY\\\\\r\nX^TY=Y^TX\\\\\r\n\\]\r\n有,\r\n\\[\r\n\\begin{split}\r\n  ||X-Y||_2^2&amp;=(X-Y,X-Y)=(X-Y)^T(X-Y)\\\\&amp;=X^TX-X^TY-Y^TX+Y^TY\\\\\r\n  &amp;=2(X-Y)^TX\r\n\\end{split}\r\n\\]\r\n故,\r\n\\[HX=X-(X-Y)=Y\\]\r\n注: 正交变换不改变向量的2范数,即若\\(P\\)为正交阵,则 \\[||PX||_2=||X||_2 \\] 因为,\\(||PX||_2^2=(PX,PX)=(X,P^TPX)=(X,IX)=||X||_2^2\\)\r\n定理: (约化定理)设\\(X=(x_1,x_2,\\cdots,x_n)^T\\neq\r\n0\\),则存在初等反射阵\\(H\\),使得,\r\n\\[\r\nHX=-\\sigma e_1\r\n\\]\r\n其中,\r\n\\[\\begin{cases}\r\n  e_1=(1,0,\\cdots,0)^T\\\\\r\n  H=I-\\beta^{-1}uu^T\\\\\r\n  \\sigma =sign(x_1)||X||_2\\\\\r\n  u=X+\\sigma e_1\\\\\r\n  \\beta=\\sigma(\\sigma+x_1)\r\n\\end{cases}\\]\r\nproof: 令\\(Y=-\\sigma\r\ne_1\\),取\\(\\sigma=\\pm||X||_2\\)\r\n此时,\\(||Y||_2=|\\sigma|=||X||_2\\)\r\n由上面的引理知, \\[\\exists H=I-2ww^T\\\r\n,s.t.HX=-\\sigma e_1\\] 其中, \\[\r\nw=\\frac{X-Y}{||X-Y||_2}=\\frac{X+\\sigma e_1}{||X+\\sigma\r\ne_1||_2}:=\\frac{u}{||u||_2}\\] 且, \\[H=I-2ww^T=I-2\\frac{uu^T}{||u||_2^2}:=I-\\beta^{-1}uu^T\\\\\r\n\\beta=\\frac{1}{2}||u||_2\\] 显然, \\[\\begin{split}\r\n  \\beta&amp;=\\frac{1}{2}||u||_2=\\frac{1}{2}||X+\\sigma e_1||_2^2\\\\\r\n  &amp;=\\frac{1}{2}((X_1+\\sigma)^2+X_2^2+\\cdots+X_n^2)\\\\\r\n  &amp;=\\frac{1}{2}(\\sigma^2+2\\sigma X_1+X_1^2+X_2^2+\\cdots+X_n^2)\\\\\r\n  &amp;=\\frac{1}{2}(\\sigma^2+2\\sigma X_1+\\sigma^2)\\\\\r\n  &amp;=\\sigma(\\sigma+X_1)\r\n\\end{split}\\]\r\n为避免有效数字损失,\\(\\sigma\\)应该与\\(X_1\\)同号.\r\n计算上,当\\(X\\)的分量太大时,可考虑归一化, 令\\(d=||X||_{\\infty},X&#39;=\\frac{X}{d}\\),\r\n\\[\\begin{cases}\r\n  \\sigma&#39; =sign(X_1&#39;)||X&#39;||_2=\\frac{\\sigma}{d}\\\\\r\n  u&#39;=X&#39;+\\sigma&#39; e_1=\\frac{u}{d}\\\\\r\n  \\beta&#39;=\\sigma&#39;(\\sigma&#39;+X_1&#39;)=\\frac{\\beta}{d^2}\\\\\r\n  H=I-(\\beta&#39;)^{-1}(u&#39;)(u&#39;)^T=H\r\n\\end{cases}\\]\r\n平面旋转矩阵和Givens变换\r\n对于\\(\\R^2\\)上的旋转变换(向量逆时针)\r\n\\[\r\n\\begin{pmatrix}\r\n  x&#39;\\\\\r\n  y&#39;\r\n\\end{pmatrix}\r\n=\\begin{pmatrix}\r\n  \\cos\\theta&amp;-\\sin\\theta\\\\\r\n  \\sin\\theta&amp;\\cos\\theta\r\n\\end{pmatrix}\\begin{pmatrix}\r\n  x\\\\\r\n  y\r\n\\end{pmatrix}\r\n\\]\r\n而坐标系逆时针(向量顺时针)的旋转矩阵为 \\[P^{-1}=P^T=\r\n\\begin{pmatrix}\r\n  \\cos\\theta&amp;\\sin\\theta\\\\\r\n  -\\sin\\theta&amp;\\cos\\theta\r\n\\end{pmatrix}\r\n\\]\r\n一般地,对于\\(\\R_n\\)也有旋转变换,\\(y=Px,\\quad x,y\\in \\R^n\\)\r\n\\[\r\nP(i,j,\\theta)=P(i,j)=\r\n=\\left(\\begin{array}{cccc}\r\n1 &amp; &amp; &amp; &amp;&amp;\\\\\r\n&amp;1&amp; &amp; &amp;&amp;\\\\\r\n&amp;&amp;\\ddots &amp; &amp; &amp; &amp;&amp;\\\\\r\n&amp;&amp;&amp;\\cos \\theta &amp; &amp; &amp;\\sin \\theta  \\leftarrow i\r\n\\text { 行 } &amp;&amp;\\\\\r\n&amp;&amp;&amp;&amp;1&amp; &amp; &amp;&amp;\\\\\r\n&amp;&amp;&amp;&amp;&amp; \\ddots  &amp; &amp;&amp;\\\\\r\n&amp;&amp;&amp;-\\sin \\theta &amp; &amp; &amp;\\cos \\theta  \\leftarrow j\r\n\\text { 行 }&amp;&amp;\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\ddots&amp;\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;1\r\n\\end{array} \\right).\r\n\\]\r\n称为平面\\(\\{x_i,y_i\\}\\)的旋转变换,或称为Givens变换.\r\n定理: (约化定理)对\\(\\forall X=(x_1,\\cdots,x_n)\\neq\r\n0\\),则可选取Givens变换\\(P(i,j,\\theta)\\)使得, \\[PX=(x_1,\\cdots,x_i&#39;,x_{i+1},\\cdots,0,x_{j+1},\\cdots,x_n)^T\\]\r\n其中\\(x_i&#39;=\\sqrt{x_i^2+x_j^2},\\theta=\\arctan\\frac{x_j}{x_i}\\)\r\nProof:\r\n矩阵的QR分解\r\nHousehold变换下的QR分解\r\n目的: 对矩阵\\(A\\in\\R^{m\\times n},(m\\leq\r\nn),s=\\min(m-1,n)\\),则存在初等反射阵\\(H_1,H_2,\\cdots,H_s\\),使得, \\[\r\nH_s\\cdots H_1=\\begin{cases}\r\n  R,m=n\\\\\r\n  (R,\\theta)^T,m&gt;n\r\n\\end{cases}\r\n\\]\r\n引理：若 \\(A\\in\\R^{m\\times\r\nn}\\) 且 \\(A\\) 列满秩。\\(s=\\min(m-1,n)\\),则有初等反射阵， \\(H_1,H_2,\\cdots,H_s\\),使得, \\[\r\nH_s\\cdots H_1=\\begin{cases}\r\n  R,m=n\\\\\r\n  (R,\\theta)^T,m&gt;n\r\n\\end{cases}\r\n\\]\r\nProof：设 \\[A=\\begin{pmatrix}  \r\n  a_{11} &amp; \\cdots &amp; a_{1n} \\\\  \r\n  \\vdots &amp; \\ddots &amp; \\vdots \\\\  \r\n  a_{m1} &amp; \\cdots &amp; a_{mn}  \r\n\\end{pmatrix} =A^{(1)}=(a_1,a_2,\\cdots,a_n)\\]\r\n第一步：（约化）\\(a_1\\neq\r\n\\vec{0}\\)\r\n由前面的定理，可以知道存在初等反射阵， \\[H_1=I-\\beta^{-1}_1u_1u_1^T\\] 使得，\\(H_1a_1=-\\sigma_1 e_1,\\sigma\r\n=sign(a_{11})||a_1||_2\\),于是， \\[H_1A^{(1)}=(H_1a_1,H_1a_2,\\cdots,H_1a_n)\\\\=\\begin{pmatrix}  \r\n  -\\sigma_1 &amp;a_{12}^{(2)}&amp; \\cdots &amp; a_{1n}^{(2)} \\\\  \r\n0 &amp;a_{22}^{(2)}&amp; \\ddots &amp; \\vdots \\\\  \r\n    \\vdots &amp;\\vdots&amp; \\ddots &amp; \\vdots \\\\  \r\n0 &amp;a_{m2}^{(2)}&amp; \\cdots &amp; a_{mn}^{(2)}\r\n\\end{pmatrix} \\]\r\n定理：(矩阵的QR分解) - \\(m&gt;n\\),设\\(A\\in\\R^{m\\times n},A\\)列满秩.\\(s=\\min(m-1,n)\\),则存在初等反射阵\\(H_1,H_2,\\cdots,H_s\\),使得, \\[H_s\\cdots H_1A=(R,\\theta)^T\\] 其中\\(R\\)为非奇异的\\(n\\)阶上三角阵.\\(\\theta\\)为零矩阵.\r\n\r\n\\(m=n\\),设\\(A\\in\\R^{n\\times n},A\\)非奇异,则 \\[A=QR\\] 其中\\(R\\)为非奇异的\\(n\\)阶上三角阵.\\(Q\\)为正交矩阵.且当\\(R\\)的对角线元素均为正值,分解唯一.\r\n\r\nProof: (1)第一条证明同上一条引理. (2)第二条,当\\(m=n\\)时,\\(s=\\min(m-1,n)=n-1\\),则存在初等反射阵,\\(H_1,H_2,\\cdots,H_{n-1}\\),使得, \\[H_{n-1}\\cdots H_1A=\\begin{pmatrix}  \r\n  r_{11}&amp; r_{12}&amp; \\cdots  &amp; r_{1n} \\\\  \r\n  0&amp; r_{22}&amp; \\cdots  &amp; r_{2n} \\\\  \r\n  \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  \r\n  0&amp; 0&amp; \\cdots  &amp; r_{nn}  \r\n\\end{pmatrix}  \r\n:=R\\] 记\\(Q^{-1}=Q^T=H_{n-1}\\cdots\r\nH_1\\),则 \\[Q^{-1}A=R\\] 即,\\(A=QR\\),Q为正交阵. 下证唯一性, 若\\(A=Q_1R_1=Q_2R_2\\),且\\(R_1,R_2\\)为非奇异上三角阵,有正的对角元,\\(Q_1,Q_2\\)为正交阵. 考虑\\(A^TA\\),因\\(A^TA\\)对称正定.则 \\[A^TA=(Q_1R_1)^TQ_1R_1=R_1^TR_1\\] \\[A^TA=(Q_2R_2)^TQ_2R_2=R_2^TR_2\\] 由于\\(A^TA\\)的cholesky分解的唯一性,知, \\[Q_1=Q_2,R_1=R_2\\]\r\n注解: (1)若\\(A\\in\\R^{n\\times\r\nn}\\)非奇异,则\\(A^TA\\)是对称正定的;\r\n证明:对称是显然的, 任给一个非零向量\\(X\\),因为\\(A\\)非奇异,所以有\\(AX\\neq 0\\),要验证\\(A^TA\\)为正定阵, 有正定定义, \\[X^TA^TAX=(AX)^TAX=(AX,AX)=||AX||_2^2&gt;0,\\forall\r\nX\\neq 0\\] (2)QR分解的计算意义: \\(AX=b\\Rightarrow QRX=b\\Rightarrow RX=Q^Tb\\)\r\n转置基本没有计算量,\\(R\\)是上三角阵解出\\(X\\)是容易的.\r\nGivens变换下的QR分解\r\n定理:若\\(A\\in\\R^{n\\times\r\nn},A\\)非奇异,则存在平面旋转矩阵\\(P_1,P_2,\\cdots,P_{n-1}\\),使得, \\[\r\nP_{n-1}\\cdots P_1A=R=\\begin{pmatrix}  \r\n  r_{11}&amp; r_{12}&amp; \\cdots  &amp; r_{1n} \\\\  \r\n  0&amp; r_{22}&amp; \\cdots  &amp; r_{2n} \\\\  \r\n  \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  \r\n  0&amp; 0&amp; \\cdots  &amp; r_{nn}  \r\n\\end{pmatrix}  \r\n\\] \\(A\\)有QR分解,其中\\(R\\)为非奇异的\\(n\\)阶上三角阵.\\(Q\\)为正交矩阵.且当\\(R\\)的对角线元素均为正值,分解唯一.\r\nProof: 第一步约化,不妨设第一列元素都不为0.\r\n可以选取\\(n-1\\)个Givens变换,\\(P(1,2),\\cdots,P(1,n)\\)作用再\\(A\\)上,使得, \\[\r\nP(1,n)\\cdots P(1,2)A=\\begin{pmatrix}  \r\n  r_{11}&amp; r_{12}&amp; \\cdots  &amp; r_{1n} \\\\  \r\n  0&amp; a_{22}^{(2)}&amp; \\cdots  &amp; a^{(2)}_{2n} \\\\  \r\n  \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\  \r\n  0&amp; a_{n2}^{(2)}&amp; \\cdots  &amp; a^{(2)}_{nn}  \r\n\\end{pmatrix}  :=A^{(2)}\r\n\\] 其中\\(r_{11}^2=a_{11}^2+a_{21}^2+\\cdots+a_{n1}^2\\),记\r\n\\[P_1=P(1,n)\\cdots P(1,2)\\] \\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\\(\\big|\\Big| |\\bigg|\\Bigg|\\)\r\n第k步约化:设已经完成\\(k-1\\)步约化,即\r\n\\[\r\nP_{k-1}\\cdots P_1A=\\left(\\begin{array}{cccccc}\r\nr_{11} &amp; r_{12} &amp; \\cdots &amp; r_{1 k} &amp; \\cdots &amp; r_{1\r\nn} \\\\\r\n&amp; r_{22} &amp; \\cdots &amp; r_{2 k} &amp; \\cdots &amp; r_{2 n} \\\\\r\n&amp; &amp; \\ddots &amp; \\vdots&amp; &amp; \\vdots \\\\\r\n&amp; &amp; &amp; a_{k k}^{(k)}&amp; \\cdots &amp; a_{k n}^{(k)} \\\\\r\n&amp; &amp;  &amp; \\vdots&amp; &amp; \\vdots \\\\\r\n&amp; &amp; &amp; a_{n k}^{(k)} &amp; \\cdots &amp; a_{n n}^{(k)}\r\n\\end{array}\\right):=A^{(k)}\r\n\\] 现进行第\\(k\\)步约化,不妨设\\(a_{jk}^{(k)}\\neq\r\n0,(j=k+1,\\cdots,n)\\),则可以选择Givens变换, \\[P(k,j)\\] 使得, \\[A^{(k+1)}=P(k,n)\\cdots\r\nP(k,k+1)A^{(k)}=P_kA^{(k)}\\] 此时,就把\\(a_{k k}^{(k)}\\)更新成\\(r_{kk}\\)且其下方元素为0. 故得到\\(k+1\\)阶上三角阵\\(A^{(k+1)}\\), 继续以上约化过程,最后就有,\r\n\\[ P_{n-1}\\cdots P_1A=A^{(n)}:=R\\]\r\n记\\(Q^T=Q^{-1}=P_{n-1}\\cdots\r\nP_1\\),有\\(Q^{-1}A=R\\),即有 \\[A=QR\\] 其中\\(Q\\)为正交阵,\\(R\\)为非奇异上三角阵(唯一性,Cholesky分解).\r\n\r\n例题:用反射阵对 \\[\r\nA=\\left(\\begin{array}{lll}\r\n0 &amp; 2 &amp; 0 \\\\\r\n2 &amp; 1 &amp; 2 \\\\\r\n0 &amp; 2 &amp; 1\r\n\\end{array}\\right)\r\n\\] 进行QR分解.\r\n求解超定方程组\r\n设\\(AX=b,A\\in \\R^{m\\times\r\nn},(m&gt;n)\\),\\(A\\)列满秩,一般而言没有通常意义下的解.\r\n线性最小二乘问题:对超定方程组,找到\\(X^*\\in \\R^n\\),使得 \\[\r\n\\min_{X^*\\in \\R^n}||b-AX||_2^2=||b-AX^*||_2^2\\neq 0\r\n\\] 记 \\[r=b-AX\\]\r\n为残差向量,于是我们只要让\\(||r||_2^2\\)最小即可.\r\n可以利用正交约化求最小二乘解.\r\n有正交约化定理,可选择初等反射阵\\(H_1,\\cdots\r\nH_n\\),使得, 左边 \\[\r\nH_n,\\cdots H_1A=\\left.\\left(\\frac{R}{\\theta}\\right)\\right.\r\n\\] \\(R\\)为\\(n\\times n\\)的矩阵,\\(\\theta\\)为\\((m-n)\\times n\\)的矩阵 右边 \\[\r\nH_n,\\cdots H_1b=\\left.\\left(\\frac{c}{d}\\right)\\right.\r\n\\] 记\\(Q=H_n,\\cdots H_1\\),于是\r\n\\[Qr=Q(b-AX)=Qb-QAX\\] \\[=\\left.\\left(\\frac{c}{d}\\right)\\right.-\\left.\\left(\\frac{R}{\\theta}\\right)\\right.X=\\left.\\left(\\frac{c-RX}{d}\\right)\\right.\\]\r\n注意到\\(Q\\)为正交阵, \\[||r||_2^2=(r,r)=(Q^TQr,r)=(Qr,Qr)=||Qr||_2^2\\]\r\n\\[=||c-RX||_2^2+||d||_2^2\\geq\r\n||d||_2^2\\] 取等条件为 \\[c=RX,X\\in\r\n\\R^n\\] 即有,当\\(X^*\\)为\\(RX=c\\)的解时,有 \\[\\min_{X^*\\in\r\n\\R^n}||r||_2^2=||r^*||_2^2=||d||_2^2\\neq 0\\] \\[\\min_{X^*\\in\r\n\\R^n}||b-AX||_2^2=||b-AX^*||_2^2=||d||_2^2\\neq 0\\]\r\n","categories":["Math","数值代数"],"tags":["数值代数"]},{"title":"课程简介","url":"/2022/10/06/%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B/","content":"数值分析\r\n\r\n数值代数（36+12-4）\r\n数值逼近（36+20）\r\n微分方程数值解（48+12）\r\n\r\n数值 数值解是否可靠\r\n课程目的\r\n\r\n用计算工具求解线性及非线性方程问题.(允许误差存在)\r\n若真解好求,加快求解速度\r\n若真解不好求,给出近似解\r\n\r\n主要内容\r\n\r\nch1:向量及矩阵范数\r\nch2:解线性方程组的直接法\r\nch3:解线性方程组的迭代法\r\nch4:非线性方程组求解\r\n\r\n考核方式\r\n期末80 作业大作业 20 # 课程概述 关于解线性方程组: 理论上的求解可以有:\r\n- 伴随矩阵 - Cramer法则 但是计算量显然比较大 O(n!)\r\n数值计算以多项式复杂度居多 - 直接法,等价变化成对角阵 - 迭代法 \\[AX\\Leftrightarrow X=GX+d\\]\r\n","categories":["Math","数值代数"],"tags":["数值代数"]},{"title":"解线性方程组的迭代法","url":"/2022/11/16/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/","content":"直接法的好处，除了舍入误差外没有引入额外的误差。但坏处在于，计算比较复杂。为此我们引入额外的误差设计迭代法。\r\n本章概要\r\n迭代法分为两大步：\r\n\r\n方程的改写(矩阵分裂)\r\n\r\n\\(AX=b\\)等价变形为\\(X=BX+d\\)\r\n若 \\(A=M-N\\),则\\(MX=NX+b\\),若\\(M\\)可逆就有, \\(X=M^{-1}NX+M^{-1}b\\)\r\n\r\n真解换成数值解\r\n\r\n\\(X^{(k+1)}=BX^{(k)}+d,k=0,1,\\cdots\\)\r\n\r\n\r\n注意:\\(B\\)的选取极为关键,它绝对了收敛性.\r\n# 迭代法\r\n定义:若\\(X=BX+d\\)是\\(AX=b\\)的同解方程组,对\\(\\forall X^{(0)}\\in \\R^{n}\\),迭代\\(X^{(k+1)}=BX^{(k)}+d,k=0,1,\\cdots\\),得到的\\(\\{X^{(k)}\\}\\)有极限,称迭代是收敛的.\r\n定理:(迭代收敛判定定理)迭代\\(X^{(k+1)}=BX^{(k)}+d,k=0,1,\\cdots\\)收敛,等价于\\(B\\)为收敛矩阵,或者说\\(B^k\\rightarrow 0\\),即\\(\\rho(B)&lt;1\\).\r\nProof: 记\\(X^*\\)为迭代方程\\(X=BX+d\\)的解,即 \\[X^*=BX^*+d\\] 误差 \\[e^{(k)}=X^*-X^{(k)}\\] 由\\(X^{(k+1)}=BX^{(k)}+d,k=0,1,\\cdots\\),知\r\n\\[e^{(k+1)}=X^*-X^{(k+1)}=B(X^*-X^{(k)})=Be^{(k)}\\]\r\n于是 \\[e^{(k+1)}=B^{(k+1)}e^{(0)}\\]\r\n因为\\(e^{(0)}\\)为有界向量,则 \\[e^k\\rightarrow 0\\Leftrightarrow B^k\\rightarrow\r\n0\\] 由第一章定理知,\\(B^k\\rightarrow\r\n0\\)等价于\\(\\rho(B)&lt;1\\).\r\n推论:(充分条件)若\\(||B||&lt;1\\),则迭代\\(X^{(k+1)}=BX^{(k)}+d,k=0,1,\\cdots\\)收敛.\r\nProof:由第一章推论知道, \\[\\rho(B)\\leq||B||&lt;1\\] 收敛.\r\nJacobi 迭代\r\nJacobi\r\n迭代公式(分量形式,用于计算)\r\n对\\(AX=b\\)的分量形式: \\[\\sum_{j=1}^n\r\na_{ij}x_j=b_i,i=1,2,\\cdots,n\\]\r\n\r\n方程改写:若\\(a_{ii}\\neq\r\n0\\),则可等价改写成 \\[a_{ii}x_i=b_i-\\sum_{j\\neq i}^n a_{ij}x_j\\]\r\n即 \\[x_i=\\frac{1}{a_{ii}}(b_i-\\sum_{j\\neq\r\ni}^n a_{ij}x_j)\\]\r\n真解改数值解 任取\\(X^{(0)}\\in\r\n\\R^{n}\\),迭代方程. \\[x_i^{(k+1)}=\\frac{1}{a_{ii}}(b_i-\\sum_{j\\neq i}^n\r\na_{ij}x_j^{(k)})\\] 即, \\[\r\n\\left\\{\\begin{aligned}\r\nx_{1}^{(k+1)} &amp;=\\frac{-1}{a_{11}}\\left(\\qquad a_{12}\r\nx_{2}^{(k)}+a_{13} x_{3}^{(k)}+\\cdots+a_{1 n} x_{n}^{(k)}-b_{1}\\right)\r\n\\\\\r\nx_{2}^{(k+1)} &amp;=\\frac{-1}{a_{22}}\\left(a_{21} x_{1}^{(k)}\r\n\\qquad+a_{23} x_{3}^{(k)}+\\cdots+a_{2 n} x_{n}^{(k)}-b_{2}\\right) \\\\\r\n&amp; \\vdots \\\\\r\nx_{n}^{(k+1)} &amp;=\\frac{-1}{a_{n n}}\\left(a_{n 1} x_{1}^{(k)}+a_{n 2}\r\nx_{2}^{(k)}+\\cdots+a_{n n-1} x_{n-1}^{(k)} \\qquad-b_{n}\\right)\r\n\\end{aligned}\\right.\r\n\\]\r\n\r\n迭代矩阵及收敛定理\r\n记\\(A=D-L-U\\),其中 \\[\r\nD=\\left(\\begin{array}{llll}\r\na_{11} &amp; &amp; &amp; \\\\\r\n&amp; a_{22} &amp; &amp; \\\\\r\n&amp; &amp; \\ddots &amp; \\\\\r\n&amp; &amp; &amp; a_{n n}\r\n\\end{array}\\right)\r\n\\] \\[\r\nL=\\left(\\begin{array}{ccc}\r\n0 &amp; &amp; \\\\\r\na_{21} &amp; 0 &amp; \\\\\r\n\\vdots &amp;  &amp; \\\\\r\na_{n 1}&amp;\\cdots &amp; a_{n n-1} &amp; 0\r\n\\end{array}\\right)\r\n\\] \\[\r\nU=\\begin{pmatrix}  \r\n  0&amp; a_{12}&amp; \\cdots  &amp; a_{1n} \\\\  \r\n  0&amp; 0&amp;  &amp; \\vdots \\\\  \r\n  \\vdots &amp; \\vdots &amp;  &amp; a_{n-1n} \\\\  \r\n  0&amp; 0&amp; \\cdots  &amp; 0  \r\n\\end{pmatrix}  \r\n\\] 于是\\(AX=b\\),等价于\\((D-L-U)X=b\\),推出 \\[DX=(L+U)X+b\\] 即有, \\[\r\nX=D^{-1}(L+U)X+D^{-1}b\r\n\\] 从而Jacobi迭代矩阵为 \\[B_J=D^{-1}(L+U)=D^{-1}(D-A)\\\\=I-D^{-1}A\\]\r\n命题:(对角占优性质)若\\(A\\)是严格对角占优,则\\(A\\)非奇异.\r\nProof:仅考虑\\(A\\)为严格行对角占优情形(对于列占优,只需考虑\\(A^T\\)即可). 用反证,若\\(A\\)奇异,则齐次方程组\\(AX=0\\)有非零解,记为\\(X=(x_1,\\cdots,x_n)^T\\neq 0\\)记\\(|x_k|=\\max_{i}|x_i|\\neq 0\\), 考虑\\(AX=0\\)的第\\(看\\)个方程, \\[a_{k 1} x_{1}+a_{k2} x_{2}+\\cdots+a_{k n} x_{n}=0\r\n\\] 有 \\[a_{kk}=-\\sum_{j\\neq\r\nk}a_{kj}x_j\\] 于是有, \\[\r\n\\begin{split}\r\n|a_{kk}||x_k|&amp;=|a_{kk}x_k|\\\\&amp;=|-\\sum_{j\\neq\r\nk}a_{kj}x_j|\\\\&amp;=\\sum_{j\\neq k}|a_{kj}||x_j|\\\\&amp;=\\sum_{j\\neq\r\nk}|a_{kj}||x_k|\r\n\\end{split}\r\n\\] 从而有 \\[|a_{kk}|\\leq \\sum_{j\\neq\r\nk}|a_{kj}|\\] 矛盾.\r\n定理:(Jacodbi 迭代收敛判断定理)若\\(AX=b\\)的系数矩阵\\(A\\)满足一下的任意一条, - \\(A\\)为严格行对角占优 \\[|a_{ii}|&gt;\\sum_{j\\neq\r\ni}|a_{ij}|,i=1,\\cdots,n\\] - \\(A\\)为严格列对角占优 \\[|a_{jj}|&gt;\\sum_{i\\neq\r\nj}|a_{ij}|,j=1,\\cdots,n\\] - \\(A\\)的元素满足: \\[\\sum_{i\\neq\r\nj}\\frac{|a_{ij}|}{|a_{ii}|}&lt;1,j=1,\\cdots,n\\]\r\nProof: 1. 考虑Jacobi的迭代矩阵\\(B_J=I-D^{-1}A\\)则, \\[\r\nB_{J}=\\left(\\begin{array}{ccc}\r\n1 &amp; &amp; \\\\\r\n&amp; \\ddots &amp; \\\\\r\n&amp; &amp; 1\r\n\\end{array}\\right)-\\left(\\begin{array}{cccc}\r\n1 &amp; \\frac{a_{12}}{a_{11}} &amp; \\cdots &amp; \\frac{a_{1 n}}{a_{11}}\r\n\\\\\r\n&amp; &amp; &amp; \\\\\r\n\\frac{a_{21}}{a_{22}} &amp; 1 &amp; \\cdots &amp; \\frac{a_{2 n}}{a_{22}}\r\n\\\\\r\n\\vdots &amp; &amp; &amp; \\\\\r\n\\frac{a_{n n}}{a_{n n}} &amp; &amp; \\frac{a_{n n-1}}{a_{n n}} &amp; 1\r\n\\end{array}\\right)\r\n\\]\r\n\\[\r\nB_J=\r\n\\left(\\begin{array}{cccc}\r\n0 &amp; -\\frac{a_{12}}{a_{11}} &amp; \\cdots &amp; -\\frac{a_{1\r\nn}}{a_{11}} \\\\\r\n-\\frac{a_{21}}{a_{22}} &amp; 0 &amp; \\cdots &amp; -\\frac{a_{2\r\nn}}{a_{22}} \\\\\r\n\\vdots&amp;\\vdots&amp;&amp;\\vdots\\\\\r\n-\\frac{a_{n 1}}{a_{n n}} &amp; -\\frac{a_{n 2}}{a_{n n}} &amp; \\cdots\r\n&amp; 0\r\n\\end{array}\\right)\r\n\\]\r\n即\\((B_J)_{ij}=-\\frac{a_{ij}}{a_{ii}},j\\neq\r\ni,\\quad (B_J)_{ii}=0,i=1,\\cdots,n\\) 于是, \\[||B_J||_{\\infty}=\\max_{1\\leq i\\leq\r\nn}\\]\r\n\r\n考虑Jacobi迭代矩阵\\(B_J=I-D^{-1}(L+U)\\),其特征多项式为:\r\n\r\n\\[\r\n\\begin{split}\r\n  P_{B_J}(\\lambda)&amp;=|\\lambda I-B_J|=|\\lambda I-D^{-1}(L+U)|\\\\\r\n  &amp;=|D^{-1}\\lambda D-D^{-1}(L+U)|\\\\\r\n  &amp;=|D^{-1}||\\lambda D-L-U|\r\n\\end{split}\r\n\\]\r\n因\\(A\\)严格列对角占优,则\\(|a_{jj}|&gt;\\) ????????????????????\r\nGauss-Seidel 迭代\r\nGuass-Seidel 迭代公式\r\n迭代矩阵及收敛定理\r\n定理:若\\(A\\)为严格的行或者列对角占优,则Guass-Seidel迭代收敛.\r\nProof: 若\\(A\\)为严格行对角占优,考虑Guass-Seidel的迭代矩阵,\r\n\\[B_G=(D-L)^{-1}U\\] 其特征多项式为\r\n\\[\\begin{split}\r\n  P_{B_G}(\\lambda)&amp;=|\\lambda I-B_G|=|\\lambda I-(D-L)^{-1}U|\\\\\r\n  &amp;=|\\lambda (D-L)^{-1}(D-L)-(D-L)^{-1}U|\\\\\r\n  &amp;=|(D-L)^{-1}(\\lambda D-\\lambda L-U)|\\\\\r\n  &amp;=|(D-L)^{-1}||\\lambda D-\\lambda L-U|\r\n\\end{split}\\] 因为\\(D-L\\)为下三角矩阵,显然\\(|D-L|=a_{11}\\cdots a_{nn}\\) 记\\(C=\\lambda D-\\lambda L-U\\), \\[\r\nC=\\begin{pmatrix}  \r\n  \\lambda a_{11}&amp; a_{12}&amp; \\cdots  &amp; a_{1n} \\\\  \r\n  \\lambda a_{21}&amp; \\lambda a_{22}&amp;  &amp; \\vdots \\\\  \r\n  \\vdots &amp; \\vdots &amp;  &amp; a_{n-1n} \\\\  \r\n  \\lambda a_{n1}&amp; \\lambda a_{n2}&amp; \\cdots  &amp; \\lambda a_{nn}  \r\n\\end{pmatrix}  \r\n\\] 于是\\(|C|=0\\)的根就是\\(B_G\\)的特征值.由收敛矩阵的判定定理,当\\(|C|=0\\)时,有\\(|\\lambda| &lt; 1\\),因为,如果有\\(|\\lambda|\\geq 1\\),则 \\[\r\n\\begin{split}\r\n|C_{ii}|&amp;=|\\lambda||a_{ii}|&gt;|\\lambda|(\\sum_{j=1}^{i-1}|a_{ij}|+\\sum_{j=i+1}^{n}|a_{ij}|)\\\\\r\n&amp;\\geq \\sum_{j=1}^{i-1}|\\lambda\r\na_{ij}|+\\sum_{j=i+1}^{n}|a_{ij}|=\\sum_{j\\neq i}|C_{ii}|\r\n\\end{split}\r\n\\] 于是可得\\(C\\)为严格对角占优矩阵,那么由之前的命题可知\\(C\\)为非奇异阵,即\\(|C|\\neq 0\\),矛盾.\r\n定理:若\\(A\\)为对称正定阵,则Guass-Seidel迭代收敛.\r\nProof: 记\\(v\\)为\\(B_G=(D-L)^{-1}U\\)从属于特征值\\(\\lambda\\)的特征向量,即 \\[(D-L)^{-1}Uv=\\lambda v\\] 变形 \\[Uv=\\lambda (D-L)v\\] 因为\\(A\\)对称,所以有\\(U=L^T\\),于是 \\[L^T v=\\lambda (D-L)v\\] 上式左乘\\(v^*=\\bar{v}^T\\),得 \\[v^*L^Tv=\\lambda v^*(D-L)v\\] \\[v^*L^Tv=\\lambda v^*Dv-\\lambda v^*Lv\\qquad\r\n(*)\\] 记\\(\\delta=v^*Dv=\\sum_{i=1}^{n}\\bar{v_i}a_{ii}v_i=\\sum_{i=1}^{n}a_{ii}|v_i|^2&gt;0\\)(因为\\(A\\)正定,其对角线元素大于零) 记\\(v^*Lv=\\alpha+i\\beta\\)可以发现, \\(v^*L^Tv=v^*L^*v=(Lv)^*v=(Lv,v)=\\bar{(v,Lv)}=\\bar{v^*Lv}=\\bar{\\alpha+i\\beta}=\\alpha-i\\beta\\)\r\n则\\((*)\\)式化为, \\[\r\n\\lambda(\\delta-\\alpha-i\\beta)=\\alpha-i\\beta\r\n\\] 两边取模的平方得, \\[\r\n|\\lambda|^2((\\delta-\\alpha)^2+\\beta^2)=\\alpha^2+\\beta^2\r\n\\] 因为\\(A\\)正定,则有 \\[\\begin{split}\r\n0&lt;v^*Av&amp;=v^*(D-L-U)v\\\\\r\n&amp;=v^*Dv-v^*Lv-v^*L^Tv\\\\\r\n&amp;=\\delta-(\\alpha+i\\beta)-(\\alpha-i\\beta)\\\\\r\n&amp;=\\delta-2\\alpha\r\n\\end{split}\\] 考虑到, \\[\\begin{split}\r\n&amp;((\\delta-\\alpha)^2+\\beta^2)-(\\alpha^2+\\beta^2)\\\\\r\n&amp;=\\delta^2-2\\delta\\alpha\\\\\r\n&amp;=\\delta(\\delta-2\\alpha)\\\\\r\n&amp;&gt;0\r\n\\end{split}\\] 即,\\(((\\delta-\\alpha)^2+\\beta^2)&gt;\\alpha^2+\\beta^2\\)\r\n从而应有\\(|\\lambda|&lt;1\\),迭代收敛性得证.\r\n逐次超松驰迭代(SOR)\r\nSOR是Gauss-Seidel迭代的加速.\r\n计算公式\r\n迭代矩阵\r\n\\[B_{SOR}=(D-\\omega\r\nL)^{-1}((1-\\omega)D+\\omega U)\\]\r\n收敛定理\r\n定理:SOR迭代的 必要条件是: \\[0&lt;\\omega&lt;2\\]\r\nProof: 若SOR迭代收敛,则有\\(\\rho(B_{SOR})&lt;1\\),记SOR迭代矩阵的特征值为,\r\n\\[\\lambda_1,\\cdots,\\lambda_n\\]\r\n则,\\(det(B_{SOR})=\\lambda_1\\cdots\\lambda_n\\)\r\n于是, \\[|det(B_{SOR})|=|\\lambda_1\\cdots\\lambda_n|\\leq\r\n\\rho^n(B_{SOR})\\] 即, \\[|det(B_{SOR})|^{\\frac{1}{n}}\\leq\r\n\\rho(B_{SOR})&lt;1\\] 另一方面, \\[\r\ndet(B_{SOR})=det((D-\\omega L)^{-1})det((1-\\omega)D+\\omega U)\r\n\\] 而, \\[det((D-\\omega\r\nL)^{-1})=1/(a_{11}\\cdots a_{nn})\\] \\[det((1-\\omega)D+\\omega U)=(1-\\omega)^n\r\n(a_{11}\\cdots a_{nn})\\] 于是得到, \\[det(B_{SOR})=det((D-\\omega\r\nL)^{-1})det((1-\\omega)D+\\omega U)=(1-\\omega)^n\\] 故有, \\[\r\n|(1-\\omega)^n|^{\\frac{1}{n}}&lt;1\r\n\\] \\[0&lt;\\omega&lt;2\\]\r\n注记：\\(det(A)=\\lambda_1\\cdots\\lambda_n\\)\r\n证明: 记\\(A=TJT^{-1}\\),其中\\(T\\)为可逆矩阵,\\(J\\)为若尔当阵. \\[det(A)=det(J)=det(J_1)\\cdots\r\ndet(J_r)=\\lambda_1^{n_1}\\cdots\\lambda^{n_r}_r\\] 其中\\(n_1+\\cdots+n_r=n\\),重根按重数算即得,\\(det(A)=\\lambda_1\\cdots\\lambda_n\\).\r\n定理:若\\(A\\)为对称正定阵,\\(0&lt;\\omega&lt;2\\),则SOR迭代收敛.\r\nProof:与上面的定理证明类似,只需要考虑, \\[B_{SOR}=(D-\\omega L)^{-1}((1-\\omega)D+\\omega\r\nU)\\] 的谱半径.\r\n迭代停止准则及收敛速度\r\n迭代停止准则\r\n定理:若\\(X^{(k+1)}=BX^{(k)}+d,k=0,1,\\cdots\\),满足\r\n\\[||B||\\overset{\\Delta}{=}L&lt;1\\]\r\n则有, \\[\r\n\\begin{split}\r\n(1&amp;)||X^*-X^{(k)}||\\leq\\frac{L}{1-L}||X^{(k)}-X^{(k-1)}||\\\\\r\n(2&amp;)||X^*-X^{(k)}||\\leq\\frac{L^k}{1-L}||X^{(1)}-X^{(0)}||\r\n\\end{split}\r\n\\] 其中\\(X^*\\)为\\(AX=b\\)的精确解.\r\nProof:考虑\\(||X^{(k+1)}-X^{(k)}||\\),\r\n\\[\\begin{split}\r\n||X^{(k+1)}-X^{(k)}||&amp;=||X^*-X^{(k)}-(X^*-X^{(k+1)})||\\\\\r\n&amp;\\geq||X^*-X^{(k)}||-||X^*-X^{(k+1)}||\\\\\r\n&amp;=||X^*-X^{(k)}||-||(BX^{*}+d)-(BX^{(k)}+d)||\\\\\r\n&amp;=||X^*-X^{(k)}||-||B(X^{*}-X^{(k)})||\\\\\r\n&amp;\\geq ||X^*-X^{(k)}||-||B||||X^{*}-X^{(k)}||\r\n\\end{split}\\]\r\n于是, \\[||X^*-X^{(k)}||\\leq\\frac{1}{1-L}||X^{(k+1)}-X^{(k)}||\\\\\\]\r\n\\[=\r\n\\frac{1}{1-L}||B(X^{(k)}-X^{(k-1)})||\\leq\\frac{L}{1-L}||X^{(k)}-X^{(k-1)}||\\]\r\n(1)得证.又容易发现, \\[\\frac{L}{1-L}||X^{(k)}-X^{(k-1)}||=\\frac{L}{1-L}||B(X^{(k-1)}-X^{(k-2)})||\\leq\\frac{L^2}{1-L}||X^{(k-1)}-X^{(k-2)}||\\]\r\n如此反复就可以得到(2).\r\n迭代收敛速度\r\n\\[\r\ne^{(k+1)}=X^*-X^{(k+1)}=B(X^*-X^{(k)})=Be^{(k)}=\\cdots=B^{k+1}e^{(0)}\r\n\\] 即, \\[\r\n||e^{(k)}||=||B^{k}e^{(0)}||\\leq\r\n||B^{k}||||e^{(0)}||\\leq||B||^k||e^{(0)}||&lt;\\delta\r\n\\] 当迭代收敛时只需考虑\\(||B||^k&lt;\\delta\\), 因\\(B^k=TJ^kT^{-1}\\)反映了特征值\\(\\lambda_i\\) 可考虑\\(\\rho^k(B)&lt;\\delta\\)且\\(\\rho(B)&lt;1,k\\)为迭代次数, 取对数有,\\(k\\lg\\rho(B)&lt;\\lg\\delta\\),即\\(k&gt;\\frac{\\lg\\delta}{\\rho(B)}=\\frac{-\\lg\\delta}{-\\rho(B)}\\)\r\n称,\\(R(B)=-\\lg\\rho(B)\\)为迭代法\\(X^{(k+1)}=BX^{(k)}+d\\)的收敛速度.\r\n最速下降法及共轭梯度法\r\n对称正定方程组的求解\r\n等价性定理\r\n对\\(AX=b\\),考虑二次型 \\[f(X)=\\frac{1}{2}(AX,X)-(b,X)=\\frac{1}{2}\\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}x_ix_j-\\sum_{j=1}^{n}b_jx_j\\]\r\n其中\\(A\\)对称正定,\\((X,Y)=X^TY\\)\r\n引理:若\\(A\\)对称正定,则 (1)\\((AX,Y)=(AY,X)\\) (2)\\(\\forall x,y\\in R^{n}\\)及\\(r\\in R\\),有 \\[f(X+tY)=\\frac{t^2}{2}(AY,Y)-t(b-AX,Y)+f(X)\\]\r\n(3)\\(\\nabla\r\nf(X)=AX-b\\overset{\\Delta}{=}-r\\),其中\\(r=-\\nabla f(X)=b-AX\\).\r\nProof: (1) \\[\r\n(AX,Y)=X^TA^TY=X^TAY=(X^TAY)^T=Y^TA^TX=(AY,X)\r\n\\] (2) \\[\r\n\\begin{split}\r\nf(X+tY)=&amp;\\frac{1}{2}(A(X+tY),X+tY)-(b,X+tY)\\\\\r\n=&amp;\\frac{1}{2}(AX,X)+\\frac{t}{2}(AY,X)+\\frac{t}{2}(AX,Y)+\\frac{t^2}{2}(AY,Y)-(b,X)-t(b,Y)\\\\\r\n=&amp;\\frac{1}{2}(AX,X)-(b,X)+t(AX,Y)-t(b,Y)+\\frac{t^2}{2}(AY,Y)\\\\\r\n=&amp;f(X)+\\frac{t^2}{2}(AY,Y)-t(b-AX,Y)\r\n\\end{split}\r\n\\] (3) \\[f(X)=\\frac{1}{2}(AX,X)-(b,X)=\\frac{1}{2}\\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}x_ix_j-\\sum_{j=1}^{n}b_jx_j\\]\r\n而, \\[\r\n\\nabla f(X)=\\begin{pmatrix}\r\n\\frac{\\partial f}{\\partial x_1} \\\\\r\n\\vdots\\\\\r\n\\frac{\\partial f}{\\partial x_n}\r\n\\end{pmatrix}=AX-b\r\n\\] 验证起来是简单的.\r\n定理:(等价性定理)若\\(A\\)对称正定,则求\\(AX=b\\)的解\\(X^*\\)等价于求 \\[f(X)=\\frac{1}{2}(AX,X)-(b,X)\\]\r\n的最小点\\(X^*\\).\r\n证明:\r\n最速下降法\r\n\\(\\nabla\r\nf(X)=AX-b\\overset{\\Delta}{=}-r,\\quad\\)\\(r=-\\nabla f(X)=b-AX\\). \\(\\nabla f(X)\\)为函数增长最快的方向, \\(r=-\\nabla\r\nf(X)\\)为函数下降最快的方向,所以写成这种形式。\r\n","categories":["Math","数值代数"],"tags":["数值代数"]},{"title":"23.6.7 Baire 空间的性质","url":"/2023/06/07/23.6.7%20Baire%20%E7%A9%BA%E9%97%B4%E7%9A%84%E6%80%A7%E8%B4%A8/","content":"前置概念\r\nBarie空间\r\n定义：称拓扑空间\\(E\\)是一个 Baire\r\n空间,若\\(E\\)中任意 、\r\n可数多个 、 稠密  、\r\n开集的交仍然在\\(E\\)中稠密。\r\n稠密\r\n设\\(A,B\\)为度量空间\\(E\\)中的集合，如果有\\(\\bar{B}= A\\) ，则称\\(B\\)在\\(A\\)中稠密。（我们使用这种稠密的定义）\r\n要证明下面定理，我们需要注意到稠密的一种等价表述为：如果\\(A\\)中任意开集与\\(\\bar{B}\\)的交集非空，称\\(B\\)在\\(A\\)稠密。\r\nBaire 空间的性质\r\n定理\r\n定理：设  \\(E\\)  是 Baire 空间, 则\r\n(1)  \\(E\\)  的任意开子集也是一个 Baire\r\n空间. (2) 设  \\(\\left(F_{n}\\right)_{n\r\n\\geqslant 1}\\)  是  \\(E\\)\r\n 的一列闭子集, 并且  \\(E=\\bigcup_{n \\geqslant\r\n1} F_{n}\\) , 那么  \\(\\bigcup_{n\r\n\\geqslant 1} \\stackrel{\\circ}{F}_{n}\\)  在  \\(E\\)  中 稠密。\r\n证明\r\nProof (1) 设 \\(\\Omega\\) 是 \\(E\\) 中开集, \\(\\left(O_{n}\\right)_{n \\geqslant 1}\\)\r\n是任意一列在 \\(\\Omega\\) 中稠密的开子集.\r\n由于 \\(\\Omega\\) 是开集, 令\r\n\\[U_{n}=O_{n} \\cup\r\n\\bar{\\Omega}^{c}\\]\r\n则 \\(U_{n}\\) 显然是 \\(E\\) 中开集, 且有 \\[\r\n\\overline{U_{n}}=\\overline{O_{n}} \\cup \\bar{\\Omega}^{c}=\\Omega\\cup\r\n\\bar{\\Omega}^{c}=E\r\n\\] 因此 \\(\\left(U_{n}\\right)_{n\r\n\\geqslant 1}\\) 是 \\(E\\)\r\n的一列稠密开子集. 因 \\(E\\) 是 Baire\r\n空间, \\(\\bigcap_{n \\geqslant 1} U_{n}\\)\r\n依然在 \\(E\\) 中稠密. 而\r\n\\[\\bigcap_{n \\geqslant 1}\r\nU_{n}=\\left(\\bigcap_{n \\geqslant 1} O_{n}\\right) \\cup\r\n\\bar{\\Omega}^{c}\\]\r\n由此推出 \\(\\bigcap_{n \\geqslant 1}\r\nO_{n}\\) 在 \\(\\Omega\\)\r\n中稠密。因为，如果不稠密，那么 \\[\\overline{\\bigcap_{n \\geqslant 1}\r\nU_{n}}=\\overline{\\left(\\bigcap_{n \\geqslant 1} O_{n}\\right) }\\cup\r\n\\bar{\\Omega}^{c}\\neq E\\] 即 \\[\r\n\\overline{\\left(\\bigcap_{n \\geqslant 1} O_{n}\\right) }\\neq \\Omega\r\n\\] 这与我们假设\\(\\left(O_{n}\\right)_{n\r\n\\geqslant 1}\\) 是任意一列在 \\(\\Omega\\) 中稠密的开子集矛盾。\r\n\r\n任取 \\(E\\) 中非空开集 \\(\\Omega\\), 则\r\n\r\n\\[\\Omega=\\Omega \\cap E=\\bigcup_{n\r\n\\geqslant 1}\\left(\\Omega \\cap F_{n}\\right) \\] 由于 \\(F_{n}\\) 是闭集, 则 \\(\\Omega \\cap F_{n}\\) 也是 \\(\\Omega\\) 中闭集. 由 (1) 可知开集 \\(\\Omega\\) 也是 Baire 空间, 那么必存在某个\r\n\\(n\\), 使得 \\(\\left(\\Omega \\cap F_{n}\\right)^{\\circ} \\neq\r\n\\varnothing\\). 注意此处的内部是关于 \\(\\Omega\\) 上的拓扑取的. 但由于 \\(\\Omega\\) 是 \\(E\\) 中开集, 则 \\(\\Omega \\cap F_{n}\\) 在 \\(\\Omega\\) 中的内部也是其在 \\(E\\) 中的内部. 那 么 \\(\\Omega \\cap F_{n}\\) 在 \\(E\\) 中的内部也非空, 即有 \\(\\Omega \\cap \\stackrel{\\circ}{F}_{n} \\neq\r\n\\varnothing\\). 故 \\(\\bigcup_{n\r\n\\geqslant 1} \\stackrel{\\circ}{F}_{n}\\) 在 \\(E\\) 中稠密。\r\n","categories":["Math","泛函"],"tags":["深夜食堂"]}]